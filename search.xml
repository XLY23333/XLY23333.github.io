<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数模M01-评价模型</title>
    <url>/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/M01-%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="评价模型"><a href="#评价模型" class="headerlink" title="评价模型"></a>评价模型</h1><h2 id="一、层次分析法-AHP"><a href="#一、层次分析法-AHP" class="headerlink" title="一、层次分析法 AHP"></a>一、层次分析法 AHP</h2><blockquote>
<p>学习源Video:<a href="https://www.bilibili.com/video/BV1qy4y1a7JJ?p=23&amp;vd_source=1437b1798845fbcba4cf09d5a889e546">Bilibili-ln异教徒 <strong>AHP</strong></a></p>
</blockquote>
<p>作用：层次分析法用来进行决策，求指标的权重</p>
<p>模型建立步骤：</p>
<ul>
<li><p>建立层次结构</p>
<ul>
<li>将决策问题分为三个部分：目标层、准则层和指标层/方案层</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/XLY23333/picture01/img01/AHPeg01.png" style="zoom: 50%;" /></p>
</li>
<li><p>对准则层构建判断矩阵</p>
<ul>
<li><p>判断矩阵为两两指标重要性的判断，一般判别矩阵构造如下：</p>
<script type="math/tex; mode=display">
A=(a_{ij}) _{m\times n}=
\begin{pmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{n1} & a_{n2} & \cdots & a_{nn}
\end{pmatrix}</script></li>
</ul>
<p>九级标度法表格</p>
<p>| 标度             | 含义                                      |<br>| ———————— | ————————————————————- |<br>| 1                | i和j具有<strong>相同</strong>的重要性(Eg:主对角线元素) |<br>| 3                | i比j<strong>稍微</strong>重要                          |<br>| 5                | i比j<strong>明显</strong>重要                          |<br>| 7                | i比j<strong>强烈</strong>重要                          |<br>| 9                | i比j<strong>极端</strong>重要                          |<br>| 2、4、6、8       | 上述标度的<strong>中间量</strong>                      |<br>| $\frac{1}{标度}$ | 矩阵下三角<strong>对称位置</strong>的值                |</p>
</li>
<li><p>一致性检验（特征根法）</p>
<blockquote>
<p>在通过主观想法确定两个属性之间的重要性差距标度时，可能出现不一致的情况，需要用一致性检验对所得的判断矩阵进行一致性的检验，确定所得的判断矩阵能够使用</p>
<p>一致性的例子：A~12~=2, A~13~=2,那么说明1 对 2和3 的重要程度相同，可以推出2和3的重要程度相同，</p>
<p>​                          即A~23~ = A~32~ =1，如果该值不为1则说明其不一致。</p>
</blockquote>
<p>用对应于A的最大特征根（记为$\lambda$）的特征向量（归一化后）作为权向量$w$，即$w$满足</p>
<script type="math/tex; mode=display">
A\lambda = \lambda w</script><p>当 $\lambda = n$ 时，该判断矩阵为一致阵，且任何判断矩阵的最大特征根 $\lambda\ge n$ 。因此，当最大特征根比 $n$ 大得多时，该判断矩阵的不一致程度越严重，所以可以用 $\lambda - n$ 的数值来衡量判断矩阵的不一致程度，并将</p>
<script type="math/tex; mode=display">
CI = \frac{\lambda_{\max}-n}{n-1}</script><p>作为一致性指标，当$CI=0$时判断矩阵为一致阵，并引入随机一致性指标$RI$，$RI$数值如下：</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>$n$</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>$RI$</td>
<td>0.58</td>
<td>0.9</td>
<td>1.12</td>
<td>1.24</td>
<td>1.32</td>
<td>1.41</td>
<td>1.45</td>
</tr>
</tbody>
</table>
</div>
<p>  将它的一致性指标$CI$与同阶（指$n$相同）的随机一致性指标$RI$之比称为一致性比率$CR$，当</p>
<script type="math/tex; mode=display">
  CR = \frac{CI}{RI}<0.1</script><p>  时，认为该判断矩阵的不一致程度在容许范围之内，可以用其特征向量作为权向量。最终得到每个指标的权重结果。</p>
<ul>
<li><ul>
<li>方法一：使用MATLAB的<code>eig()</code>方法直接求得特征根 $v$和特征向量$d$，随后通过求取特征向量和特征值的所在列，计算<code>w = v(:,loc)/sum(v(:,loc));</code>得到转为行向量，即权向量res_A。</li>
</ul>
</li>
</ul>
<p>​    <strong><em>Matlab-ModelCode</em></strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% 判断矩阵导入</span></span><br><span class="line">A = [<span class="number">1</span>   <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">     <span class="number">4</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">6</span> <span class="number">6</span></span><br><span class="line">     <span class="number">4</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">6</span> <span class="number">6</span></span><br><span class="line">     <span class="number">1</span>/<span class="number">2</span> <span class="number">1</span>/<span class="number">6</span> <span class="number">1</span>/<span class="number">6</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">     <span class="number">1</span>/<span class="number">2</span> <span class="number">1</span>/<span class="number">6</span> <span class="number">1</span>/<span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"><span class="comment">%% 一致性检验</span></span><br><span class="line">n = <span class="built_in">length</span>(A);</span><br><span class="line">[v, d] = eig(A); <span class="comment">% 计算特征根和特征向量</span></span><br><span class="line">[temp, loc] = <span class="built_in">max</span>(<span class="built_in">max</span>(d)); <span class="comment">% 返回loc为特征向量的所在列</span></span><br><span class="line">r = temp; <span class="comment">% 得到lambda_max的值</span></span><br><span class="line">CI = (r-n)/(n<span class="number">-1</span>); <span class="comment">% 计算一致性指标CI</span></span><br><span class="line">RI = [<span class="number">0</span> <span class="number">0</span> <span class="number">0.58</span> <span class="number">0.90</span> <span class="number">1.12</span> <span class="number">1.24</span> <span class="number">1.32</span> <span class="number">1.41</span> ... <span class="comment">% 换行输入</span></span><br><span class="line">      <span class="number">1.45</span> <span class="number">1.49</span> <span class="number">1.52</span> <span class="number">1.54</span> <span class="number">1.56</span> <span class="number">1.58</span> <span class="number">1.59</span>]; <span class="comment">% 引入随机一致性指标RI</span></span><br><span class="line">CR = CI/RI(n); <span class="comment">% 计算一致性比率CR</span></span><br><span class="line"><span class="keyword">if</span> CR &lt; <span class="number">0.1</span> || n == <span class="number">2</span> <span class="comment">% 确定其一致性比率&lt;0.1或只含有两个元素，两个元素一定一致</span></span><br><span class="line">    CR_Result = <span class="string">&#x27;Pass&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    CR_Result = <span class="string">&#x27;Nope&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 权向量计算</span></span><br><span class="line">w = v(:,loc)/sum(v(:,loc));</span><br><span class="line">w = w&#x27;;</span><br><span class="line"><span class="comment">%% DispResult</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;---------AHP---------&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;CI: &#x27;</span> num2str(CI)]) <span class="comment">% 一致性指标</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;CR: &#x27;</span> num2str(CR)]) <span class="comment">% 一致性比率</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;CR_Result: &#x27;</span> num2str(CR_Result)]) <span class="comment">% 一致性检验结果</span></span><br><span class="line"><span class="keyword">if</span> CR_Result == <span class="string">&#x27;Pass&#x27;</span> <span class="comment">% 若一致性检验通过则输出特征值和权向量</span></span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;lambda: &#x27;</span> num2str(r)]) <span class="comment">% 特征值</span></span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;w: &#x27;</span> num2str(w)]) <span class="comment">% 权向量</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>方法二：算术平均法求权重</li>
</ul>
</li>
</ul>
<blockquote>
<p>将判断矩阵按照列归一化$\to$将归一化的结果按行求和$\to$每个元素除以n</p>
</blockquote>
<script type="math/tex; mode=display">
w_i =  \frac{1}{n}\sum\limits_{j=1}^n\frac{a_{ij}}{\sum\limits^n_{k=1}a_{kj}}\quad\quad(i=1,2,\cdots,n)</script><ul>
<li>对指标层/方案层的内容构建<ul>
<li>每一个准则层性质中 多个指标间的判断矩阵并进行AHP（多个准则，每个准则指向多个指标）</li>
<li>每一个准则层性质的 每个方案间的判断矩阵并进行AHP（多个准则，多个主责指向多个方案）</li>
</ul>
</li>
<li>将准则层/方案层的每一个准则性质的$w$转成行向量<ul>
<li>准则层的所有值$w$值构成权向量res_B</li>
<li>方案层纵向拼接，所得的即为方案曾的权矩阵res_B，</li>
</ul>
</li>
<li>计算最终得分/综合权重<ul>
<li>指标：res_A(指标层集的大类准则)$\times$res_B所得结果</li>
<li>方案：res_A$\times$res_B得到综合权重res_Z</li>
</ul>
</li>
</ul>
<hr>
<h2 id="二、熵权法-EWM"><a href="#二、熵权法-EWM" class="headerlink" title="二、熵权法 EWM"></a>二、熵权法 EWM</h2><blockquote>
<p>学习源Video:<a href="https://www.bilibili.com/video/BV1qy4y1a7JJ?p=24&amp;vd_source=1437b1798845fbcba4cf09d5a889e546">Bilibili-ln异教徒 <strong>EWM</strong></a></p>
</blockquote>
<ul>
<li><p>数据的归一化处理</p>
<blockquote>
<p>由于各项指标计量单位并不统一，因此在计算综合权重前先要对它进行标准化处理，即把指标的绝对值转化为相对值，并令 $x{\small ij} = |x{\small ij}|$ ，从而解决各项不同质指标的同质化问题。</p>
</blockquote>
<ul>
<li><p>方法一：</p>
<p>由于正向指标和负向指标数值代表的含义不同（正向指标数值越高越好，负向指标数值越低越好），因此对于高低需求指标应当采取不同的算法进行数据标准化处理，具体处理方法为 :</p>
<p>对于正向指标：</p>
<script type="math/tex; mode=display">
x_{ij} = 0.998\frac{x_{ij}-\min\{x_{1j},\cdots,x_{nj}\}}{\max\{x_{1j},\cdots,x_{nj}\}-\min\{x_{1j},\cdots,x_{nj}\}}+0.002</script><p>对于负向指标：</p>
<script type="math/tex; mode=display">
x_{ij} = 0.998\frac{\max\{x_{1j},\cdots,x_{nj}\}-x_{ij}}{\max\{x_{1j},\cdots,x_{nj}\}-\min\{x_{1j},\cdots,x_{nj}\}}+0.002</script></li>
</ul>
</li>
</ul>
<blockquote>
<p>通常会采用一些稍微小一点的值来代替 0 和 1，以便更好地保留原始数据的分布特征。</p>
<p>且直接使用 0 和 1 作为归一化后的极值，可能会导致数据过于集中在边界附近，失去了部分信息。</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Matlab的归一化自定义函数 # Gy.m</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">Gy</span><span class="params">(x,type,ymin,ymax)</span></span></span><br><span class="line"><span class="comment">% 实现正向或负向指标归一化，返回归一化后的数据矩阵</span></span><br><span class="line"><span class="comment">% x为原始数据矩阵，一行代表一个样本，每列代表一种指标</span></span><br><span class="line"><span class="comment">% type设定正向指标1，负向指标2</span></span><br><span class="line"><span class="comment">% ymin，ymax为归一化的区间端点</span></span><br><span class="line">[n, m] = <span class="built_in">size</span>(x);</span><br><span class="line">y = <span class="built_in">zeros</span>(n,m);</span><br><span class="line">xmin = <span class="built_in">min</span>(x);</span><br><span class="line">xmax = <span class="built_in">max</span>(x);</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">type</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:m</span><br><span class="line">            y(:,<span class="built_in">j</span>)=(ymax-ymin)*(x(:,<span class="built_in">j</span>)-xmin(<span class="built_in">j</span>))/(xmax(<span class="built_in">j</span>)-xmin(<span class="built_in">j</span>))+ymin;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    case2</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:m</span><br><span class="line">            y(:,<span class="built_in">j</span>)=(ymax-ymin)*(xmax(<span class="built_in">j</span>)-x(:,<span class="built_in">j</span>))/(xmax(<span class="built_in">j</span>)-xmin(<span class="built_in">j</span>))+ymin;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法二：Python scikit-learn MinMaxScaler</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据归一化(sklearn)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line">data = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">        [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">        [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],]</span><br><span class="line"><span class="comment"># 如果data为单列则需添加.values.reshape(-1,1)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>,data[:<span class="number">5</span>]) <span class="comment"># 展示前五个数据</span></span><br><span class="line"></span><br><span class="line">MM_Scaler = MinMaxScaler(feature_range=(<span class="number">0</span>,<span class="number">1</span>)) <span class="comment"># 默认缩放范围(0,1)</span></span><br><span class="line">MMres = MM_Scaler.fit_transform(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;MMres:&#x27;</span>,np.<span class="built_in">round</span>(MMres[:<span class="number">5</span>,],<span class="number">2</span>)) <span class="comment"># 展示前五个数据,保留3位小数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>计算第$j$项指标下第$i$方案指标值的比重$p_{ij}$</p>
<script type="math/tex; mode=display">
p_{ij} = \frac{x_{ij}}{\sum\limits^n_{i=1}x_{ij}}\quad(j=1,2,\cdots,m)</script></li>
<li><p>计算第$j$项指标的熵值$e_j$</p>
<script type="math/tex; mode=display">
e_j = -k\sum^n_{i=1}p_{ij}\ln p_{ij}\quad(j=1,2,\cdots,m)</script><p>其中$k=\dfrac{1}{\ln(n)}$，满足$e_j\ge 0$</p>
</li>
<li><p>计算信息熵冗余度$g_{j}$</p>
<script type="math/tex; mode=display">
g_j = 1-e_j\quad(j=1,2,\cdots,m)</script></li>
<li><p>计算各项指标权重$w_j$</p>
</li>
</ul>
<script type="math/tex; mode=display">
w_j =\frac{g_j}{\sum\limits^m_{j=1}g_j}\quad(j=1,2,\cdots,m)</script><ul>
<li>计算综合评分$S_i$<script type="math/tex; mode=display">
S_i = \sum^m_{j=1}w_jx_{ij}</script></li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% DataLoad</span></span><br><span class="line">data = xlsread(<span class="string">&#x27;./HouseData.xlsx&#x27;</span>);</span><br><span class="line"><span class="comment">%% 归一化</span></span><br><span class="line">ind = <span class="built_in">ones</span>(<span class="built_in">size</span>(data,<span class="number">2</span>),<span class="number">1</span>); <span class="comment">% data列数作为RowCount,ColCount=1</span></span><br><span class="line"><span class="comment">% indArr的建立，正向写1，负向写2，在此处默认都是正向指标，所以建立全一的纵向Arr</span></span><br><span class="line"></span><br><span class="line">[n, m] = <span class="built_in">size</span>(data); <span class="comment">% n个样本，m个指标</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">    <span class="keyword">if</span> ind(<span class="built_in">j</span>) == <span class="number">1</span> <span class="comment">% 正向指标的归一化</span></span><br><span class="line">        X(:,<span class="built_in">j</span>) = Gy(data(:,<span class="built_in">j</span>),<span class="number">1</span>,<span class="number">0.002</span>,<span class="number">1</span>); <span class="comment">% 归一化最低值范围不能为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">% 负向指标的归一化</span></span><br><span class="line">        X(:,<span class="built_in">j</span>) = Gy(data(:,<span class="built_in">j</span>),<span class="number">2</span>,<span class="number">0.002</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 熵权法求取权向量</span></span><br><span class="line"><span class="comment">% 计算第j个指标下，第i个样本占该指标的比重p(i,j)</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">        p(<span class="built_in">i</span>,<span class="built_in">j</span>) = X(<span class="built_in">i</span>,<span class="built_in">j</span>)/sum(X(:,<span class="built_in">j</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 计算第j个指标的熵值e(j)</span></span><br><span class="line">k = <span class="number">1</span>/<span class="built_in">log</span>(n);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">    e(<span class="built_in">j</span>) = -k * sum(p(:,<span class="built_in">j</span>).*<span class="built_in">log</span>(p(:,<span class="built_in">j</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">g = <span class="built_in">ones</span>(<span class="number">1</span>,m)-e; <span class="comment">% 计算信息熵冗余度</span></span><br><span class="line">w = g./sum(g); <span class="comment">% 求权值w</span></span><br><span class="line">s = X*w&#x27;; <span class="comment">% 求综合评分</span></span><br><span class="line"><span class="comment">% DispPlot</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;Gyed_Data:&#x27;</span>);<span class="built_in">disp</span>(X)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;p(i,j):&#x27;</span>);<span class="built_in">disp</span>(p)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;e(j):&#x27;</span>);<span class="built_in">disp</span>(e)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;g(j):&#x27;</span>);<span class="built_in">disp</span>(g)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;w(j):&#x27;</span>);<span class="built_in">disp</span>(w)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;s(j):&#x27;</span>);<span class="built_in">disp</span>(s)</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">2017</span>:<span class="number">-1</span>:<span class="number">2010</span>,s)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学建模</category>
        <category>评价模型</category>
      </categories>
      <tags>
        <tag>AHP层次分析法</tag>
        <tag>EWM熵权法</tag>
        <tag>MATLAB</tag>
        <tag>评价模型</tag>
      </tags>
  </entry>
  <entry>
    <title>数模M02-Kmeans聚类</title>
    <url>/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/M02-Kmeans/</url>
    <content><![CDATA[<h1 id="KMeans聚类法"><a href="#KMeans聚类法" class="headerlink" title="KMeans聚类法"></a>KMeans聚类法</h1><h2 id="一、Kmeans内容"><a href="#一、Kmeans内容" class="headerlink" title="一、Kmeans内容"></a>一、Kmeans内容</h2><blockquote>
<p>Video:~<a href="https://www.bilibili.com/video/BV1qy4y1a7JJ?p=25&amp;vd_source=1437b1798845fbcba4cf09d5a889e546">Bilibili-ln异教徒 <strong>Kmeans</strong></a></p>
</blockquote>
<ul>
<li><p>随机生成k个聚类中心点</p>
<ul>
<li><p>其中k值的确定可以采用“手肘法”，通过分析不同k值下误差平方和(SSE)的值的变化，选取其”肘部“作为合适的聚类数目</p>
<script type="math/tex; mode=display">
SSE = \sum_{i=1}^k\sum_{p\in C_i}|p-m_i|^2</script><p>其中$C_i$是第i个类，p是$C_i$中的样本点，$m_i$是$C_i$的质心($C_i$中所有样本点的均值)，SSE是所有样本的聚类误差，代表了聚类效果的好坏。通过找寻SSE的值的下降幅度剧烈减小的位置来判断合适的k取值</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SSE</span> = <span class="title">funcSSE</span><span class="params">(data,total)</span> % <span class="title">data</span>为数据,<span class="title">total</span>为要划分的类别总数</span></span><br><span class="line">n = <span class="built_in">size</span>(data,<span class="number">2</span>); <span class="comment">% data的ColCount</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:total</span><br><span class="line">    k = <span class="built_in">i</span>;</span><br><span class="line">    [label,c] = kmeans(data,k);</span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">i</span> <span class="comment">% 按照分类数量遍历</span></span><br><span class="line">        loc = <span class="built_in">find</span>(label == <span class="built_in">j</span>) <span class="comment">% 找到每个类别所对应的行标(Row)，形成一个Arr</span></span><br><span class="line">        <span class="keyword">for</span> j2 = <span class="number">1</span>:n <span class="comment">% 按照Col遍历</span></span><br><span class="line">            temp = temp + sum((data(loc,j2)-c(<span class="built_in">j</span>,j2)).^<span class="number">2</span>)</span><br><span class="line">            <span class="comment">% 通过loc得到一个row区域内的所有label与c索引相同的数据</span></span><br><span class="line">            <span class="comment">% 依次loc所对应数据块中的每一列与c同列的数据相减并求点成的平方</span></span><br><span class="line">            <span class="comment">% 随后sum求和处理后每一列loc数据的和并且与先前的其他列数据结果相加</span></span><br><span class="line">            <span class="comment">% 将每一个label相同的data和c的结果再相加，全部用temp承接数值</span></span><br><span class="line">            <span class="comment">% 实际上是将原本每一数据点同其c的减法求平方(距离)过程纵向化了</span></span><br><span class="line">            <span class="comment">% 用于矩阵运算的遍历，以及其最终得到的结果就是每个数据每个坐标的距离</span></span><br><span class="line">            <span class="comment">% 所以可以用这种简单的方法Coding</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    SSE(<span class="built_in">i</span><span class="number">-1</span>) = temp <span class="comment">% 令SSE这个Arr的数值仍然从Index=1开始</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>根据聚类中心点，将数据分为k类。分类的原则是数据离哪个中心点最近就将他分为哪一类别</p>
<ul>
<li><p>距离的判断采用欧式距离(欧几里得距离):</p>
<p>令各类中心为 $\mu_j$ ,计算各个数据到各类中心点的距离为$(x-\mu_j)^2$</p>
</li>
</ul>
</li>
<li><p>根据分好的类别的数据，重新计算聚类的类别中心点</p>
</li>
<li><p>不断重复上述的两步，直到中心点不再变化，得到聚类结果</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% 数据导入</span></span><br><span class="line">data = xlsread(<span class="string">&#x27;./k-means.xlsx&#x27;</span>);</span><br><span class="line"><span class="comment">%% SSE手肘法判断</span></span><br><span class="line">km = <span class="number">10</span>; <span class="comment">% 所需的k最大测试值</span></span><br><span class="line">SSE = funcSSE(data,km);</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">2</span>:km,SSE)</span><br><span class="line">k = <span class="number">5</span>; <span class="comment">% 选择 k=5</span></span><br><span class="line"><span class="comment">%% Kmeans聚类</span></span><br><span class="line">[label,center] = kmeans(data,k)</span><br><span class="line"><span class="comment">%% DispPlot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">scatter</span>(<span class="number">0</span>,data(label==<span class="number">1</span>),<span class="string">&#x27;cyan&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">scatter</span>(<span class="number">0</span>,data(label==<span class="number">2</span>),<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">scatter</span>(<span class="number">0</span>,data(label==<span class="number">3</span>),<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"><span class="built_in">scatter</span>(<span class="number">0</span>,data(label==<span class="number">4</span>),<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="built_in">scatter</span>(<span class="number">0</span>,data(label==<span class="number">5</span>),<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:k</span><br><span class="line">    <span class="built_in">plot</span>([<span class="number">-0.1</span>,<span class="number">0.1</span>],[center(<span class="built_in">i</span>),center(<span class="built_in">i</span>)],<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">xlim([<span class="number">-1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、Python可使用代码"><a href="#二、Python可使用代码" class="headerlink" title="二、Python可使用代码"></a>二、Python可使用代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> sklearn</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;Consolas&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Consolas&#x27;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机数据</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.seed(<span class="number">66</span>)</span><br><span class="line">x = [random.randint(<span class="number">1</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line">y = [random.randint(<span class="number">1</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line">data=<span class="built_in">list</span>(<span class="built_in">zip</span>(x,y))</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df.columns = [<span class="string">&#x27;v1&#x27;</span>, <span class="string">&#x27;v2&#x27;</span>]</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手肘法判断图</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> silhouette_score</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line">score01 = [ ]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">7</span>):</span><br><span class="line">    km1 = KMeans(n_clusters=i, random_state=<span class="number">42</span>)</span><br><span class="line">    kcat1 = km1.fit_predict(df)</span><br><span class="line">    score = silhouette_score(df, kcat1)</span><br><span class="line">    score01.append(score)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">7</span>),score01)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">n = <span class="number">4</span></span><br><span class="line">km = KMeans(n_clusters=n, random_state=<span class="number">42</span>)</span><br><span class="line">km.fit(df)</span><br><span class="line">centers = km.cluster_centers_</span><br><span class="line"><span class="built_in">print</span>(centers)</span><br><span class="line">kcat = km.predict(df)</span><br><span class="line">df_cat = pd.concat([df,pd.DataFrame(kcat)],axis=<span class="number">1</span>)</span><br><span class="line">df_cat.columns = <span class="built_in">list</span>(df.columns) + [<span class="string">&#x27;Cate&#x27;</span>]</span><br><span class="line">df_cat.head()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colorg1 = [<span class="string">&#x27;#1f77b4&#x27;</span>, <span class="string">&#x27;#2ca02c&#x27;</span>, <span class="string">&#x27;#ff7f0e&#x27;</span>, <span class="string">&#x27;#7f7f7f&#x27;</span>, <span class="string">&#x27;#9467bd&#x27;</span>]</span><br><span class="line">colorg2 = [<span class="string">&#x27;#2ecc71&#x27;</span>, <span class="string">&#x27;#3498db&#x27;</span>, <span class="string">&#x27;#e74c3c&#x27;</span>, <span class="string">&#x27;#9b59b6&#x27;</span>, <span class="string">&#x27;#f39c12&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    plt.scatter(df_cat[df_cat[<span class="string">&#x27;Cate&#x27;</span>] == i].iloc[:,<span class="number">0</span>],</span><br><span class="line">                df_cat[df_cat[<span class="string">&#x27;Cate&#x27;</span>] == i].iloc[:,<span class="number">1</span>],</span><br><span class="line">                label = <span class="string">f&#x27;Cate<span class="subst">&#123;i&#125;</span>&#x27;</span>,color = colorg1[i],)</span><br><span class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> df_cat[df_cat[<span class="string">&#x27;Cate&#x27;</span>] == i].iterrows():</span><br><span class="line">        plt.plot([row[<span class="string">&#x27;v1&#x27;</span>], centers[i, <span class="number">0</span>]], [row[<span class="string">&#x27;v2&#x27;</span>], centers[i, <span class="number">1</span>]], color=colorg1[i])</span><br><span class="line"></span><br><span class="line">plt.scatter(centers[:,<span class="number">0</span>],centers[:,<span class="number">1</span>],color = <span class="string">&#x27;r&#x27;</span>, s = <span class="number">100</span>, zorder = <span class="number">5</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;KMeans Result&#x27;</span>,size = <span class="number">20</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;V1&#x27;</span>, size = <span class="number">15</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;V2&#x27;</span>, size = <span class="number">15</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.savefig(<span class="string">r&#x27;./PIC.svg&#x27;</span>,dpi=<span class="number">500</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_cat.to_csv(<span class="string">r&#x27;./kmoutput.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="三、Python展开Kmeans聚类"><a href="#三、Python展开Kmeans聚类" class="headerlink" title="三、Python展开Kmeans聚类"></a>三、Python展开Kmeans聚类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成测试数据</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">1</span>)</span><br><span class="line">kdatax = [random.randint(<span class="number">1</span>,<span class="number">30</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)]</span><br><span class="line">kdatay = [random.randint(<span class="number">1</span>,<span class="number">30</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)]</span><br><span class="line">kdata = pd.DataFrame([kdatax,kdatay]).transpose()</span><br><span class="line">plt.plot(kdata.iloc[:,<span class="number">0</span>], kdata.iloc[:,<span class="number">1</span>], <span class="string">&#x27;ro&#x27;</span>)</span><br><span class="line">kdata.head()</span><br><span class="line"></span><br><span class="line">colorg1 = [<span class="string">&#x27;#1f77b4&#x27;</span>, <span class="string">&#x27;#2ca02c&#x27;</span>, <span class="string">&#x27;#ff7f0e&#x27;</span>, <span class="string">&#x27;#7f7f7f&#x27;</span>, <span class="string">&#x27;#9467bd&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">kdata, cen, ax, k</span>):</span><br><span class="line">    plt.plot()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Dep</span>(<span class="params">ax, t, cen,</span>):</span><br><span class="line">    pls = [ ]</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> t:</span><br><span class="line">        dval = [ ]</span><br><span class="line">        dsum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cen)):</span><br><span class="line">            dval.append(np.sqrt(<span class="built_in">sum</span>((cen[i] - d)**<span class="number">2</span>)))</span><br><span class="line">        place =  dval.index(<span class="built_in">min</span>(dval))</span><br><span class="line">        pls.append(place)</span><br><span class="line">    <span class="keyword">return</span> pls</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Init_cen</span>(<span class="params">kdata, k, ax</span>):</span><br><span class="line">    centers = [ ]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        subcenters = [ ]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ax):</span><br><span class="line">            maxval = (kdata.iloc[:,i].<span class="built_in">max</span>())</span><br><span class="line">            minval = (kdata.iloc[:,i].<span class="built_in">min</span>())</span><br><span class="line">            subcenters.append(random.randint(minval,maxval))</span><br><span class="line">        centers.append(subcenters)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Init:&#x27;</span>,centers)</span><br><span class="line">    <span class="keyword">return</span> centers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">KmeansH</span>(<span class="params">kdata, k, seed = <span class="number">0</span>,centers= [<span class="number">0</span>],co = <span class="number">0</span>, ax = <span class="number">0</span>, karray = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span> ax ==<span class="number">0</span>:</span><br><span class="line">        ax = <span class="built_in">len</span>(kdata.columns)</span><br><span class="line">        karray = np.array(kdata)</span><br><span class="line">        <span class="keyword">if</span> seed !=<span class="number">0</span>:</span><br><span class="line">            random.seed(seed)</span><br><span class="line">    <span class="keyword">if</span> co == <span class="number">0</span>:</span><br><span class="line">        centers = Init_cen(kdata, k, ax)</span><br><span class="line">        co = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        co += <span class="number">1</span></span><br><span class="line">    label = Dep(ax, karray, centers)</span><br><span class="line">    kdatanew = pd.concat((kdata,pd.DataFrame(label)),axis=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    cn1 = [ ]     </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        cn2 = [ ]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(ax):</span><br><span class="line">            cn2.append(np.mean(kdatanew[kdatanew.iloc[:,ax]==i].iloc[:,j]))</span><br><span class="line">        cn1.append(cn2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(co,centers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>((np.array(cn1) - np.array(centers)).<span class="built_in">sum</span>()) &lt;= <span class="number">1e-9</span>:</span><br><span class="line">        random.seed()</span><br><span class="line">        <span class="keyword">return</span> kdatanew</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> KmeansH(kdata, k, seed,cn1 , co, ax, karray)</span><br><span class="line">    </span><br><span class="line">k=<span class="number">4</span></span><br><span class="line">kdatak = KmeansH(kdata,k,<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">centers = pd.DataFrame([[<span class="number">25.0</span>, <span class="number">10.416666666666666</span>], [<span class="number">9.555555555555555</span>, <span class="number">24.666666666666668</span>], [<span class="number">14.166666666666666</span>, <span class="number">10.0</span>], [<span class="number">3.0</span>, <span class="number">5.333333333333333</span>]])</span><br><span class="line">centers</span><br><span class="line"></span><br><span class="line">colorg1 = [<span class="string">&#x27;#1f77b4&#x27;</span>, <span class="string">&#x27;#2ca02c&#x27;</span>, <span class="string">&#x27;#ff7f0e&#x27;</span>, <span class="string">&#x27;#7f7f7f&#x27;</span>, <span class="string">&#x27;#9467bd&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line"></span><br><span class="line">    plt.plot(kdatak[kdatak.iloc[:,<span class="number">2</span>]==i].iloc[:,<span class="number">0</span>],</span><br><span class="line">             kdatak[kdatak.iloc[:,<span class="number">2</span>]==i].iloc[:,<span class="number">1</span>],</span><br><span class="line">             <span class="string">&#x27;o&#x27;</span>,color = colorg1[i])</span><br><span class="line"></span><br><span class="line">plt.plot(centers.iloc[:,<span class="number">0</span>],centers.iloc[:,<span class="number">1</span>],<span class="string">&#x27;r*&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学建模</category>
        <category>聚类分析</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>聚类</tag>
        <tag>Kmeans</tag>
        <tag>Kmeans++</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数模M03-Kmeans聚类论文可使用部分</title>
    <url>/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/M03-KmeansPaper/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="027efff8ee900bf8ff98ca7e830e37f8e40b69d685b69fb7bd669cf9b67e7c3a">2d0cc57e0ca0d95b94a86d2858934c236a929973a1341844210faac8bd7bf73c3d510240d6cf5d989f7d63f8c8db6b1b6de20346640f5bf50f274f81c03b231129d482910960ac219e778af4c7db4e28f847ec4295f626227dcafc651a81d083870862d9b60a25c285297c3841c2186709d6ca45d98fdca289c5962b5723b6f48aec913b14d84755eb8cd71be942815bac9bd0d7eb6b8c7ae786515eedee51d009412b6eb977aee6e4f6c389ae3f9d72c603f32c89edc619d1f286ea75e92b853a02a671cd475f25380c155d1bfa5298f5d3b8f93b484b4630c3e9c451f6d0e2d86249a1d58138a2d17c97c0340867ed82348899845dac8bc2e4a20ef38f707fbf85c2cf48bb68c7d33f1262dcdd5caf51f31ca6bcac75f942631e06029498d9d849d228d243b7a54ad4f1135a5fbb686823ba6044d4a90bd35d1679043129a7dc87b8315b58c4700e74da2475ae3a21e9120ac3cef3ffc438106f529f7a86b3a9173a9eadd713d8217c5b149ddd8a54fca18ed0dae1d62cf8f69fceed32219c7a2a5dd070dd4d91f158fbf14f8aa481ce67ac77334906a57342d86e4402b62c72b01fc4a4b603e6fcf4ddfd1614a432e70bf49195bb16f9515cfca4164ca43c6e6fac9c3dc70e3017cfbebbc9006a5e61e879076e86d9b629dc0172a8de77367b33fe1a25a47fa1f70a23bfb721d158d2030e05e9f57b1337ffc949b5dd99e45a153af549b5b7976a7c2dc83b5a62a5600d06148713cd4bcf6536f8209b717b3c7c2db9504290ee1d20bfe47349e9b3ff399a1992618d3ffa00c62e24810d43593838d69e95ab0a19806cccde49f51b0713cd0afb81714a94da0518fa07176b23b86c0cacaaeadabc2001ff9e5d29052f0b1e5d478d69373a9d1bd7ddc3c274f806373d3a1f870dbe2c687c8e3644eefc2ca4d85783949e54959df4be1d59c26f59d19b2382f8c5835ae08c5518a5f06c34c3fd64c6e9e57ea46bb5779fe645d6ef058ea20ef3ad1724765bdc1f7177e2a37930dfe7c116f05674eb22c7cb3b7507df0f87dbf3bd0c5ecea5be20e53e776a8e99197fa8d1ea6d2b57a9a805002a4c9eec6fcd2c482a531f29895b3f16068692f03b8957872a7d00e6176dec7748cea3980390cf0ee4338ce45bab2b05b56f2744bafb090e1689008f851b539e84df08b58ef0b5ae75ca168dd63beefc508566c2fd1937314c9ddaa3698b1b66757eb716de222c953321d26f44cc640668ec7a070762d9c8066fdd4585a77f8306c33e8daa6474b0a78a371c12d7f6bf3f6db5dc0f66a7861de08f0cf2e7d96af1b576ca6c00736045f88d630134c4bc1a05ed3c7987cd399ebd3fa1ea840d3f1f1ac895a0ba064a78c0c96fc6b663cc6b4ee181289dbd9b3397d0fa5331f5caa6612f36981b527b2adf87b56ede9639ac0e1e5d3dcd036c1356eba7cf9cd757716d29af81f0e27cd6dbfeffd583ef2b0cf7fb37635e67c06cd338d1b303f302f511299a6064a3d956d91e102a520ae1aac147e4295d5dc54f6368ebafd0b81d645f632ed81ddf0ce72922a4b4cee7ad47e0f7fa5d4bac21fbf743693cdb7adc036dfca5f49dd88d349842568853c6d918232babada3e62f51a9b6bbee5efdcd6501a3514cf098f4d76a7beaa1aed54dbbd34679d184d3090e89d38bf2b4170b93ece2c0c5cd7a43d3786b131d73c732a674aeaf56a384af5b73a0efff9f7f092cde095c5a7cbe0b30859fd66fe1250cfa467822410b1d9637202f782e5177670d6c715e84e2a8b1ae21b8fdbca545614525c768fc776cb07ff91ac12b808c165514024fa806e2e2708e9b09d3294252a35ea6f6c3b1ae2d6f51f356f228b4757982eb3392f12412b7a3db15d0c20ce97e24d3c55bfe52665ae813b9e76c0ae2c389dea9e04de631adb6a8868342c04181b6412200bbd956d2491fd4f8802f3f9ca4cb739220b81964eec3ab43cc53af23478855c40ee004191f17464101f275a00e0dc40ff56c5c34089444c24a6ec117a79e635ca080456dd9d1485f3494fe3f07551b34b2cff3a23e600363f29b79ba2379a390bffeb9b2a8179719b1993c1216bcf003faaf1723afde94cc075eed93810b3aa622606ea31e971ea7cafd63a4dba40b37582c8ea9c5f3ec14b70250802e1547ffa9e258bef1100d5149239e817d95dac3d9bc66801ae536714ca4c4eb6caf382caa7a82a36d96db930986615f764dbbf3020904678fa527300a537ac0ea64a31d5e6961e22eed3bbbbc904e808e4c6e006553cdef315ddc6a5748a69806573c2246b7ca9ebe727099ff9e1854fabdee68fb28d3844fe9f34094fcfcbb2a0bb820659e752cbd00da30517e3684354e2912545ee04a51d08e33239d1a37bbeae9c731fdca026d6de43a7cfd1de1c1562d6d5faf6673a86fabaf17494d7a5e0e0dc276adf773fb9f20416402d58a75b2601969c48a4b7083646ab12a532682acf80dce0caf0ceda80ab0ef17a3bfe3c93120305610b05d69a88cc35d7600a3ddf21738b2711ea55a8d287f1dc8f4d077c2bc4cd7409f6c76426e7b3ac2b2d4cdee93a1b4aa7477f383ec5a224bff8af7499b85b1e4d3449cd22cb6e0fdc36c2486c2b828f7d5dcb89434c6513fa95bdcd17ad03c978f7c1437c6c7b6b1e058dbbcab01f93f1b09838b781b9ef3e6c66cc6fc9665d167d714720f0e04364ee8df9c62eed98263215a74c2da8ee03279e891a88750b362deacfbb96ea60898b2b36287f7c97d62d92533111cab8b7ad3e11d0e7ec60d444cf7734f613c2007920e513364bd79fa965484a7a17f69399a4938243c1f64c7d646809b79bbe116f765e9cd0530642213fe0eb17e019cde75b750c7dcb9519f5f2ab60caa7a4fd09138ac1feffade0646d41651e2bde14c7ed6219f288d0db6b39c7401123d69e6c5dcba8c16a3dd4b1db219b4da4fe7f42d3ea3c1f2325f564e220afdbeafaa16a20ace8e7b5feb1fc8dee7f1cfed8220b3059f0b24799888cfd3ff3f48e8b9875d992148cb191a0cd19e1f1a114874518ed2479f41ed15d2f51eb4273adc8ae9d2a5120aa7d29334b67af80c420ed3cc12448a24150afdc27d52119008a47123d152962a1c84e2abc0543cad573820e5ac30f7a21d3957d7a5d9f72560f9759b318fde72321fba6628228c8528521a3d8a9e1c4ad7170f4fc1c4f0629b7bdfb41187a82597d91e0343d1ee14819bad418999b624df69f79330c895c99d6d2fff2c91e0122367d6bed3b520b98ead6c6b160e4bfc8999c8bb16b77b1512b8172bc0a576ccf9d4d9410c36b3d3f522db759a9508fcce5b4754bf8fa728950d3c737be07a55bdab673952742aef1c226d3f38227c8768c02f52920dd6be616833c85fe92933b505241244cfcd45052f74fe12c8c8e5a9b65e939d24049c8f9fa541356267e9ebe9619f26a2358db2421b95fd306b31cca6014d2f31c1abbc00dbf52014462f14780b0d0882b9f7b34947e1794d4ea06081b79a30d68941056c372ac1842102f604f0a811d44b623d74864f8318b365af1222f67402e6baf9f453121cc7f3e07a71d6b031eb5bdd888980ca9c8ff6e005f8a53a959acbc066f1c56e4ee95f3ce551fcdb605aad70df5c3d110a7e28d0940735e923bbb9c30d14dc4938e4267bf37829bdf80a6aa4db2f581ef15ade74422acddffe8180a32d1164c408a67606a679f8930e59c599c0e1b6068dda6bc1d3d70929447ed53820852340689d262ade039b12228c3eddc4425e997ae093e529eefba78a6235cace6f0448ac7d51005cde73202d5d59bdcfe707d826390a5e98f27b77ecad918c0cabde424016e5711eeaefec3c262d9098bddbdd75fea652a7b3bd1ac77cc2a6391399abf2856bbaa8a9dd64ee2700ab01258a45e94bd38e433934485aa736b6d8f122da17926cf01d85f24f65ce4c13b1302baf599b4f4938f03952d470c787a6caab185a618222928b51fbb3d0de483f44f2311f48421661a6db55d7eda77c9edf4b526a492a6adba76fe689440e9d40f8700e0f7aaff6cbe4051f1eadb6ca119ddfca7ff88fc0559a5ffdfc8c90e8e83e0b07f66268618b9ab3379a1b45599708cd8ad3f537ded4364ea166b214dbd091594f266a339c133b0d47c7e920c19a2ca570f3f99e487f0c85b91ff7f005228cff9d3968a7280e59e0c582fde67ae93bcb2c500daf7e9066b9f71d1bd5c2af6f0789b2935993a75e1ad4aa95e16eddb4989b978e66a35bd10a8f08bc482e62e4bc72fce412bd2730a84ebb70f852e5403fb1a8e655a81c08d90ae15caa7983778f2d4da4d37834b0b3957828e130f7822f6f8f1421db4a19cbebf07454ce6a34a7f11026370b94af391572b9f3084dd712a56dc013152122f1a091e7bca6cc8f78ae0a30a035f98b698e5cb9ba3af744ed8b7c18f1905dfa963829716be5b6ec86df7128695c1937cf2b2f629735069249c5a5dcd6078edcc0d3faab90bfe96454c4cfdf29574afabf07a0b35bdf987e563b6a6ccea39506f5e9234b51801e81917ae06805c752cfb63b065d0cd84167c4982fec1b685f516b3d6407e04f3fa67eba7ffe7f802d2ef10126922babdf9e7a2af916c3515815213b4ea6b1e3e7ebcb5e887008093e329971113c7b0ebc9d251c3cd0ab9a46ae2d4e1252279a38701af40c986becb6788a4ee7556240786b8859aad2b10e3e8d3543dd860f7fedeeb4bf906a4d9f275b42949a3ae6a44f1b51cfbd422a67075727e2c29eb2da0d93785bc7df0ce627ede7452f2f278e97933a13ae5454dc0a075b56916e93ef603b2ae524b4dfdd158fef3ee8b20e985f7568dd8f7f8feef15bde6416cf88400c65c8a89f179c7586e5846ffca776436cb5aebef79268d2ac72dc6e112b73dfa1c817cc83c5b7d8c646b832a602f98ca5de93b9bf290d61681be699b148bf3efbd92ace0d42fcc3572c6373fafadd7b638e23af6b2592ecd9ec9e482dc40b8c4b6db28fe60ac5187c36d05385f9f9ca292f6b7e63412019cb1d97da3dc7c2cd0ae479d5a95ac5436785edead7f92fa6cba3232c48e680603504c1cca0f2d8efb3fed6755eaaf0950e2dc59615f93152f59c875b79ed0c67bf9a980e4a6403521de1dc1c6b7b455430f88447ec86b8e87b01bb54cad8ea670fbd326dbec3b4a23da77a5b4ab2b3a99e306c6434f33750960dca68feb7fa199acac3754273ddb93edc53dc63e5abaac8729a3db1bddfe2af1ccce8ebc182820b213b7050263ca3aae92c5844c219543e1aecb4e651e3b56a2f5b088f8155c91e37231b97902d2d405ed271ad491a8b72003cdd997be9d605f32c296ef74c3f31c52976e4a39435fb08b0f3b019a5d4910ef212f1d7e6c66aefee09983b37ae871843f2bb74877603334da88f66e71192a71acd27f4adbac7116d7f96dba68ba7dc902e6bc9ead4f4791e9be91edbba45ab452fc78db5b435e7ad533643d6a4f0780320f2fa44433c888f6e065fcb3d7ffb768034f598f6884b0ec3b1a1ac87fafcb3fa711f46049c52483ade5c94450ff0fa21b36e09e6f9989137439c36680c36cc04db81a19777dcea4045d44f2da1b9a746c2715a4a9892fa878f37cc8aee388ef9779485651e81becd78f10ed37148f73e39d605a268186922d693216e1dcbfb41e050827d8f8f376332278d500d199f19e5ccf8c059fc9421c1b1788b7f90bc4383bef20bc939ff60e2ffd60da84c1cbdcf6a483ac12cf46ceecb7eb67adab7dc313df0decefb5f26b5a320ec6d2f8621dd7341d3ec11c71e844ad252a9617e463ed696eac128a46b4bc72ebfeaadedec61e591965dae54135889dac4a5e1b07fe4661e233b7ba3e8b9fd439697180f7148a468b56ae48129a9ade148f3bfd6c62772a07a3d0e8aad8acf265346d14d86af39f36b0eb58dd4b9d6ce44fb35c3fce52efe3f1f38ab79205f74ea787ab5bda936f38c4d19c61cf549eac83e8fff64a9fc8ae934921eac0ff0f8b816713ed26062318bf52030fe99c52f324b52753b3119df6a30488d8f0c24380ffa964e9c7d4ca8187173cbd73ecfe595241c76396d21f3b0c5c78094c893c35459aacad475e19f2672284555341dc36fa71249a960a4a1b0f00bc85854e930ee8f1dfa127d576ef39a155605703a62fb4713309bb3670abc2599b26b36b0e4607602509183983ab3e482d1671f8817113e60830e0ebab43b2143c2f0288534490f5007557e7e8756d89c10f8d4e68d980ccf038ede1681119bca9bf9e77b5f83530052504b3628c493c9aa96cc85253e533e3d89f7f1eeaeb2edd18c48932e0009251e57e37cd797dbeb7571bd651a8426652d106947495a426df88bc8f4ab0cd3c6a3aa85472f02279e22aba311a1d650b52753e5dfe61b821aad7d011f4b7503635e5264fabec5ed809b83a8c973c214a7cf8e5c29155c6d4f7295cb79abb1643d248d8c8966f029799335126efa0cf97802df87977e37e5b306cdeb5d99163e0c966b30c1fad54462e9886d14a5b464ac326fdbb733f240bbbe232e6c7040d0f5ab0905ec0c799f875c6f35e095097aebe31b1159d7c496152be3ed5aa135da47e6ef85cfda73e35a4564d3c0b436a16c36e180bf6085239b1bb3aa5deba3bf5cd059a51962416383df8cf671dc7c3bf50c3e7de45915245998c815a8a4055d943e013c7bdefa3e196747a675de58e316ae260609ecf7b986b445c4dca03be65c4e28bc36418a2204552bf18bd3e6438fe5445b1153440fecddac1bf7b029917e8ff45ed62efacdb52fe5f92451bd0466f76a718dbdab80bced0f3a6c247ed7d66c06e6602568ae7d8247a555d75826756dc2e31c9e5166ec3bda4585613f73f3a97ef26063b33a14a713497c4b71ce3629b18e6171aaa93725cacbd0eccf09dafcd933c05669b212601afde3fe13f6223f2b7252759e580efdd7939f1d38686f9b970721ab79aca6bff6ff511a6820b4867fd7a21caad491d364d935a03d0b221c8eb07d29049496637c31d06596d6c2ec9333b047498e805dea5e7cf0467ce92cec35c74ea6563b36390e2faa085b4ae96144f7896052cee8797f34b273ced2bf1b96165701e29915d0f43ee130fec0d6533c4f0ec1c94495ca4a3f6ee983faa33c10d48b8c3a81d8495f76f326000a63d674a8247e8e0b5198212fc917ab6576223c88acbc90f6fad8d8bf57fa8da73cf32eb7caf51d8a5f3f88ce53d4e4afb520af627c9bdb0e54dd650e2d1f175ec1248604a010ffa9e69af40965daf7e4d77691543776c0184d3d954bf6fbc5febce0b56b8c14af2f139713927c6df7f9fc2d4e4b61f6cba53d467c18992b87047f822a5684ebe892bde01d8e8a68734c60533d83cc6f0599a534995e321599e37910f92b98e114449a70a59e892dddc06262c8cca8d103b4cd7665ccb5ccf44b18296a876a9f4ec7cc6acb4fccfb8a94548fff864046fd40426682f5e1dfd4a1549ca93adc50ea856761e3081ddbeb5e5cb1d14e40e9e45ee95c5ffc45964ca4d14bea6ad452d9f733b180abad9839cbbc48150f4ff788ecf543473f83ca99b21322251e089fdbfe9c71d7aa0402fbec7ab6f2050389f4c6480538c812d68a2a3b0b260bdf99067b9613526a7f5d1c015516c05d52fa02cdc520d9122b74d16cb6a689d34af6cc21f5fdf4695473716e8c2629cd3eb835c92842806b95c2f2d65a9cf50ac4e4e3d9a95bccf06ada76e2cd7fe3ca007d9c0edb225c56ad02766474d49ea52fc9c870c14cc01ce0a2c25af4d797392642a0d1c81329adba6b240711caa7389e56b7850545a1b884a68ed89f020f98c1335ce5cf1f49f9200640847f887d4f1330a26a264947a9475bd7d34c724e21cc61928bc204d0eb3a21e763e504f60fba9b22bc4634facf7e482b018ebb580febe5a9b1d4a0026c3fd8f414d37683a1b15387947d5e2a18dd3daf3c248d9abf301a45e3e2a9aa95f4b79eecf64f9b038e13bb8e820c5a5625009d26e4b4c26d216b9497133719d875bdb059a78275815af1f4b8c9c3ee987065d8ff93ff9d15eb9da3649d53de103fe3a7cd271b8a0f536897b7486c5c42174a6bfddf0ddf87f4faea6813b5a327d25e538f2c376f59ed7c3ef7242188d8ee56dfd462b84a2f174f11aaf1e1d7b8e130fd0330414ae4ab730a58a185a30a8f12b71df2b83ac740238b2b63104b7cc2035f13044a88d1bea5337c070304a258e55d2f78933092992784d02aeea594f4076b0f3ab42702853f33ce375e1b7d7aef58a2278bd80bd67bef01134e80486797af4561745d819c6d6eb9db90d854620ec99ec1c8dfd62846d9098a9f63f5efaf0c6071f9ad842c5b540a506eeddac048f1516b6b20cfc7b5dd90d8c8052a3d9abfcf04b708e5883d479527b5ba9699e2502b7a3399e6192fe209f183e141e358f7900af2ecd428c3081e3af8a2c72b25aabd80c75fca25b12d39c03bba5f6ceb0bb8d9d05332cd5ff1de07647d50017c4cdcc56403fbd02f958c15b9d4c3b9cabd431df5ac5e8a3e12d0fc09b736b2e4dbe6e0c00e9abc9a6f7670b87161e910ce5ec020605d4f7cddf7ae47ab86d45523637e11308cd7ebd7c8b9e26296ea933f0c715ead5991014db739e1b83277af5c51bc672da40f28c1b6bab96a0e53ed30cc0b4cc47d0c8d837d45483029eb4002f617726a9129ad091aba63349d051c0d35fb2eb7ae904f995ba042b62a33c0dcd1148f914b34e849d72542c00ce23eb5c5415b72b76a2b64a380b1a854a7fb4c8b54eccbb62629227b4de531209f3a8330f1f2101e2880bd561031673f57aa1868ab3d707a9b0e31048f82eb20aff1092cd1be1b4686f483477010d965daaf7f7d00e98c53999f117e9f35e239e01c1fe1e30c214dd73368cf2b0bca40622faa903b6a7dec58cbecd4cbad10875f68a8777924847076d690a268d8ebb848d01a03585f80b8ff476c92c1ee2550bf5a7fa204cbaef1c8d4a3703d0f83f79ea07bafdf5cae7c94ca2cf68e2a766655ebcd463e834643b19a7ab04da54f0742df83ec884dcc4c8c77023f60c0e8e095bdc029b5341ed23393bccfe4815eb35a2fecc23a7e4045fb96827d95967f60000a36cc8cabfd6dfefe2e39410449a14aa8a2706e46f7b71f11aa2248bce7c824114bcfffc87081b4298ae1e4765f8155c7787238546291b1fb1fde28ca14d055065edcfe2cd22d9a9fc55ad34ecc9e1cfdb1004f13d974d335859303600b7a07c57b886f5e4567e43a379b74c60c067ade47bdcae56fa4e4a0a1b6f9b63318e24d21ee056b431cf5a935a84d85b56da3b53f568383f9ecf1593cd0ba585035907b35f55d6f9129d2229376e5c3689af746d47986944fd908780d3417e636117e71a7691f3364d2f4db85a4780b150e86143a29f0495b96df45d9e3e5100e03b65764bc2cacb515b2a5cde179c3c12764e995ba27f416911f0802e9e248fb8df3e735179aefa39be5e989473df06e1475ed320acb93aa9484757fa4385f84e68a581b887f56b483bb3cd8485cbb57d9c6ec5b8352417dae10da2ad267a4b9a2eefd3d013c94a673d9416e1905ffcc8e86245717fb922019ffe360c8edce8cef845ee605aa1f4bfb811cca752b84a88e1113f943be90c28d393845f63d910ae4753f0c7836b1b2505cce13cc876c453c3cd9caecfd4c3128789a4090d88590a774e18c089af74ce9528fee6a477bd02ec5219f1edfb1cb4d60f06e0ed981be78c0002b384d279cc4c2f4e1827f01ac7ccefe9a6ef69766dab7a6da465791e2e95ff0e327a498c9e2f944cdfd8946db1d008e9061c13aa8dc557b04621314c1fa94b5046d24899e7bea6f4b92b3688eee725ed0fd220e4a05f3b0bc6d1b5617889c9ff983cdfb213a3dc84fc846d3da968f1fcb18596675282e6e3b8fe21cc9eef0b0f417502cd606dd3173f8cd453568b8f5038e63dd9992dae9f6d93e32b9c00194f83f5bc7657adca9dfc445a7ea7ba9dcbdd03a5b5eedbb956eb8a0c93e2d57e4100ee690289ca91f885413bb37c75739b02e491830def6c02a57b5f8d5e63119b162d27e27fa769c2f69d66d4c2bdf4e8a797a449d0357410154526dee5f1b5d6b36d6b23361be3550888bb8bded53c1e9c46125b5b3abd8b56c10fc66083e5b6b359755ec26bbcf860e83ac654ef865b21c273748449c71f877a6c51172924e4832091f101ccc26d0c8f1e8cc330b609fbce2f9b78aa7b67c12abcbeb367c6ebbcb3331cd6ef1e73395562bbe4f8f1c6a52fb901b6e524e2e7a6b70174b946e65e2fc9b6463f7299e5eaf09454233a7e50956aacc05cb0d250981d9e9498814646342fb6b6d57654016fe62071ba210e70c4e578e2aafa88f46d9d86b742b7ebf6df55c3d55606b88637c5c287ef491ccae04cc21b1a15e1a591b1c063161febc773d73a2a6fb38fe504f1fe97e607dbaa758c078234155361bbb4d59931587dee4f41678a83bf48767a3ad46855325f3f296c3c64fa2bd7cfb24b8388fcfed3836b4b1dcdfa2f86368890887a0f1f13e912f332aaa16a6b459089282c27affa1092e6d09b25e42266a7d55356d0f4993b9c43676ee2ed1af391ef9f603fd83a0e576b434c2f59a42865ad56e2516c0d1fee91b21027f002d68ba58cc0436530a3d3b8a69ffd49205baf257fa629451e49312625a2996919d48faa5d60e3a7fc3c220867d36e38468b48572addf7192debfae6dc9e826b95fee81d5d4f9ba353f076b880c0879d19dacb8b55412297542174402e1ea43732bf2d436e01ae5ef61ccd9664859c6e0f5eff7b16656104f9c4a1bcbb0059ef8f4ef7434f9bba2c1dc381445e279bb673df4740fb46d09d45ef7ade0fd255a9878c351ccc947bcd0d5745003e253fa74cb32607b089dc207010b2edf2a863f52e5fac1a2d0ee305c3c5c2e6a8b633f3d9bfadce852ae6de878b8c89bf9a97a6e5bc20f88825a2269ddb1915f1127d6cc0f96029f22d39f06beec035c16bdfbf18c5659759eb5a410dd06436f484b4b9f7d10567d1adf5950fe4c6368b2b6f8fd7cba7cca7583f7ade27a5e58b1e4085b1af3bd7e8c23eb9bfd499fd4c61fd58182f07b5f461c3d272f79adb6a7a48b53049a33938ce744acb9274598a4ab0d4e26532517ef0e519e889b18b51f0e85e3641e890b76360ce1dfe1a7f72276a6edaddbc7e3bea5e48a71c5664ff17b8c08c87440a77d8deddd97d1baea130008689420c9498974af6dbb3d15a450f57d84af672391a4f296b6b3545d9ac8109141fb36dfe46963d281f81ef3bd35e87ab8a57fdcc941ea969bc671f377c979f6163bb104b643ab9e53485d4bfbd5c24a150f66fa618d88a1f0d8fb62b559fa846024aa6ad563ee38714d9dd444eb9d41cdc39ffa3647d84c66b39eebfa990483ce54a2e2679270d7de3291808e6aa0d578e31b59c9510c327cfd47a460cfd4dd214be89c63dbf25ea7f77010b8402f1b78ab744985e65ceaa6e3450657f60b8609a948036768c8c5a30e1af77bcecd00ab5b0c61a273aeb3ff7c2fbd6f2d6646a5a42b4cb958eb4273a160a898929f18db9e5e392dc09a048393b70064fdb793d3c36061fade8aeb25e117318e2781981a56421cf68605981c1402a06e246962b33c81825acb3cc242eb9d1cf012c251e10976c8290e75d3d91548a53a3c6f4bdd20f67d8b33472fdf75a7a453ed75323ea790c0c4e1997593879c4030bc17e34a1dacb354be516bd3283c29c68716eee1a2a4da797d2609f08a9f5ced60d50d667faf4245862ee36e3aa18841bbcc0719863c7df94a09449e9d8d26c0905b3d62f8f823780345390d86a014148a1619890a0d49f4a7c18ca37794457abd3f17dfbd7e0536d4f781ccbb72dcd07f22933c0b4fa84d82216a2344f57b0a66730b313c917b3a547b87610ea5af9e7f97861b5ea625b97757740ddf5bc4dd1dba77e90d5bcab7cb116454ac547fb22ad7ad75d624a1d8ba52e046f3fe5466cabb79074ff0ebba054d168975d706433e89dc5f0c5bc2360ced6c1c99812ae0ea358e8bdc3fb35b1cd07b153b2896cd28e4e47d5e61d968242f17133167d7178c03625b62dbf366b62c6ef1ff82eca564cb8099b016677d7289384c284d7ebf245aeb9e4fe708bd15b0da2f76dd1cca9dfa259b55a94443f51ff9b84cf6123e932f6a969d76a31009774c8412d43c5fcbb032f83c4ffc1e6010af88dbb76601d1c585df2040c906280fa5aa63fef723a11fc11a12147b738c608db5deb787326c99f98fe7ed23ed50757c7dc789d626c73fb223ac9136020953bb8742d7ce61f10c7732d0628ceeeda2cebb4748f9f0b12094d82b5c0b1ccc853ba897218e2b11fe0dbd5371c5f8a5c93b598ba6fa83d31a2d4c1d8d573729db7d145cc967721689752f039acf5d2e4fecce4f21046e9757e5c094b8fb0bc80fd40e8b69779b3f9d2591069492db8d943ae59c08e0260c757929699981264937a25b8352d879306430ad1b15a3109cc64ea1328319c97e310dfeacfd0055b012a6a8bbc13ad1a2bbce4b14cd66cf7edd6b556de2aba43022650c6ad5b5e43e7c927b24004540c6700410b73eb4294b08620bae93f1dc2be6be99232103d3639eb06e5127394fa033c18ec0944b33fec761f5e0a2e98213344862364e8c258bd0d3f6b85aeaf665c4e2f226f7f743b94c143c86be9dc0d7d8749c8b6668a441faf058e027a9a80d018a399ecc1c8853a2d043b2b690c99f9e2ed7bca2545ba5067138f15f9788601f078156386d85155045c5228ce45376f4337e50de25ae7baf0c1eda93dee97e9eccc6bbfcaf996457e65d435e19992b56edb517ad4328dd6b5ab03c12fc96c3748b42c95243e6281cf9b8cd8589c9a6c96f46ca2287a8934bfc68ccd30dbdbf68b78adbafb10982ae5224673580a6682e4156b78fa9211d79bf84e7b72944fdeadd41d2818b7f8ab026348ba89af0f2515f56c0ae3d28d7d250c78a7f70f8408f24ed6c33a93fdb3130d50417c27cac3bba19d93ff37a7d4ecf488a6c8704c7edfb345b427301c1c6f49fcb1ef7f162058336bd72a78bb5807f7ba4178ce54050dff76376dbd9787ea282834935edfb3b7ca5d9735553cb731da5d6fe0f0d7a682beabff45338e677980eb5865797035b667f2d08cdc35bccff69802887b97509b2da0726c827b9d1ad833bbdac47efc9416afbcf726b1f644ba731260f389d4de019b8ee75a171ee98776da0de512172d60c52a3f81c312038ad26371d93663a1c221d3f0dcc92c29f877a03c958f116972c0d27377bb846f3d715984ca59c9a4bec0c85298390e12ff33f360075b1167f0e43ba4e2b93f9984409bacb5166f599e4a9fd847381b8e68be864b5947ead3c03b9a11fac609199f07ef6debab7ac44a919598dcc2277a02fdab97c05af17fb342f88c540de7f4794087dd43495fa8e934ed5753b97c011899839a34f2f1cff72eb97c9cfc32366041700c754faf03f96452e42819535f5ebbdd0fc73e3c2d053dfb28da42608af070d6f6547503a32a58730ef2857b37adb456ea936f63ee90626adbcb2527493c225f59ece80ac92be63a80fbd9f1f6a81f35dd211649612067da6efd5cbbe94f5becb9d911e183b03d30b99854ff9c7c9a81064ec4959f899bb84abe7c2a706960da64ad8cc45f219cf461ba2b3809d556aad23f6c3576792bcfdf3fcaaa8ff2e18f3ecd54467ab583b9c1aecaeed9059d01ff281d81043697aef23d0097c3ede80b8098de4f96b81208ad57e501decd5c5868fc3490da2b0f76e2ae3a81d06336e8ecfdbadb7db0130b1677a3ac61e593f04eb1dce65b216af379e3fbddbba018e82bd268874eaa47af7854e1493d1988cce904a38293f694933206d15bfef26875a4fefff71a81535760b239813dd992fb7573048876f4ab323155f476272d75a1188481f0ee5060d9ce033ac31cdae1f244146f266ee4c4f004c542b0c06a7dbc67280176270ab311cda6eb72df85a2c8b47a6d58b26d59516b6abc6d7128364a51335baee563c69005f8b72ae70b3a327a275c9e2fe802ac61be32d043757a39533ad16db0cf217b60e5fa941add3adf061f66f7b5c8712a09ee5878014ed6862659ca909281961fa9e9083d3fa87e2267741cdbf5e9c2cee9c338861f1c89fcc6a52882b1f15cdc9d151f1efa56d5072a279e00b0dbb4b260855256bb6273e664275b58c4651ae47920bd446f6bd9f37ecd4ddf5d33057d2f03c8ac63a6334a82e73d02e1807ebad00eecf1ba11db709328cca8bdd2e5a14eeba11bb627f0cad8d365ee1661ad120589c63f5b265a239734aa2aaf231cf9e7c430c61879aa219a732572d411e3ff54501e3e026ec14a182b72830a301d2a8883d64881e9353541c931d011159eb3d25256221f8e34b587c87cc533e32033df11b0310dd110ee10679d40baac637a95f4142b6d29e191ced599477cdf9b1904c03e27dfaf7491d51938b8041e87d3d902984f6a61ee5a0765009addc9a758d15c13ec2d7ce8a5d71ff7941e4219e70868fda4bd655ee8a259c5f0724c41e6596cfc9ec375268840c511de5fed1dd97761f51decd2ffc8f811f191e7a551d8cbae8796dfaa008ceae3bf7b520aabb6ad22f856f95d88753cfff05856dd250438cbedb45e972cee64f25a8c6f775c947aaf104cc0cf07c1c4ccbec6e41ca1be374d77534d68e8498a9b23b364823232049d134238bd1fa644b4392484d9b0566dcc2c157a1b13c26b3591da58e55759cd9b9b505ca36fe036f2d39db630042cb4cbf661ddc20e289c2b5c6948e3e457921b2497f28e79150d273dcf316b02015294b9151e0ff4310f0b670dd85a41e38f38fb23b073045129ea8cbbb99231c4f58ac5c53561d6242e5eede33cb56fac10095e06e5f975364dffda9a30c343659ffafb059ee7423f186c46ac25c231cedfdcafec70da9abdef094009669d78e86e421bdea6c646a62ae033959e20cffbe27d5a6ac9e33061c81e78e4fbcaa71b1a43b1ac4010b0fb91c9c6c3d34be64d1e818baea9765bbb4bebda16b02cc70a01d3b2bc03119dab326b765aad79a8c22d8bd0e597bdd333772fcf8c2553edbabe9b2fae4d002a0ae77cb4775e6909c25f78337cd9365564558ff6bb29966373ef4851b0696c3ab4a635f384265b1c8fa1db4fc6b0e1aa91c0f6fa72d2f44720cdf2cfc4b019dac2d6266a4e3e4db2840fa1c2b6849c22b7079d99e521122e43501a314fcc8c853198901f943d1d082ac0b58a3c6e774dce1f5888b098a6eeac58186e5c1e1d8e4df065f238127616f410e06d3a6eaf39cd9c0bbcc79734267f29991302b534ee578bd38ea6f60c2d7dc026fcd922d56d617891b6a4d8dc51e8484d4713dd53a380d95bc16abea5ca4aff43428f2a4a80490767d71750470b5fdd248f715ed7de607bfb2503aebadedb608a0440c582c002f4d14d94f8832bf1680740236a9f0ef2b7fb146e8646ab3f5e832f45a2fba5b867cce4f9f05d6608284f48119b2fa92ef1605c46d93f6ced05653bfbd9ae266074bfb7959c07a2f99e03c997482c5bae7716f3545bde8aecb6771965753c2f49ce5c6648271029975516ad97634ac6acb9ba2de41a34b983150e062ea67921785122f1f598e1f2770b6d423da561c361e07a4b15f9f9ed88f8e5a477a3cd530f51f1944fe7f075f0fc8aae1a7788936fdd988648ba5b4e74f2dd30248af39c7d69068d7e8c3b760b5514deaf668675a548d62393e53157b3a163dd97212f8012b6d7d98ad2a8772d6dbcf075a46f545b824349d9eac8d4efa7d9fa7a5ddf4d8ae17f4b9849b2383b1dc716cb42d5081ca62dd2dae8696824ba914216b2c2f8d3b28b8cf416e123b53985385be9037d790246448810f25111f898721c90d79858a568787b048a84437299c685a84128004b1642b6b490ef0059ff441817a82084fb7971623c865e8f5a044a46cfddd437c2b29be25d965b725fd1e256bf7e9f24b773c1b593a460dd6734d7e37855fa8112172318d624a76ecf22bf41083e5e32da4da5cb3924938d7bc48b3dfc3c7259844a0174eeb46a3afa39ec6ab64e7a43f2ab0d2365c24e469caf2bff7493be676504c87772238cba4738862a17bfb44c45e7856bf0417f9571e63982c86463fefd2b4f70644a41818a6a59687305cbd4981e5d77c92d647a142386c6a833efd205f5b058870d490774eb1623415e3008168772fb124be2f38fc39a4e279513e604ce36560501aca08a6cc665791b0d1da5e35d8bac82bab0c72014a5fcba8328824558c4263acbd6c70dfdf51b826cb205d2a591db2d6bfc32fee5b67fbadf6efff21445496d65df13f8902b2d0e501e1b31be60ca43efbf8db7ba1b6faaf12a8c9b2e20ff92f39fc8f5c6e19b1edc8e84862bfd76cc7f6e1f132d1ffb7f491b824fd8b0dadc95bf4a654ad4bdce8ce9f386b27cf0034e7732df2c188452a3905e10fc6714f3a341169743938475ae84fdbbf71b5d70d5d586b83301d3d1f8445816e9d1a358b8bed667564f4d4d55e15d5bdb71d132bc8a3903dba08d8bbdd6ab052d0586c9d68e0c774a1e4334bf634ae6c59dbc040cf1482f333bc9c6bafe5e91abc0eab4bd851d1d4ab3f16515f9efc4a04b477adfd25d8ef7b816cd6944560920a10ce526389e8c413f71aa27b9bed1b02f24ac4b0b1a58b2b731df1650802672b0d2d8be308dc54e137de0b55491f30630e8229e9194924b73b7051126b3b261a9485fa304bda5b02b42558f838f4f546ddb582f5ca2b45fafb90c55d3e546b45586a878ac613825fa27dd396bc94363f887b5184684665ee5ee0ac8c580e6629270f993ab32f32b3641952af9d099d7722db1c325667de6d6483c74db5540c4dd27d533a8b5701e7c3089d44e2691a23f9bfff98d4ce1429ff0d88f020d740b8e851a985f9775cd2ffee49b8265b7b40932916a28a2583eeac7c1d3cf663a7fd68e0e424c694e30db4d078568c51c72aef98f2912eb8dcf1fda01f2a34dacce4b538224a12aec0fb51e762aebe34491353cba66c013a1aa246e9d7a8f8ca00a79a2c5d7bb212f7b6e22c12ae906cba2243b5be686c9f75bf07b7f2e359e1394fd7c48ab9ba1777acb9636a9070c9b716e8dad98b4f796a9e3e42e22519844ead3db75fdb953bbcb3766d9a69abb5b47c842796c6060a2bb3fb04163a686a71369c38d484ee607d83d137ecdfb469e6d31fe525c868d663e2c581fc9f94900b182db6f2604e430a1d5d1532c9348ffbefd650770daeaf29c349503dcae0bf39ab97c2bc0549518c6224323326d6d98fb5c8c8b2e449782f155ce1ea198ff9e7f642c6c8e83fb969471353d963ea02b5b2b78918b02f7e08a61a41ca2eb8891cbe381198a1f62dec9cefbf0801d54c3902dda6844522021791ee9029c352b26c04c3d36c7cd815929be6915e126244bc205023a731997fb4bb0c069f9c35289a86938530992a997a0e801794026142a345ba60f6c40245bf34bebf84617213321f920f707936b2050ffebd5f420a5a3dde1bbb2ce51c8519464285c2f75f20441f0bb3b1e3d6eb6b876ba07f909e2e18c5d5e78be47c279ec1d214643feef9cbacee2b033a685be4218d0727f0d82d0c14ffd80529ed85d84fd8606258e525341ff06d5b85d8ca7c8ada086072c461d16ba08f5218ec1e04c2d8b39579aeb6a4a627599ba19a5f885b6f441ce62cbf1a90db98b09d60c1ae88fc7c3632611244f28a0db02a314f5dbaea13ea1d4a610f4b80548175fef2bfcb53470ba443734e60a9256865980e7e21b246e4ce56dce75157ff0f67a9bb79d9857299f60c49bb5e51775cb9fbe617feb878216c83b2cf5948fc4875902ecd8d3d304caf472113df4c77b4fff809bb72ec1ba1235854fde3ebd9f5fa7ee4e9bb3f64d62cc7760bfd6b25e64202b0ac6473dd0d202c915573675fe9c5ddbe61dbd6606231079f0a28223423a42e49a2f9f99ac18bf556d429ae637ddf1c58387ac7030e918460956a2d8b963d9cd57e5325530f604880c174e3c78b9352d43c90c81ebdba6c12b027e619a4e76cad8bb08e697a4ca3347587285663d6c87eb262bab92e20001fa567484240e562279daf8db80ae733bdfcd8d88d817c90f6ec38a215a8ef809caa580660933e971e9284eeea5a9e61ee3125ba4947bbfaa45441954c14c9fd8ff418bb56a937784d5ed73232593023e29dcd24cffe03fba5a6abd85276f6d6ddfbf5883a55cb7b9b3714687ed5c55c3531b37c74857afc77303bf97ea5efdf4b64feb9b43dce39833d80e78846102aa58e841e6dd50590f7b3e5da5f1858f50a5bf43cbfdd76e45456b3872144b3f7c5339188bc73554e148537f9ee89ed88cd770d9ab171e341d8b2134015ba19666c1ef2054eb3462c73e5df83cbe96add0e8a5465a51d635788cf4921399f0a08387f6badd583caf6e3c365b818095c8e70b6d89413b5acc5b3c7d44f351d15d3fddd3a8057002b8684667e0afe8a2d406657dcde5e82c3b0992808fc5549e1c77c78ec6e33de2f8063eedcadecca29389a5b19cdaf434afd976ac3a5c73a251cce6ce738156904a4c45fc7123fbe5855048594b456dccefbcb65540b2c0af1a99d7f4f1cb1f3d05460bb75d0d20a4a1e4e2b37a446ce7c72627efd4970d2c6ed9891b0ca7326c34d21a509bc105de0f6aecb98464c5f79599c18a6215961f152ab5b41f0fa5258de37c4174c031dbca93132048f99357365d314d679a08a5a48f7ec9f2559ea73ea16888b5733054a3bfd0c568eaba8ffc462a34ecfcdf21782955b683cb7440a928099ce32fec662ea25e4d7f0028baa65654b614e7ca239d112a79a6b04a800edb2116c6dd495ea35ea7315d18dd96ebdbf6cd172d73ab489d5f42efe714000064d21614b8289e38cabbbb2186db304d47e5b5f7b2e1c1e0d41e3999a158891e9f4037b658218fae5c6471cacf88a52b395052550673d5fa4a2723741da559eed6a0936ee6aefe7360bb969da1a41a0d86ead3c3d70eb54d1f8b6a6e70803f4ccb9b701ab860c8b7f64112aa7a6b3ec061a810ad19d99aee07f12b70c1004373808d60c47b5ad040ab489233d99f98e23c7ccc02c2abe6010274548a715dee0af6dfce5d0ec3c846e78c2ab07d2e7c78ca71b20a7b2fec1e91469d44f2cfb6ba98227d21ec79390eb14c4529810aa151fa48b48bd41bc4a67b0f54fd760ce599e8fd9c4db536587cd4ab0d56dea3b644082e1e8f40034e7c8ab380437df9b28fe68addd7c402a806e010bf4fb00c733bf4578fcb26bbc8b7270113346578f7896dbb4185c06b0965419c852ac954f9d191769ebb85fba823622f5bfda727f93a3fc0a5009090b585e7255ce27d56b756a9bd1a1f06bb6d460167a5e0792e7fe2198b3cd34c396c4797c8b3b14833e07b2aaad9e80917dfbb903f299f4353e58e95a1a7b95aa3792f68ab5039cf746c37734fc35caac680bcd693891b98a116b1145073e099deb6220933c00deed49b3d71cf0d218a296478b26daf091423b7cf765b4f9b03e58cc6f9b3bcd46d740b49248548ea35ab7450379d2cabb79efbf242597d4b20cd22b9c27b1e07b798cbb11a3105581d8d45e56a7023dd0aa0c637e791c583c72b28e83e1f30c0a9ed45126cf96efc1b199534f7cd0aecc1a4ec4d6f289f80561da5125649d23731c5f5e3da256074489339a5ee2a615c65a6528e893ac50d3bbdc41039646d0b219f0d629bc660bf3258946c7c956f743e257ef9f38d730df3f8045238840a08cad664657971d7e093708b319e5c56a1b74202fdd5347cdad91b0fa8b95dae486c5f69b33214ecce2f2a9e010cb5adb48faf4a1aa51558c604e45314fdcd76a5e96d9aed8c05735f6b2132c5be2ffa9ce3afa6f9c7db4864f9b039215203a311001656391282b00a9efba7cbba6afaa0d780bbd80fd08058fecd63c85224193bebf288852da1dcf9c556a5b70a5746e2c02bb03e23f57168890a90fa33477403e60c17fa1f247a1a1d00d590697d9b2bc3f56ddc33debcb7cc4f0caa0350035489039f867a9defdbd4ce560524f4ee4faaed56f893bc60439f706b1ad384cd1357a7e3097b8b168d215409ba6e05571681ce7d0bead61857d52420279967aba0224eb6d9d3bbb46526eae4731b3cc634e2a60980fea1cd9e080d213acc8ca97cbd4db5f2030fa15bd334850b40592f7a1369b4ac970c2c827f8263e2bf9cc618b11009d5754e3c1090a1ea7dcc193402513b1204037c3e87a892a69ccf65b463f6930b4e1e4c59953137672a5d288d8b39d2bb31288f7c00350b8225d1c4378ae80911da6306321a425a1c5bc87680ff9e7e6020b1ea34551b0fecd2da96cd65447b97ab80e84e1c0519e11f383cf444bf3d87671e4eb4f0f7f25aba13555c23e44b4d816e778ef42c249b26f745d18b7d9ad16408cf1c850eae9c00d16dbc216df787ad2217af96785ad6a3bb9f81709bd119067eb09d728648d64960c9077f6857a55a9ba53293b9dc752917ad6f7b09814db0b8a76c4f5c2f16e760d3744bf748f7570dcb443c2d4cd848e4788a1066cde16d3e207a39c4d84b494db6460b536a51071b74ca41bca5029a01f74944960f2a983dcdf40fe7793f290450f6762cb663460a3ce06e1eeb69ab070da74856b8c09d0a6bd9888f3cc04d634b4ae93b700ad46f3203633036ef7e835de39b321946881b27f03d2f40dae61aacfb2a92e41fde87761ae43ac43b2f0a61c09dd8346b6d0fe4ffb3c17548481ab552c09274456d32e3c06975face538f7ffb50978d0753a52eb19fd09c2ab1a824ec1ffce290ff19fe6f570c799f3e505ed2cb764bf8178a067d5483d1afd00cb4b8b9b4a9592d37836d827d78251661bae87ac381d26427c0adbaa718cf1d6a46f337dc46991b17bee017a32465dc38a8e86e42985db7e9a47a0a1178f32571dcf4b484ca437eb0ac435d3376f8fc34d77beca34df036371945608be068b994306e8a565e9d5e85f735ce0615412759f00adc2bc477fc1794e04c9096f18eb404553c44af223fadc98fe8d7f66f21a56863197f448f64bb6047c78685ffb323dee0c7230715826a7fc1b20ad8f8a0e7cfb9acb31e9735dad9defd4d4acbf50fbc940fa8a507083e9356bd3384040c73dd8ff2bf8014f20dd09b74cdbd1d72cbe9dadb02d863ab7eda30ff1faab22b608e30b40776f8cefb612d7320531b8bbff9bca863c85aeed2fb67b54b98dc934f9016d6b18fa52bd689caf213a3099d01bcff1dd382d77058126ad6f184cab7a0f67e75bf7cd7968a98fb575ff3d8fccdb92265c657c9e9ed287f6ed060740de767581c3924385bb10a8cb4490c349d5fc9a2488260c613e786e39445fdd516ccb4189531a44b31435bee8e7f88ab76eb613fa5fc0650573eb620c0ae02f22a025145bc500c664e50c109bcaebfaf2cfa64e98ac17ceeb389aa0e3f4760830c948fe55e7bf0e0d2a51f764b7c59e3e9f9bb2a3ac055624ae1bacba0521d2187cd87d518f0731889602fb2d7396f6180cd0e467b22302c8e29d64359ee93ba6c442274f731dfbe8d5bbfe63ab7cb4c0d24b9f0eaea6ebb8a86c2ae10795ac611ec284d0c437b1ca7d3cb8439e68abb6e13b5a608ee4dec18da58b4bad4073ed86c261dd3e1caaee50cdb224762e42f5efc305fceb10b14e524d932f7fe32b2b8ba70a92f97a009571f1512d4db92b5055e2507151453da1a3ec57ab962de736b0f6ad1af738a9b404d5e8b3b1d6a852ad88fd42aebdf590eb8343a16216bf387839b5bc2766fb9072883e2a6e43435f8a2423b89bc2c4e6c7c541ea227ca32073894c88fc2a10667c5a4d4aa2b5e482252e3de8ef9734ee0aafe45fbdb9827a84e5bc867b71dbcb6a8d458b6df6424341012e1d9068410dd2c1c383138b2e707ac03c567d9e44b0f4ccc4384b9c0fb08d9d04a3f9d1220857bff2ea1ffc7fcdef7e8bcc0dcff77c23a35298883751e0e81a3e85e2189bc3052559670facfdaf2f7814452b78048b6749f94dd75cc85da6dfd4426b6f81bec6878c5d0c6ee65acc25a15c7d97a3d78b9fcedab35d28d6e1af554517e5da2d2ffbdbaf45bc1e2493cf7d3dad317e50e783decf3c4005a8744ed610ab3cd85b2376a04afe216c10a2d8a6776487e796fe7a4b3d81320b1f7182186e8ebd1feab6349f9b5c25a97dcbec7ca5e26be1c7fe80b696483d08c502c132767266a29383b1d4cfcf34d1e32f106eb2dcd9cd089bd16477aba7b7f022bfc767a52e7d736859a39d76ebc603bc71cbff97c8aa20e033e20b7255dfb3b70c6578d26ebfc3918a7e0359a9f19540a704739dd11463916ceacb3a384c3c0ebb42bc626019b79ba74405e152bf31199e3f70c4022220a53af36bb6eee0366277c2dcea518e4fa21b22e7eaaf7a78880ce2ab629ba72973c7856e023835592f9e8ab86aefa807cce00714d6388b0885cb705ac8620be085db16e0cb40baacbf7ebad2a176c57b6ae61cfd95b5c5bc02f92d552038d0e8ed6b7d091135e5987876203889fecad9fb70a59bd97f38a257c4c72b24152f22c5a5e09a54943f0d71e4a3cd1369a2d14811da8a4bd25cabc8b2bf9ce5deb64093e0928290d940c0f5432e42c63b089f6e0159e8616175775e915d52c765022a8ec2ffab090cbf33c5fa9eeba3faf06debd57ead368b2a3df15b33d9c327aaf3c095c5459ac652617584e7e07c66eda9f76d51de82e61bac08b5b25d426209c3bb183ff6d08305c758c35d57f6423c1691ea5e479e3e5f28a82b12c53c63e4378f0d6293f39904cb1decfd547f11f33a1160806ff30eda8ff688279b979296e70a3f804bdc077d2527ec7b30ae72eb404fe5be762d097d5ae8ab32b692fa33ad7cd89e45283680dbc976f8dba33f9ce640ffbe4ae3d0a24fce24989b29dcc5eeb86e9d94e474bb9ccd52a64bc24a63055c29402026af65453d8503765ef2e60240c0db3fb931396960bdf1c4947cc3a5e0d3b17724bb1b994e1dce790b49d850223cf84dca4f74cdd55324cfa323a80542dd4771f3a4d8920c0a279342ad1023658dde1ea80d3438eb957a776a8f67b11d836c2566ba95442e032a08483b3caf31222cbd5182e71e8ed22223e3bcf2ca50abc7ed7f067ced256233b53ce4da6a879e836026d821d55549e871299de9441834887f6035cec47d339d66b7a2fa70020a4cf23f9dd9ba6929f9539f16034f06c782926425c7c7e86fc530514ee85825c390b928d287c9fef6480f747d37064d19648a089b49e6b9f0f6b97b47e57a2828281a591499fcd0383768cb4fd156d00e7cf30b4db066190c850240396f0dbc54b709b1a1be7b75179dc9d1273c464488b6a7101c70e0e33dbea7ac7160fba1e88c07aab2c92a1ab9b8e94e8971adee4da1604c5c1ddcb8711faebf9627b4373bcaec4be55d1c081867c8728ac7500ef4209635927591b53304627ee785318c8c6c145d444a6068fd8e2564ebb279c7afe157445a4e1e89104bf18562d1331de3e741d07f9929801af5c574e5e33bd0e6f47ca9fdbbeb24558313ec99cfe139ec2c967fb6157ae2a7ff213e34a1d45e70010a065ccdf5737d0aeabac58de86268b0530de3f481520718e4a94074bd644cf2ca41850ee857fc93978b4416df8081148a2ad8ba395fda0cdfd07fa64b5a9ca628f41fafd74360bc29cd14796964002053308388df9741f0df83ab7089cedacfb6c0095c2c805db9c840f694b7aed6d7bbe4238e80f905edfcf597eea589c02ec4fd83d93c6faa3437a9d2fd9f97e8329b3d538cb5b5ba29f6ab0e3cb41f8fbc168fd0919119f5011ed333d615cdc9e52d7e0a376d30f70e84b75ddad3e60b145232ac30bbce171ea676474b875ea7a47477452ec8931eb06fe41bd4fc2d76cf1bfc40f9d2e02d05d32719bc8cda2792912efd5edf3b5299ba6e5039092d90a972403e25c783d4a4a7e50294cb4d371e11b91ec9a4ee1210863525a1781714dc8897433659c122aa7f2cead6b0f41f24936c79cddc7fa4f17f29b4d00eb3fd89c7bb9933a1653baec70d3425cd0898c0597e9316d772a7ad2664de0d937e1628e5ba1487dc39479d37aac01303efd496df386f3384387f3a168216d6c2679ea91e7a09eb0746c613d886c9fd0c9ba9b402a5ed9f889129a827876b29510a3f61852b0c414c30525a1365358f51b4039a04dc6ee73fa3ef84bb1e0d29e57309b42e8916799656fbb8facd7d4b533bb934c7c08e8a8d51e4ed6d2824e480648a902a2491281b8115427c61645246d864a1a2237d7a2ebf2f64bfba4dfe4c21e8d4e5e6e8ba765af8455baeaf0188837374a455ee4947917e0123fdb7f0e01d9e8ffa9c38a8cfb8176d4df029c832137b7d88c3a9c07128d5884100e538c9085f16446fa028c4e1cc0815031ff85b0c1bbd94727623d81e595ae3a1752cc3cf9e75cda5662f2b605b528fa92f69e5a429277a00144a83fd797cb67f259405e69e639549e08c6d0eda4dcdad8666dfbcdaa3e71d415fac854b3e95fa52b419f8f891fdc415f42b848dea17cf3b1fb17c730973a8302fbb5cad653a4c5e0ee72e6c2eca10db59a200e8731bf154fb498a843ef2cf455194ea99cca2edd83b91c045cbc1c196c83a86e4be212b379373ccf9e81e30e527e8bcf40814b3bbc2914f8fc6ce1a60fb3035234b5ab1c55d2c42ddf706a26d2d74a61e050c55187debcddac6ee1b61c24f419f025e380b510b84fbda283e780b82a3fac220284aaf036d10e4daf891a8d230625de0bbd4f8b7c278d07f1403b236ef854f98c716c9359681bff319fb3b269ae8d650a59541ed03926b275ed5b57eb338e07a638d9ecc100a085fc28c82e1ed94ec37f4a55f60db1a5b62eb9ebcdbacaeeb94e8858b6f59032aebe48b719c63bd207a36e276d6e245a9c0d15556f062a0604c9d8ac0624257daf4a00f09503fd5e5a31adf6e55778fd5fca0aea52a6ed0dc4d119431d98e8678b4993efb8eaab0c78448baed5168489890cb194b3acb920b5b66777160b01a503fb4e0951e0740e6dd1bca4a106ba4704d6fb0bcb7a9be2a14b3ea53e66a79bbbc9af38a84929665e6e3ba0827f01048acbbef746f450c5ed6166b17790d74b0873ea6beb76bf3af6629d0e6d37aeda4cd3a6edebad04ef4fda7065f74011ec023b3de6c7ec4540fa035c2369613573db1fd65be628ba6211fb84989431b20901c4a5319d4378426b4b0032f7b767d2668b3eb05016e6abc2a7a1977e2aed46d65abfc513177c6a8044e75731b36781b3386eda163ebb1fbbb07305555acef35bbdc5df5ac2640aac31c6bc95adc6e4112a0534f224aa2ef8ed7bed194707d8cf62595ffb045da02953b427b799873b25ad05423dc51aee345b664c499f60e6c9e502bdf1ecc34ff1d56e7720c9cab31ec26ce7a149e97a5e2a9158bf6818e58ea1af35e0a1871f85b1720c52eae3059b14910cf01992cd6cfda62a64c28071213ca8e48da0822f85748559deb2f8f955895f9c4c8f5e1a8a4054237b502671f2f49fee4d5b1ccd80fc53576189d245ffeab181dc788db192ed6afbfb364ca4e4f0e373bb0e60c5c2828b55a04da17870ba7dadef22063bbda9d771e31553279d96da262e1327ec3fd2b590b53000e33ec64418af1813680ef88008e530d3de838ec3baf586e54c671237effaf7376b743b4e7c06b45acc506f1d1dea6a9c6772cf46555f8e1613fa183b97c5ed671d3375978fda2003bb4a5d22a9e347f98544cb6a016f377de1b1db7c9bbb45437148ef63baa22ad5264609fc71f7177419b89c2b6162dc54a79e6b372acee4b58ae0dcf3d0f3b08f896f1dec654207a6aaf3f9cde5d79ab867d13a03ef4510a14d9fd6be8463b486e6655315a53ebba2c314f1df3364c1976357981a0890de656ce75d7f0d2fd4da55de5687da5c6b69501dbe9a6d66c9c9a82f341decf0d472e66481d22fd7dc20d403be8774494f646c96b5eecea69e632ab61675109adc66d5f8ffa143b2b2ef9e8046ced46c3baf35ebbcc28725133d065d50574fa6e0030f547e0443192ccbaca4b3159ce87153efddc4107e4592acbfb5cdf6cda0a845c4d219d4504e5ef20925ae9b1a356b01fd30002548aa24e9bb36607ce4dbc4f17279fcc44b8b151d61bfa8f8f7694dd1139709a6852294f420e6c24f6a1d5b184a2087552daedc90228eb481aedee4d881b8ff80e069093c955963d20bfba2afa65c5e5782b95b8a47993bb682aa2d3bf98d036265ea60da66640578cb5348dce11de177cb37c2d5306c2bc303b6216b375eed7533e71d6331cb13af25c847c87842a110e2fee15ba3c2dc2a28b1acdac7b2686cc83f43412bb955ff035f918824e768a559587c9f2c841b534ec2c9bdbd9005a37dc3d474a6b3a3f90fb0ff3e794c55fc69d9d4fcce2bdab29063ea1e87c6816a9bc692f910fd28e660224c7b1173d096a120a36adce3405ae863bc614268cf3c2161703ff93cbf699ef551ed407f0d2d0b53b5b8b8f466fc1e601ef6c943ed792200b0da41e2db87ac710cd0ede4b794ffb1d4fbbd98e226f49dea35ccba695dfd21b15d6970df04c385ebac9df6beedf9f0fbb650998cebc5afba19afc631f1d552423f0b567c3d1dab4af8906a4b3532ee3445f82f3d06f0ac8542eb6dd7f8f0afa5620ce265c7e513f39a733c5c30a910d1732a61eb8ff9a73caacc1e478706c0644e577a93b0f84464526bd8ab34e976cf6cfbdf49f9a4224d215cb6f8ee5a46f0bee8e430a3721ba690a7d0c55ea69a05b1cc88fd33999a66e1915ffe5b0bdeb4bf2125943bee502258ab47d787350422d833cd9ba95d61ff7da8296f8d6635c6ab859cd6e252e28d725d7f9cad43c3903855ecc8b6f626045a75328d4917a8ad789390f3ffd86f4e774d9f174b0f5105918216cffed1a952344ac5a17d0daef420e0aa7c26ae4abc8812c78c6c10088ecd53b87321d19889dd9419ff807c98e6a608ff9d685196ab5f3e8574f259ccfcb5d16b68c3d830e98f54dfa05292657d95f004672d60bd9f71a90dfdae413f99cd821a7357197b0a2eebe013e9d9c95f25496e67b25caf61049a4f843284b43258598fcb1a341765ecb17e1289a7c9dd7e5bed8037f33e2839b40219b5e0db4835a53db790ee374d13d04dd7db8168bbd1001333d67b4c986fde166407bc5ffed447ee7d39dcfefe93aef9370e3d1261b91aabf0477ea830f4c0857ab418fbc5d6ff3a6a74e52583784e767692f278b173dd8f19214733d83164da3e762c2844d3852f15b4040228c793972ed3ac4b4e4fb1265d00831ea15d9e6af2daf8604c3720ace6c13cf0c270b089aec483442f4e2fdc278d29bce673f96ca908cab4537c8627a1b260097323ef64149d50401afb3abc9cdc05585d0d3b57a8c0a7db83dbe524b9ba36ab592e2f1f517f84707ffe76b642473b1cca831214f1c15b76657a0557265ca7c06c378901c88330f52052e16ab260760b12feae352df63bb083db8f9d00e3801c9054a8e623f38fa087d9a714ff3792a6aef3cd288fa38c5a484df3695b805077c72cb41b64614b3fa4571ae028fcf931b399b9bca05602753a7e2f59cc3e0a4123128af7735827dc2329b2c1b94b753db0a3a1bfa14522f07778b25bef3937f19a660025c713cc73f061e188a044e51d096a44080c21b1bdd8e17b085aa188cb8f70639b2cd9b665ae7168cf600b95a3322d33b0f6c1d892b7435b060eef7b46ed1c9712d7359d63e0d3ea6aacda600d2be022749c2e288425042c4663b21289fef44b74bf331dcbaa079832f8dfa96ce430cc83cdf1355d70c312754ba5aa95e3c65026a724f02d108ce8f61d4567d2d0b9f94dc1149b3343b1822147d50fea81b314bb1c3c50076ed4527a7560c4c665c3244a935902c3cc718a618526cc806c02cd89b4d378c771da4c92cd88cb2f515b1cc3557d6520d675273864479621abd1a3aab4230696de92da2712c50489f68d14b3646c40deb51c6ef8333da043e78007b6639d7d3b2f88e8bf3af1e6fc77b9050187c742cb9b8ff4c4d0032c5cb57f757d9f454a60bf6f99f50c4d9e3b4eb53193c2bd6a7f6ed67690718a94c92b135c7902791340920129eda1e55a1b56e058c03e94035c9051129e544ecd20ed0f0412300652bb26c64e443669cdc098cd5cd013d9f014c44e7355bbdff2649d2da988d52df34078841b885a2663238b8c9a2ad2e3392129faf02ce73514d195474011ce8c68b2ccf0e895d1ea76e1e3d3803cd07bb4bb2b0418a68caf73f4fb902ac317b7468883f7f1f8b8e7b2cdf50fcdf789c36136b751abb4ca9155a0494351cddfc7320df7e09e58ff894618c73d1c8e8fb0153f435c9fe3b8bd0718a8928d19dabd335c3c135965e798b1bf9df3337b54d935c1e83fd67ec0cd73bc39469fea6cf86ad6b2cde2395ba82bd80c78bf844f7c2d2d7ec00f472382b9db8686481e3bd85c5f4db635433e3ec1067324f365947c73236969586230d29505d10e6423adb1c996ec26dc13cd39e0b4db3a7e7ef631a049e3c1455b3c323d7e3feb3425cb277e1730599414cef82cfd76dd0f23351a56625c380be1ff95a4fb524644d724520f0f7eb9790cac694a9738e057e27ec71b9dcfd3dc09859af847b7ec0c130c32bd55a12bae60b5d284c913b880efd43279bbf9a684042a878ae0f5e3387c5cc13de6db7bec994d0ce761bb21e589af1e454eeab5bb1901a83f12d4347a7711c7f73499cca99b58ad5a0f728f2e9edb15e99c0d52554d1a807307af0330b178512b606a21624aaa45e1cd91d5da4b975af0b03c96d5946112534343853b197c7ba8892ca278f451eb95b0cab11d6898244cec28f174338dfce367f1c27e1893200c6518bb3da47e4f1d9268e04b6ac45fb88b3f5a4186928b98b09cb13219fa5ffbf73cebccc06b7eb3acd71955eab280d638d16ac41385a17b29f7752333c597d56eccda8fb37379b291fc32ff3055c2da2258250a6641fdc0bce822d40a505fe6c1e63749a5aea872ccfb826e06a06b1dd1fac03dfdd85ba010a911747bb2bd597a08b5d8bce6c8af6d8abd31e8a07d47dc8ab8593a09003925ab1b47e6f41bee6ea26dd5c552f691d53691f038e43f2adc7a0144f8bb16321fe130e5035083b4b1f6dbc11d278b08843fed6473e8235524ab63fba131860c8993e195daebb627944f6a0578136eded9ed9fc901fa7e08f4d64df545c474d1b3a04994aa0bd0af61c22d668d97e3d01ac22d85b564968dbd9170caf6ecd1162d2cf010041c2a17875d1853d97cd61264baa6c56049c1fd8869c8b477687aec54a0d525081c7a3bdaea192ad20efec26ab6f3b12c8728a50c30ffc9c80728fd781b2cefdaf66333a64f8300823332c6981f44d3a5d9126cc82b51fbf4bce306e9b8b39a57ad99a77f29c16f7a1828b7327b13245ef7f71d0c4ce8e7605e2a97cd8989a9ae5ee32d38e831eeb6ac8171b302c873a3b2380bf2147f148693b9437d41ecaa3a33a82cb9a60736e88153e0614f5a2c6660aacab5e1b847b62835f9c768c3bf18b3d579e5af5c07fdc66342dca52fa0147c9b67282f0df5b9a430d42fc1bf60caeaa10171c20d628fb548ef35677573bab6ef050781632826b45a63287bae984a0f16aa2dd270ba95f2848cb3f478f198e33a1ae03da724e1f7dcb8bf25ffdf113f9113ed69b790fbddc28b73cffaa354b784ff1f80f518c59b33e964ab5221428648cd153b74ec044706f7190596c939b227962dbfc3a682ced5c13afa648f435ad3997267426edc263655962af291fe47a443b80e10521263c85fe8b28ebd243e30604e07f253a027c7f537ecf245a326f569336e378b21b64f17ef0abe250f1c982e8f5e6b752dba64b6394dd1d1f60d2344c8e8c9f73e3b80017311f670fbde14d57c1690a96655338dfe3e58496ff2d17264cf461da24227309dc2289</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This blog post requires a password to view.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>数学建模</category>
        <category>聚类分析</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>聚类</tag>
        <tag>Kmeans</tag>
        <tag>Kmeans++</tag>
        <tag>Python</tag>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>数模M04-插值</title>
    <url>/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/M04-%E6%8F%92%E5%80%BC/</url>
    <content><![CDATA[<h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><h2 id="一、插值定义"><a href="#一、插值定义" class="headerlink" title="一、插值定义"></a>一、插值定义</h2><p>数据处理问题：在平面上给定一组离散点列，要求一条曲线把这些点依次连接起来，称之为插值</p>
<p><strong>注意！</strong>此部分出现了大量不同的有关矩阵的函数运算方法，不同的运算方法之间对行标和列标的对应不同，最好在使用之前用<code>size()</code>方法看清相应的大小和对应关系，再进行操作！</p>
<h2 id="二、常见插值方法"><a href="#二、常见插值方法" class="headerlink" title="二、常见插值方法"></a>二、常见插值方法</h2><p>已知$n+1$个点$(x_i,y_i)\ (i=0,1,…,n)$，下面求各种插值函数</p>
<h3 id="（一）分段线性插值"><a href="#（一）分段线性插值" class="headerlink" title="（一）分段线性插值"></a>（一）分段线性插值</h3><p>将两个相邻的节点用直线连接起来，如此形成的一条折线就是分段线性插值函数，记作$I_n(x)$，它满足$I_n(x_i)=y_i$，且$I_n(x)$在每一个小区间$[x_i,x{\small i+1}]$上是线性函数   $(i=0,1,…,n)$</p>
<p>$I_n(x)$可以表示为$I_n(x)\sum\limits^n{\small i=0}y_il_i(x)$，其中</p>
<script type="math/tex; mode=display">
l_i(x)=\begin{cases}
\dfrac{x-x_{i-1}}{x_i-x_{i-1}},\quad x\in[x_{i-1},x_i]\ (i\ne 0)\\\\
\dfrac{x-x_{i+1}}{x_i-x_{i+1}},\quad x\in[x_i,x_{i+1}]\ (i\ne n)\\\\
\quad\ \ \ 0\quad\quad\,,\quad \rm Others
\end{cases}</script><p>$I_n(x)$有较好的收敛性，即对于$x\in[a,b]$，有</p>
<script type="math/tex; mode=display">
\lim_{n\to\infty}I_n(x) = f(x)</script><p>用$I_n(x)$计算x点的插值时，只用到x左右的两个节点，计算量与节点个数n无关。但n越大，分段越多，插值误差越小。实际上用函数表做插值计算时，分段线性插值就足够了，如：数学、物理重用的特殊函数表，数理统计中用的概率分布表等等</p>
<h3 id="（二）拉格朗日插值多项式"><a href="#（二）拉格朗日插值多项式" class="headerlink" title="（二）拉格朗日插值多项式"></a>（二）拉格朗日插值多项式</h3><p>拉格朗日插值的基函数为</p>
<script type="math/tex; mode=display">
\begin{align}
l_i(x) &= \dfrac{(x-x_0)\cdots(x-x_{i-1})(x-x_{i+1})\cdots(x-x_n)}{(x_i-x_0)\cdots(x_i-x_{i-1})(x_i-x_{i+1})\cdots(x_i-x_n)}\\\\
&={\prod^n_{j=0}}\limits_{j\ne i}\frac{x-x_j}{x_i-x_j}\quad(i=0,1,\cdots,n)
\end{align}</script><p>其中$l_i(x)$是n次多项式，满足</p>
<script type="math/tex; mode=display">
l_i(x_j)=
\begin{cases}
0\ ,\quad j \ne i\\
1\ ,\quad j = i
\end{cases}</script><blockquote>
<p>i,j相同时，$l_i(x)$式上下一致，结果为1</p>
<p>i,j不同时，$l_i(x)$中一定存在$(x_j-x{\small ?})=0$，结果为0</p>
</blockquote>
<p>拉格朗日插值函数：</p>
<script type="math/tex; mode=display">
L_n(x) = \sum_{i=0}^n y_il_i(x)=\sum_{i=0}^ny_i\left({\prod^n_{j=0}}\limits_{j\ne i}\dfrac{x-x_j}{x_i-x_j}\right)\quad(i=0,1,\cdots,n)</script><h3 id="（三）样条插值"><a href="#（三）样条插值" class="headerlink" title="（三）样条插值"></a>（三）样条插值</h3><p>部分问题对所得插值函数的光滑性有较高的要求，不仅要连续，而且要有连续的曲率</p>
<p>样条（Spline）原指富有弹性的细木条或金属条。利用将已知点连接成一条光滑曲线（称为样条曲线），并使连接点处具有连续的曲率，三次样条插值就是如此抽象出来的</p>
<p>数学上将具有一定光滑性的分段多项式称为样条函数。具体来说，给定区间[a,b]的一个分划</p>
<script type="math/tex; mode=display">
\Delta:a=x_0<x_1<\cdots<x_{n-1}<x_n=b</script><p>如果函数S(x)满足</p>
<ul>
<li>在每一个小区间$[x_i,x{\small i+1}]\ (i = 0,1,\cdots,n-1)$上S(x)是m次多项式</li>
<li>S(x)在$[a,b]$上具有m-1阶连续导数</li>
</ul>
<p>则称S(x)为关于分划$\Delta$的m次样条函数，其图形为m次样条曲线。显然，折现是依次样条曲线</p>
<h2 id="三、MATLAB插值工具箱-notebook-with-decorative-cover"><a href="#三、MATLAB插值工具箱-notebook-with-decorative-cover" class="headerlink" title="三、MATLAB插值工具箱:notebook_with_decorative_cover:"></a>三、MATLAB插值工具箱:notebook_with_decorative_cover:</h2><h3 id="（一）一维插值函数-interp1"><a href="#（一）一维插值函数-interp1" class="headerlink" title="（一）一维插值函数 interp1()"></a>（一）一维插值函数 interp1()</h3><p>Code : <code>&lt;ValName&gt; = interp1(x0, y0, x, &lt;method&gt;)</code></p>
<p>其中<code>&lt;method&gt;</code>指插值的方法，默认为线性插值(‘linear’)，其可选值有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>&lt; method &gt;</th>
<th>Description</th>
<th>Sp</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘linear’</td>
<td>线性插值</td>
<td>None</td>
</tr>
<tr>
<td>‘nearest’</td>
<td>最近项目插值</td>
<td>None</td>
</tr>
<tr>
<td>‘spline’</td>
<td>立方(三次)样条插值</td>
<td>保证函数平滑</td>
</tr>
<tr>
<td>‘cubic’</td>
<td>立方(三次)插值</td>
<td>保持函数凸凹性</td>
</tr>
</tbody>
</table>
</div>
<p>其中所有的插值方法都要求x0是单调的</p>
<p>当x0为等距的时候可以使用快速插值法</p>
<blockquote>
<p>method格式：<code>&#39;*linear&#39;</code> , <code>&#39;*nearest&#39;</code> , <code>&#39;*spline&#39;</code> , <code>&#39;*cubic&#39;</code></p>
</blockquote>
<h3 id="（二）一维三次样条插值"><a href="#（二）一维三次样条插值" class="headerlink" title="（二）一维三次样条插值"></a>（二）一维三次样条插值</h3><p>CodeStyle01 : <code>&lt;ValName&gt; = interp1(x0, y0, x, &#39;spline&#39;)</code></p>
<p>CodeStyle02 : <code>&lt;ValName&gt; = spline(x0, y0, x)</code></p>
<p><em>Recommand </em>: <strong>csape()</strong></p>
<p>CodeStyle03 : <code>pp = csape(x0, y0, &lt;conds&gt;)</code></p>
<p>​                         <code>&lt;ValName&gt; = fnval(pp, x)</code></p>
<p>CodeStyle04 : <code>pp = csape(x0, y0, &lt;conds&gt;, &lt;valconds&gt;)</code></p>
<p>​                         <code>&lt;ValName&gt; = fnval(pp, x)</code></p>
<p>提倡使用函数csape，其返回值是pp形式，为了求出插值点的函数值，需要调用函数fnval</p>
<p><code>pp = csape(x0, y0)</code>使用默认的边界条件（Lagrange边界条件）</p>
<p><code>&lt;conds&gt;</code>为指定插值的边界条件，可选值如下</p>
<blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>&lt; conds &gt;</th>
<th>Description</th>
<th>&lt; valconds &gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘complete’</td>
<td>边界为一阶导数</td>
<td>需提供</td>
</tr>
<tr>
<td>‘not-a-knot’</td>
<td>非扭结条件</td>
<td></td>
</tr>
<tr>
<td>‘periodic’</td>
<td>周期条件</td>
<td></td>
</tr>
<tr>
<td>‘second’</td>
<td>边界为二阶导数(缺省值为[0,0])</td>
<td>需提供</td>
</tr>
<tr>
<td>‘variational’</td>
<td>设置边界的二阶导数值为[0,0]</td>
<td>对于一些特殊的边界条件，可以通过conds的一个1$\times$2矩阵来表示，conds元素的取值为0,1,2</td>
</tr>
</tbody>
</table>
</div>
<p><strong><em>Eg:</em></strong> <code>conds = [2,1]</code> 左边界是二阶导数，右边界是一阶导数，相应的值由valconds给出</p>
<p><code>&lt;valconds&gt;</code>为<code>&lt;conds&gt;</code>方法所需的值，若不填写则按照缺省情况处理</p>
</blockquote>
<p><a href="# Eg5.1  机床加工">Eg5.1  机床加工</a></p>
<h3 id="（三）二维插值"><a href="#（三）二维插值" class="headerlink" title="（三）二维插值"></a>（三）二维插值</h3><h4 id="1-插值节点为网格节点"><a href="#1-插值节点为网格节点" class="headerlink" title="1. 插值节点为网格节点"></a>1. 插值节点为网格节点</h4><p>已知m$\times$n个节点：$(x_i,y_j,z{\small ij})\ (i = 1,2,\cdots,m;\ j=1,2,\cdots,n)$，</p>
<p>且$x_1&lt;\cdots&lt;x_m;\ y_1&lt;\cdots&lt;y_n$</p>
<p>求点$(x, y)$处的插值</p>
<h5 id="（1）二维插值函数"><a href="#（1）二维插值函数" class="headerlink" title="（1）二维插值函数"></a>（1）二维插值函数</h5><p>Code : <code>&lt;ValName&gt; = interp2(x0, y0, z0, x, y, &lt;method&gt;)</code></p>
<p>其中<code>&lt;method&gt;</code>指插值的方法，同一维的参数相同</p>
<p><strong>x0,y0</strong> 分别为<strong>m</strong>维和<strong>n</strong>维向量，表示节点，z0为 n$\times$m 维度矩阵，表示节点的值，x,y为一维数组，指插值点</p>
<p>x与y应当是方向不同的向量，即一个是行向量，一个是列向量（y需要转置）</p>
<p>输出内容为矩阵，Row=y的维数，Col=x的维数，表示得到的插值</p>
<h5 id="（2）二维三次样条插值"><a href="#（2）二维三次样条插值" class="headerlink" title="（2）二维三次样条插值"></a>（2）二维三次样条插值</h5><p>Code : <code>pp = csape(&#123;x0, y0&#125;, z0, conds, valconds)</code></p>
<p>​            <code>&lt;ValName&gt; = fnval(pp, &#123;x, y&#125;)</code></p>
<p>对其内容的解释同上</p>
<h5 id="（3）显示相应的三维网格图"><a href="#（3）显示相应的三维网格图" class="headerlink" title="（3）显示相应的三维网格图"></a>（3）显示相应的三维网格图</h5><p>Code : <code>mesh(y,x,z)</code></p>
<p>mesh函数的x为列，y为行，需要将xy反写</p>
<p><a href="# Eg5.3 丘陵曲面最高点">Eg5.3 丘陵曲面最高点</a></p>
<h4 id="2-插值节点为散乱节点"><a href="#2-插值节点为散乱节点" class="headerlink" title="2. 插值节点为散乱节点"></a>2. 插值节点为散乱节点</h4><p>已知n个节点$(x_i,y_i,z_i)\ (i=1,2,\cdots,n)$，求点$(x,y)$处的插值z</p>
<p>Code：<code>&lt;ValName&gt; = griddata(x, y, z, XI, YI)</code></p>
<p>其中x、y、z均为n维向量，指明所给出数据的横坐标、纵坐标和竖坐标 </p>
<p>向量XI、YI是给定的网格点的横坐标和纵坐标</p>
<p>返回值<code>&lt;ValName&gt;</code>为网格(XI, YI)处的函数值，但是<strong>行为YI，列为XI</strong>，进行mesh的时候不需要反转XY</p>
<p>XI与YI应当是方向不同的向量，一行一列（YI需要转置）</p>
<blockquote>
<p>MATLAB中插值时，外插值是不确定的，可以使用混合插值的方法，把不确定的插值换成最近点的插值结果</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">ZI1=griddata(x,y,z,XI,YI&#x27;,<span class="string">&#x27;cubic&#x27;</span>); <span class="comment">%立方插值</span></span><br><span class="line">ZI2=griddata(x,y,z,XI,YI&#x27;,<span class="string">&#x27;nearest&#x27;</span>); <span class="comment">%最近点插值</span></span><br><span class="line">ZI = ZI1; <span class="comment">%</span></span><br><span class="line">ZI(<span class="built_in">isnan</span>(ZI1)) = ZI2(<span class="built_in">isnan</span>(ZI1));</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h2 id="四、实战例题"><a href="#四、实战例题" class="headerlink" title="四、实战例题"></a>四、实战例题</h2><h4 id="Eg5-1-机床加工"><a href="#Eg5-1-机床加工" class="headerlink" title="Eg5.1  机床加工"></a>Eg5.1  机床加工</h4><blockquote>
<p>待加工零件的外形根据工艺要求由一组数据$(x,y)$给出（在平面情况下），用程控铣床加工时每一刀只能沿$x$方向和$y$方向走非常小的一步，这就需要从已知数据得到加工所要求的步长很小的$(x,y)$坐标。<br>Data中给出的$x,y$数据位于机翼断面的下轮廓线上，假设需要得到$x$坐标每改变0.1时的$y$坐标。试完成加工所需数据，画出曲线，并求出$x=0$处的曲线斜率和$13\le x\le15$范围内y的最小值。要求用分段线性和三次样条两种插值方法计算。</p>
</blockquote>
<p>Data：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center">0</th>
<th style="text-align:center">3</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
<th style="text-align:center">13</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>y</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1.2</td>
<td style="text-align:center">1.7</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">2.1</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">1.8</td>
<td style="text-align:center">1.2</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">1.6</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% Data:</span></span><br><span class="line">x0 = [<span class="number">0</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>];</span><br><span class="line">y0 = [<span class="number">0</span> <span class="number">1.2</span> <span class="number">1.7</span> <span class="number">2.0</span> <span class="number">2.1</span> <span class="number">2.0</span> <span class="number">1.8</span> <span class="number">1.2</span> <span class="number">1.0</span> <span class="number">1.6</span>];</span><br><span class="line">x = [<span class="built_in">min</span>(x0):<span class="number">0.1</span>:<span class="built_in">max</span>(x0)];</span><br><span class="line"><span class="comment">%% Linear</span></span><br><span class="line">y_linear = interp1(x0, y0, x);</span><br><span class="line"><span class="comment">%% Spline</span></span><br><span class="line">y_spline = interp1(x0, y0, x, <span class="string">&#x27;spline&#x27;</span>);</span><br><span class="line">pp_lagrange = csape(x0, y0);</span><br><span class="line">y_spline_lagrange = fnval(pp_lagrange, x);</span><br><span class="line">pp_second = csape(x0, y0, <span class="string">&#x27;second&#x27;</span>);</span><br><span class="line">y_spline_second = fnval(pp_second, x);</span><br><span class="line"><span class="comment">%% DispFigure</span></span><br><span class="line"><span class="comment">% linear</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Position&#x27;</span>, [<span class="number">800</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">800</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y_linear, <span class="string">&#x27;r&#x27;</span>,x0, y0,<span class="string">&#x27;bp&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Interp1-Linear&#x27;</span>)</span><br><span class="line"><span class="comment">% spline</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y_spline, <span class="string">&#x27;r&#x27;</span>,x0, y0,<span class="string">&#x27;bp&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Interp1-Spline&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y_spline_lagrange, <span class="string">&#x27;r&#x27;</span>,x0, y0,<span class="string">&#x27;bp&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Csape-Lagrange&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y_spline_second, <span class="string">&#x27;r&#x27;</span>,x0, y0,<span class="string">&#x27;bp&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Csape-Second&#x27;</span>)</span><br><span class="line"><span class="comment">%% Other Tasks</span></span><br><span class="line"><span class="comment">% 求x=0处的斜率</span></span><br><span class="line">dx = diff(x); <span class="comment">% diff逐差函数</span></span><br><span class="line">dy = diff(y_spline_lagrange);</span><br><span class="line">dy_dx = dy./dx;</span><br><span class="line">dy_dx_0 = dy_dx(<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 求13~15范围内y的最小值</span></span><br><span class="line">ymin = <span class="built_in">min</span>(y_spline_lagrange(<span class="number">131</span>:<span class="number">151</span>)); <span class="comment">% 找出ymin</span></span><br><span class="line">yloc = <span class="built_in">find</span>(y_spline_lagrange == ymin); <span class="comment">% find ymin的index</span></span><br><span class="line">xloc = x(yloc); <span class="comment">% 用ymin的index定位xloc</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;k(0) = &#x27;</span> num2str(dy_dx_0)])</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;xloc: &#x27;</span> num2str(xloc)])</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;ymin: &#x27;</span> num2str(ymin)])</span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k(0) = 0.49716</span><br><span class="line">xloc: 13.8</span><br><span class="line">ymin: 0.98511</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/XLY23333/picture01/img01/eg51output.jpg" alt="eg51output"></p>
<h4 id="Eg5-2-求速度曲线的位移"><a href="#Eg5-2-求速度曲线的位移" class="headerlink" title="Eg5.2 求速度曲线的位移"></a>Eg5.2 求速度曲线的位移</h4><blockquote>
<p>已知速度曲线$v(t)$上的四个数据点如下表，用三次样条插值求位移</p>
<script type="math/tex; mode=display">
S = \int_{0.15}^{0.18}v(t)\,{\rm d}t</script></blockquote>
<p>Data:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$t$</th>
<th>0.15</th>
<th>0.16</th>
<th>0.17</th>
<th>0.18</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>$v(t)$</strong></td>
<td>3.5</td>
<td>1.5</td>
<td>2.5</td>
<td>2.8</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% DataLoad</span></span><br><span class="line">t0 = <span class="number">0.15</span>:<span class="number">0.01</span>:<span class="number">0.18</span>;</span><br><span class="line">v0 = [<span class="number">3.5</span>,<span class="number">1.5</span>,<span class="number">2.5</span>,<span class="number">2.8</span>];</span><br><span class="line"><span class="comment">%% Spline</span></span><br><span class="line">pp = csape(t0, v0); <span class="comment">% 使用默认边界条件Lagrange</span></span><br><span class="line">format long g <span class="comment">% 设置长小数格式</span></span><br><span class="line">xs = pp.coefs <span class="comment">% 显示每个区间上三次多项式的系数</span></span><br><span class="line">s = integral(@(t)ppval(pp,t),<span class="number">0.15</span>,<span class="number">0.18</span>) <span class="comment">% 求数值积分</span></span><br><span class="line">    <span class="comment">% @(t) 为匿名函数的书写格式 </span></span><br><span class="line">    <span class="comment">% integral(fx,xmin,ymin) 求数值积分</span></span><br><span class="line">        <span class="comment">% 使用全局自适应积分和默认误差容限在 xmin 至 xmax 间以数值形式为函数</span></span><br><span class="line">    <span class="comment">% ppval(pp,xq)计算分段多项式:查询点 xq 处计算分段多项式 pp</span></span><br><span class="line">format <span class="comment">% 恢复短小数小时格式</span></span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xs =     -616666.666666667                     33500         -473.333333333334                       3.5</span><br><span class="line">         -616666.666666667                     15000          11.6666666666671                       1.5</span><br><span class="line">         -616666.666666668         -3499.99999999999          126.666666666667                       2.5</span><br><span class="line">s =0.068625</span><br></pre></td></tr></table></figure>
<h4 id="Eg5-3-丘陵曲面最高点"><a href="#Eg5-3-丘陵曲面最高点" class="headerlink" title="Eg5.3 丘陵曲面最高点"></a>Eg5.3 丘陵曲面最高点</h4><blockquote>
<p>在一丘陵地带测量高程，x和y方向每隔100米测一个点，得高程如表，试插值一曲面，确定合适的模型，并由此找出最高点和该点的高程</p>
</blockquote>
<p>Data:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">y\x</th>
<th style="text-align:center">100</th>
<th style="text-align:center">200</th>
<th style="text-align:center">300</th>
<th style="text-align:center">400</th>
<th style="text-align:center">500</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>100</strong></td>
<td style="text-align:center">636</td>
<td style="text-align:center">697</td>
<td style="text-align:center">624</td>
<td style="text-align:center">478</td>
<td style="text-align:center">450</td>
</tr>
<tr>
<td style="text-align:center"><strong>200</strong></td>
<td style="text-align:center">698</td>
<td style="text-align:center">712</td>
<td style="text-align:center">630</td>
<td style="text-align:center">478</td>
<td style="text-align:center">420</td>
</tr>
<tr>
<td style="text-align:center"><strong>300</strong></td>
<td style="text-align:center">680</td>
<td style="text-align:center">674</td>
<td style="text-align:center">598</td>
<td style="text-align:center">412</td>
<td style="text-align:center">400</td>
</tr>
<tr>
<td style="text-align:center"><strong>400</strong></td>
<td style="text-align:center">662</td>
<td style="text-align:center">626</td>
<td style="text-align:center">552</td>
<td style="text-align:center">334</td>
<td style="text-align:center">310</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意此处直接列写矩阵，则xy与正常的对应相反</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% DataLoad</span></span><br><span class="line">x0 = <span class="number">100</span>:<span class="number">100</span>:<span class="number">500</span>;</span><br><span class="line">y0 = <span class="number">100</span>:<span class="number">100</span>:<span class="number">400</span>;</span><br><span class="line">z0 = [<span class="number">636</span> <span class="number">697</span> <span class="number">624</span> <span class="number">478</span> <span class="number">450</span></span><br><span class="line">      <span class="number">698</span> <span class="number">712</span> <span class="number">630</span> <span class="number">478</span> <span class="number">420</span></span><br><span class="line">      <span class="number">680</span> <span class="number">674</span> <span class="number">598</span> <span class="number">412</span> <span class="number">400</span></span><br><span class="line">      <span class="number">662</span> <span class="number">626</span> <span class="number">552</span> <span class="number">334</span> <span class="number">310</span>]&#x27;;</span><br><span class="line"><span class="comment">% 此处的z0两坐标方向交叉，需要转置</span></span><br><span class="line">step = <span class="number">5</span>;</span><br><span class="line">x = <span class="number">100</span>:step:<span class="number">500</span>;</span><br><span class="line">y = <span class="number">100</span>:step:<span class="number">400</span>;</span><br><span class="line"><span class="comment">%% interp</span></span><br><span class="line"><span class="comment">% interp2要求矩阵和向量交叉对应，且y为列向量</span></span><br><span class="line">z1 = interp2(x0,y0,z0&#x27;,x,y&#x27;);</span><br><span class="line">z1 = z1&#x27;; <span class="comment">% 转置z1回正常的对应</span></span><br><span class="line"><span class="comment">% csape正常进行</span></span><br><span class="line">pp = csape(&#123;x0,y0&#125;,z0);</span><br><span class="line">z2 = fnval(pp,&#123;x,y&#125;);</span><br><span class="line"><span class="comment">%% DispMesh</span></span><br><span class="line"><span class="comment">% mesh函数的x为列，y为行，需要将xy反写</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Position&#x27;</span>,[<span class="number">500</span>,<span class="number">300</span>,<span class="number">1000</span>,<span class="number">600</span>])</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">mesh(y,x,z1) </span><br><span class="line">title(<span class="string">&#x27;Interp1-Linear&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">mesh(y,x,z2)</span><br><span class="line">title(<span class="string">&#x27;Spline&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">20</span>)</span><br><span class="line"><span class="comment">%% MAXValue</span></span><br><span class="line"><span class="comment">% interp-Linear</span></span><br><span class="line">[maxls1,xlocls1] = <span class="built_in">max</span>(z1); <span class="comment">% 按列取max</span></span><br><span class="line">[vmax1,yloc1] = <span class="built_in">max</span>(maxls1); <span class="comment">% 按行取max</span></span><br><span class="line">info1 = [<span class="string">&quot;interp-Linear&quot;</span>,x(xlocls1(yloc1)),y(yloc1),vmax1]; </span><br><span class="line">    <span class="comment">% 行loc索引列ls的loc,并用loc索引相应的x,y的值</span></span><br><span class="line"><span class="comment">% Spline</span></span><br><span class="line">[maxls2,xlocls2] = <span class="built_in">max</span>(z2);</span><br><span class="line">[vmax2,yloc2] = <span class="built_in">max</span>(maxls2);</span><br><span class="line">info2 = [<span class="string">&quot;Spline&quot;</span>,x(xlocls2(yloc2)),y(yloc2),vmax2]; </span><br><span class="line">info = [info1;info2];</span><br><span class="line"><span class="comment">% 更好的位置索引方法</span></span><br><span class="line">[<span class="built_in">i</span>,<span class="built_in">j</span>]=<span class="built_in">find</span>(z2==<span class="built_in">max</span>(<span class="built_in">max</span>(z2)));  <span class="comment">%找最高点的地址</span></span><br><span class="line">xm=x(<span class="built_in">i</span>),ym=y(<span class="built_in">j</span>),zm=z2(<span class="built_in">i</span>,<span class="built_in">j</span>);  <span class="comment">%求最高点的坐标 </span></span><br><span class="line">[zm,xm,ym]</span><br><span class="line"><span class="comment">%% DispMAX</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;Step:&#x27;</span> num2str(step)])</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;Type:&#x27;</span> num2str(info(<span class="built_in">i</span>,<span class="number">1</span>))]) </span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;max = &#x27;</span> num2str(info(<span class="built_in">i</span>,<span class="number">4</span>)) ...</span><br><span class="line">        <span class="string">&#x27;    x = &#x27;</span> num2str(info(<span class="built_in">i</span>,<span class="number">2</span>)) ...</span><br><span class="line">        <span class="string">&#x27;    y = &#x27;</span> num2str(info(<span class="built_in">i</span>,<span class="number">3</span>))])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  720.7217  165.0000  175.0000</span><br><span class="line">Step:5</span><br><span class="line">Type:interp-Linear</span><br><span class="line">max = 712    x = 200    y = 200</span><br><span class="line">Type:Spline</span><br><span class="line">max = 720.7217    x = 165    y = 175</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/XLY23333/picture01/img01/eg53output.jpg" alt="eg53output"></p>
<h4 id="Eg5-4-海底图像"><a href="#Eg5-4-海底图像" class="headerlink" title="Eg5.4 海底图像"></a>Eg5.4 海底图像</h4><blockquote>
<p>在某海域测得一些点（x,y）处的水深z由表5.4给出，在适当的矩形区域内画出海底曲面的图形。</p>
</blockquote>
<p>Data：</p>
<blockquote>
<p>x=[129,140,103.5,88,185.5,195,105,157.5,107.5,77,81,162,162,117.5];</p>
<p>y=[7.5,141.5,23,147,22.5,137.5,85.5,-6.5,-81,3,56.5,-66.5,84,-33.5];</p>
<p>z=-[4,8,6,8,6,8,8,9,9,8,8,9,4,9];</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% DataLoad</span></span><br><span class="line">x=[<span class="number">129</span>,<span class="number">140</span>,<span class="number">103.5</span>,<span class="number">88</span>,<span class="number">185.5</span>,<span class="number">195</span>,<span class="number">105</span>,<span class="number">157.5</span>,<span class="number">107.5</span>,<span class="number">77</span>,<span class="number">81</span>,<span class="number">162</span>,<span class="number">162</span>,<span class="number">117.5</span>];</span><br><span class="line">y=[<span class="number">7.5</span>,<span class="number">141.5</span>,<span class="number">23</span>,<span class="number">147</span>,<span class="number">22.5</span>,<span class="number">137.5</span>,<span class="number">85.5</span>,<span class="number">-6.5</span>,<span class="number">-81</span>,<span class="number">3</span>,<span class="number">56.5</span>,<span class="number">-66.5</span>,<span class="number">84</span>,<span class="number">-33.5</span>];</span><br><span class="line">z=-[<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>];</span><br><span class="line">step = <span class="number">1</span>;</span><br><span class="line">XI = <span class="built_in">min</span>(x):step:<span class="built_in">max</span>(x)</span><br><span class="line">YI = <span class="built_in">min</span>(y):step:<span class="built_in">max</span>(y)</span><br><span class="line"><span class="comment">%% grid</span></span><br><span class="line">ZI1=griddata(x,y,z,XI,YI&#x27;,<span class="string">&#x27;cubic&#x27;</span>); <span class="comment">%立方插值</span></span><br><span class="line">ZI2=griddata(x,y,z,XI,YI&#x27;,<span class="string">&#x27;nearest&#x27;</span>); <span class="comment">%最近点插值</span></span><br><span class="line">ZI = ZI1; <span class="comment">% 设置ZI初始值为ZI1</span></span><br><span class="line">ZI(<span class="built_in">isnan</span>(ZI1)) = ZI2(<span class="built_in">isnan</span>(ZI1)); <span class="comment">% 用ZI2填充ZI1外插值(为NaN)的部分</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">mesh(XI,YI,ZI)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,<span class="string">&#x27;or&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/XLY23333/picture01/img01/eg54output.jpg" alt="eg54output"></p>
]]></content>
      <categories>
        <category>数学建模</category>
        <category>预测模型</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>预测</tag>
        <tag>插值</tag>
      </tags>
  </entry>
  <entry>
    <title>数模M05-拟合</title>
    <url>/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/M05-%E6%8B%9F%E5%90%88/</url>
    <content><![CDATA[<h1 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h1><h2 id="一、曲线拟合的线性最小二乘法"><a href="#一、曲线拟合的线性最小二乘法" class="headerlink" title="一、曲线拟合的线性最小二乘法"></a>一、曲线拟合的线性最小二乘法</h2><h3 id="（一）线性最小二乘法"><a href="#（一）线性最小二乘法" class="headerlink" title="（一）线性最小二乘法"></a>（一）线性最小二乘法</h3><h4 id="1-问题提出"><a href="#1-问题提出" class="headerlink" title="1. 问题提出"></a>1. 问题提出</h4><h5 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h5><p>已知一组（二维）数据，即平面上的n个点$(x_i,y_i)\ (i=1,2,\cdots,n)$，$x_i$互不相同，求一个函数（曲线）$y=f(x)$使得$f(x)$在某种准则下与所有数据点最为接近，即曲线拟合的最好</p>
<p>线性最小二乘法是解决曲线拟合最常见的方法，思路为：令</p>
<script type="math/tex; mode=display">
f(x) = a_1r_1(x)+a_2r_2(x)+\cdots+a_mr_m(x)</script><p>其中$r_k(x)$是事先选定的一组线性无关的函数，$a_k$是待定系数 $(k=1,2,\cdots,m\quad ,m&lt;n)$</p>
<p>拟合的准则为使$y_i\ ,(i=1,2,\cdots,n)$与$f(x_i)$的距离$\delta_i$的平方和最小，称为最小二乘准则</p>
<h5 id="（2）系数-a-k-的确定"><a href="#（2）系数-a-k-的确定" class="headerlink" title="（2）系数$a_k$的确定"></a>（2）系数$a_k$的确定</h5><p>记</p>
<script type="math/tex; mode=display">
J(a_1,\cdots,a_m)=\sum^n_{i=1}\delta^2_i=\sum^n_{i=1}[f(x_i)-y_i]^2</script><p>为求$a_1,\cdots,a_m$使得$J$达到最小，秩序利用极值的必要条件$\dfrac{\partial J}{\partial A_j}=0\ (j=1,\cdots,m)$，得到关于$a_1,\cdots,a_m$的线性方程组</p>
<script type="math/tex; mode=display">
\sum^n_{i=1}r_j(x_i)[\sum^m_{k=1}a_kr_k(x_i)-y_i]=0\quad,(j=1,\cdots,m)</script><p>即</p>
<script type="math/tex; mode=display">
\sum^n_{i=1}a_k[\sum^m_{k=1}r_j(x_i)r_k(x_i)]=\sum^n_{i=1}r_j(x_i)y_i\quad,(j=1,\cdots,m)</script><p>记</p>
<script type="math/tex; mode=display">
R=
\begin{bmatrix}
r_1(x_1) & \cdots & r_m(x_1)\\
\vdots & \vdots & \vdots \\
r_1(x_n) & \cdots & r_m(x_n)\\
\end{bmatrix}_{n\times m}\\\\
A=[a_1,\cdots,a_m]^{\rm T}\ ,\ Y=[y_1,\cdots,y_n]^{\rm T}</script><p>当${r_1(x),\cdots,r_m(x)}$线性无关时，$R$列满秩，$R^{\rm T}R$可逆，于是上方程组有唯一解</p>
<script type="math/tex; mode=display">
A = (R^{\rm T}R)^{-1}R^{\rm T}Y</script><h5 id="（3）函数-r-k-x-的选择"><a href="#（3）函数-r-k-x-的选择" class="headerlink" title="（3）函数$r_k(x)$的选择"></a>（3）函数$r_k(x)$的选择</h5><p>通常通过机理分析能够知道有什么样的函数关系，如果不清楚其关系，可以先对数据作图，直观的判断应该使用的拟合曲线</p>
<p>常见的拟合曲线选择</p>
<ul>
<li>直线 $y=a_1x+a_2$</li>
<li>多项式（一般m=2，3，不宜太高）$y=a_1x^m+\cdots+a_mx+a{\small m+1}$</li>
<li>双曲线（一支）$y=\dfrac{a_1}{x}+a_2$</li>
<li>指数曲线 $y=a_1e^{a_2x}$</li>
</ul>
<blockquote>
<p>对于指数曲线，拟合前需做变量代换，化为对$a_1,a_2$的线性函数</p>
</blockquote>
<p>可以选择多种曲线进行拟合，通过判断最后$J$值，选择最小的一条</p>
<p>也可以通过计算MSE、MAE等数值对拟合的结果进行评价</p>
<h3 id="（二）MATLAB实现最小二乘法"><a href="#（二）MATLAB实现最小二乘法" class="headerlink" title="（二）MATLAB实现最小二乘法"></a>（二）MATLAB实现最小二乘法</h3><h4 id="1-解方程法"><a href="#1-解方程法" class="headerlink" title="1. 解方程法"></a>1. 解方程法</h4><p>由上述的可得 $J(a_1,\cdots,a_m) = ||RA-Y||^2$</p>
<p>MATLAB中的线性最小二乘标准型为 $\min\limits_A||RA-Y||^2_2$</p>
<p>CoreCode : <code>A = R/Y</code> </p>
<p>在此方法下，需要将用于训练的x0，y0数据初始化为<strong>列向量</strong></p>
<p>其中A是返回的系数矩阵，R为拟合所用函数由x0列向量对应值构建的矩阵，Y为训练用的y0列向量</p>
<p>R的具体的构建方法如下：</p>
<p>将构建函数对应的每一项依次带入列向量x0，一个系数一列，所以需要将x0，y0数据初始化为<strong>列向量</strong></p>
<p>特殊的，常数项可以用<code>ones(size(x0))</code>来替换，同时也可以用于倒数等位置Init用1的情况</p>
<p>最终得出的A数组每一位对应R矩阵的每一列所求的系数</p>
<p><strong>Eg：</strong></p>
<p>拟合函数：$a+bx^2+c\dfrac{1}{x}$ ，已知训练数据 $x0\ ,y0$ ，需要进行拟合的范围 $x$</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">R = [<span class="built_in">ones</span>(<span class="built_in">size</span>(x0)), x0.^<span class="number">2</span>, <span class="built_in">ones</span>(<span class="built_in">size</span>(x0))./x]；</span><br><span class="line">a = R(<span class="number">1</span>)</span><br><span class="line">b = R(<span class="number">2</span>)</span><br><span class="line">c = R(<span class="number">3</span>)</span><br><span class="line">y = a + b*x.^<span class="number">2</span> + c./x <span class="comment">% 输出x所包含范围内的拟合y值</span></span><br></pre></td></tr></table></figure>
<h4 id="2-多项式拟合Poly"><a href="#2-多项式拟合Poly" class="headerlink" title="2. 多项式拟合Poly"></a>2. 多项式拟合Poly</h4><p>如果取 ${r<em>1(x),\cdots,r</em>{m+1}(x)}={1,x,\cdots,x^m}$，即用m次多项式拟合给定的数据，可以用MATLAB中的poly系列函数执行</p>
<h5 id="（1）拟合函数"><a href="#（1）拟合函数" class="headerlink" title="（1）拟合函数"></a>（1）拟合函数</h5><p>Code : <code>A = polyfit(x0, y0, &lt;Count&gt;)</code></p>
<p>其中<code>&lt;Count&gt;</code>为拟合多项式的次数，输出的参数A为拟合多项式的系数数组，从高次项向低次项的顺序</p>
<p>即在拟合函数$y=a(1)x^m+\cdots+a(m)x+a(m+1)$中，$a=[a(1),\cdots,a(m),a(m+1)]$</p>
<h5 id="（2）数值计算"><a href="#（2）数值计算" class="headerlink" title="（2）数值计算"></a>（2）数值计算</h5><p>Code : <code>y = polyval(A,x)</code></p>
<p>其中x为拟合需求的取值，当x换成x0的时候，可以用与求y_fit_test，并进行MSE检测</p>
<h4 id="3-MSE检测拟合度"><a href="#3-MSE检测拟合度" class="headerlink" title="3. MSE检测拟合度"></a>3. MSE检测拟合度</h4><p>MSE(Mean Squared Error)是指最小平方误差，可以检验拟合结果和实际结果的MSE来判断拟合的程度</p>
<h5 id="（1）MATLAB实现代码："><a href="#（1）MATLAB实现代码：" class="headerlink" title="（1）MATLAB实现代码："></a>（1）MATLAB实现代码：</h5><p><code>MSEValue = mse(&lt;y_real&gt; - &lt;y_fit_test&gt;)</code></p>
<p>如果使用<strong>解方程法</strong>拟合，应当首先对<code>&lt;y_real&gt;</code>进行转置，即 <code>mse(&lt;y_real&gt;&#39;-&lt;y_fit_test&gt;)</code></p>
<h5 id="（2）y-fit-test的获取方法"><a href="#（2）y-fit-test的获取方法" class="headerlink" title="（2）y_fit_test的获取方法"></a>（2）y_fit_test的获取方法</h5><ul>
<li><p>拟合相应点</p>
<ul>
<li><p>解方程法：<code>y_fit_test = f(x0)</code></p>
<ul>
<li><code>f</code>为代入系数矩阵A的相应的函数求解表达式，其中自变量改为<strong>x0</strong></li>
</ul>
</li>
<li><p>polyval法：<code>y_fit_test = polyval(r,x0)</code></p>
<ul>
<li><code>r</code>为<code>polyfit</code>所得到的系数数组，进行<code>ployval</code>的自变量为<strong>x0</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>包含拟合后索引（x的步长需为等长）</p>
<ul>
<li><code>y_fit_test = y(1+(x0-min(x)./step))</code><ul>
<li>其中x为拟合要求的数据范围，<strong>step是x的步长</strong></li>
</ul>
</li>
<li><code>y_fit_test = y(round(1+(x0-min(x))./(x(2)-x(1))))</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数学建模</category>
        <category>预测模型</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>预测</tag>
        <tag>拟合</tag>
      </tags>
  </entry>
  <entry>
    <title>TestDoc</title>
    <url>/test/b01-test/</url>
    <content><![CDATA[<h3 id="TestDoc"><a href="#TestDoc" class="headerlink" title="TestDoc"></a>TestDoc</h3><p>这是一篇测试文章，选用的内容为数学建模插值的内容：</p>
<iframe src="//player.bilibili.com/player.html?aid=824706868&bvid=BV1ig4y1M7z6&cid=1088440765&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><p>[toc]</p>
<h2 id="一、插值定义"><a href="#一、插值定义" class="headerlink" title="一、插值定义"></a>一、插值定义</h2><p>数据处理问题：在平面上给定一组离散点列，要求一条曲线把这些点依次连接起来，称之为插值</p>
<p><strong>注意！</strong>此部分出现了大量不同的有关矩阵的函数运算方法，不同的运算方法之间对行标和列标的对应不同，最好在使用之前用<code>size()</code>方法看清相应的大小和对应关系，再进行操作！</p>
<h2 id="二、常见插值方法"><a href="#二、常见插值方法" class="headerlink" title="二、常见插值方法"></a>二、常见插值方法</h2><p>已知$n+1$个点$(x_i,y_i)\ (i=0,1,…,n)$，下面求各种插值函数</p>
<h3 id="（一）分段线性插值"><a href="#（一）分段线性插值" class="headerlink" title="（一）分段线性插值"></a>（一）分段线性插值</h3><p>将两个相邻的节点用直线连接起来，如此形成的一条折线就是分段线性插值函数，记作$I<em>n(x)$，它满足$I_n(x_i)=y_i$，且$I_n(x)$在每一个小区间$[x_i,x</em>{i+1}]$上是线性函数   $(i=0,1,…,n)$</p>
<p>$I<em>n(x)$可以表示为$I_n(x)\sum\limits^n</em>{i=0}y_il_i(x)$，其中</p>
<script type="math/tex; mode=display">
l_i(x)=\begin{cases}
\dfrac{x-x_{i-1}}{x_i-x_{i-1}},\quad x\in[x_{i-1},x_i]\ (i\ne 0)\\\\
\dfrac{x-x_{i+1}}{x_i-x_{i+1}},\quad x\in[x_i,x_{i+1}]\ (i\ne n)\\\\
\quad\ \ \ 0\quad\quad\,,\quad \rm Others
\end{cases}</script><p>$I_n(x)$有较好的收敛性，即对于$x\in[a,b]$，有</p>
<script type="math/tex; mode=display">
\lim_{n\to\infty}I_n(x) = f(x)</script><p>用$I_n(x)$计算x点的插值时，只用到x左右的两个节点，计算量与节点个数n无关。但n越大，分段越多，插值误差越小。实际上用函数表做插值计算时，分段线性插值就足够了，如：数学、物理重用的特殊函数表，数理统计中用的概率分布表等等</p>
<h3 id="（二）拉格朗日插值多项式"><a href="#（二）拉格朗日插值多项式" class="headerlink" title="（二）拉格朗日插值多项式"></a>（二）拉格朗日插值多项式</h3><p>拉格朗日插值的基函数为</p>
<script type="math/tex; mode=display">
\begin{align}
l_i(x) &= \dfrac{(x-x_0)\cdots(x-x_{i-1})(x-x_{i+1})\cdots(x-x_n)}{(x_i-x_0)\cdots(x_i-x_{i-1})(x_i-x_{i+1})\cdots(x_i-x_n)}\\\\
&={\prod^n_{j=0}}\limits_{j\ne i}\frac{x-x_j}{x_i-x_j}\quad(i=0,1,\cdots,n)
\end{align}</script><p>其中$l_i(x)$是n次多项式，满足</p>
<script type="math/tex; mode=display">
l_i(x_j)=
\begin{cases}
0\ ,\quad j \ne i\\
1\ ,\quad j = i
\end{cases}</script><blockquote>
<p>i,j相同时，$l_i(x)$式上下一致，结果为1</p>
<p>i,j不同时，$l<em>i(x)$中一定存在$(x_j-x</em>?)=0$，结果为0</p>
</blockquote>
<p>拉格朗日插值函数：</p>
<script type="math/tex; mode=display">
L_n(x) = \sum_{i=0}^n y_il_i(x)=\sum_{i=0}^ny_i\left({\prod^n_{j=0}}\limits_{j\ne i}\dfrac{x-x_j}{x_i-x_j}\right)\quad(i=0,1,\cdots,n)</script><h3 id="（三）样条插值"><a href="#（三）样条插值" class="headerlink" title="（三）样条插值"></a>（三）样条插值</h3><p>部分问题对所得插值函数的光滑性有较高的要求，不仅要连续，而且要有连续的曲率</p>
<p>样条（Spline）原指富有弹性的细木条或金属条。利用将已知点连接成一条光滑曲线（称为样条曲线），并使连接点处具有连续的曲率，三次样条插值就是如此抽象出来的</p>
<p>数学上将具有一定光滑性的分段多项式称为样条函数。具体来说，给定区间[a,b]的一个分划</p>
<script type="math/tex; mode=display">
\Delta:a=x_0<x_1<\cdots<x_{n-1}<x_n=b</script><p>如果函数S(x)满足</p>
<ul>
<li>在每一个小区间$[x<em>i,x</em>{i+1}]\ (i = 0,1,\cdots,n-1)$上S(x)是m次多项式</li>
<li>S(x)在$[a,b]$上具有m-1阶连续导数</li>
</ul>
<p>则称S(x)为关于分划$\Delta$的m次样条函数，其图形为m次样条曲线。显然，折现是依次样条曲线</p>
<h2 id="三、MATLAB插值工具箱-notebook-with-decorative-cover"><a href="#三、MATLAB插值工具箱-notebook-with-decorative-cover" class="headerlink" title="三、MATLAB插值工具箱:notebook_with_decorative_cover:"></a>三、MATLAB插值工具箱:notebook_with_decorative_cover:</h2><h3 id="（一）一维插值函数-interp1"><a href="#（一）一维插值函数-interp1" class="headerlink" title="（一）一维插值函数 interp1()"></a>（一）一维插值函数 interp1()</h3><p>Code : <code>&lt;ValName&gt; = interp1(x0, y0, x, &lt;method&gt;)</code></p>
<p>其中<code>&lt;method&gt;</code>指插值的方法，默认为线性插值(‘linear’)，其可选值有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>&lt; method &gt;</th>
<th>Description</th>
<th>Sp</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘linear’</td>
<td>线性插值</td>
<td>None</td>
</tr>
<tr>
<td>‘nearest’</td>
<td>最近项目插值</td>
<td>None</td>
</tr>
<tr>
<td>‘spline’</td>
<td>立方(三次)样条插值</td>
<td>保证函数平滑</td>
</tr>
<tr>
<td>‘cubic’</td>
<td>立方(三次)插值</td>
<td>保持函数凸凹性</td>
</tr>
</tbody>
</table>
</div>
<p>其中所有的插值方法都要求x0是单调的</p>
<p>当x0为等距的时候可以使用快速插值法</p>
<blockquote>
<p>method格式：<code>&#39;*linear&#39;</code> , <code>&#39;*nearest&#39;</code> , <code>&#39;*spline&#39;</code> , <code>&#39;*cubic&#39;</code></p>
</blockquote>
<h3 id="（二）一维三次样条插值"><a href="#（二）一维三次样条插值" class="headerlink" title="（二）一维三次样条插值"></a>（二）一维三次样条插值</h3><p>CodeStyle01 : <code>&lt;ValName&gt; = interp1(x0, y0, x, &#39;spline&#39;)</code></p>
<p>CodeStyle02 : <code>&lt;ValName&gt; = spline(x0, y0, x)</code></p>
<p><em>Recommand </em>: <strong>csape()</strong></p>
<p>CodeStyle03 : <code>pp = csape(x0, y0, &lt;conds&gt;)</code></p>
<p>​                         <code>&lt;ValName&gt; = fnval(pp, x)</code></p>
<p>CodeStyle04 : <code>pp = csape(x0, y0, &lt;conds&gt;, &lt;valconds&gt;)</code></p>
<p>​                         <code>&lt;ValName&gt; = fnval(pp, x)</code></p>
<p>提倡使用函数csape，其返回值是pp形式，为了求出插值点的函数值，需要调用函数fnval</p>
<p><code>pp = csape(x0, y0)</code>使用默认的边界条件（Lagrange边界条件）</p>
<p><code>&lt;conds&gt;</code>为指定插值的边界条件，可选值如下</p>
<blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>&lt; conds &gt;</th>
<th>Description</th>
<th>&lt; valconds &gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘complete’</td>
<td>边界为一阶导数</td>
<td>需提供</td>
</tr>
<tr>
<td>‘not-a-knot’</td>
<td>非扭结条件</td>
<td></td>
</tr>
<tr>
<td>‘periodic’</td>
<td>周期条件</td>
<td></td>
</tr>
<tr>
<td>‘second’</td>
<td>边界为二阶导数(缺省值为[0,0])</td>
<td>需提供</td>
</tr>
<tr>
<td>‘variational’</td>
<td>设置边界的二阶导数值为[0,0]</td>
<td>对于一些特殊的边界条件，可以通过conds的一个1$\times$2矩阵来表示，conds元素的取值为0,1,2</td>
</tr>
</tbody>
</table>
</div>
<p><strong><em>Eg:</em></strong> <code>conds = [2,1]</code> 左边界是二阶导数，右边界是一阶导数，相应的值由valconds给出</p>
<p><code>&lt;valconds&gt;</code>为<code>&lt;conds&gt;</code>方法所需的值，若不填写则按照缺省情况处理</p>
</blockquote>
<p><a href="# Eg5.1  机床加工">Eg5.1  机床加工</a></p>
<h3 id="（三）二维插值"><a href="#（三）二维插值" class="headerlink" title="（三）二维插值"></a>（三）二维插值</h3><h4 id="1-插值节点为网格节点"><a href="#1-插值节点为网格节点" class="headerlink" title="1. 插值节点为网格节点"></a>1. 插值节点为网格节点</h4><p>已知m$\times$n个节点：$(x<em>i,y_j,z</em>{ij})\ (i = 1,2,\cdots,m;\ j=1,2,\cdots,n)$，</p>
<p>且$x_1&lt;\cdots&lt;x_m;\ y_1&lt;\cdots&lt;y_n$</p>
<p>求点$(x, y)$处的插值</p>
<h5 id="（1）二维插值函数"><a href="#（1）二维插值函数" class="headerlink" title="（1）二维插值函数"></a>（1）二维插值函数</h5><p>Code : <code>&lt;ValName&gt; = interp2(x0, y0, z0, x, y, &lt;method&gt;)</code></p>
<p>其中<code>&lt;method&gt;</code>指插值的方法，同一维的参数相同</p>
<p><strong>x0,y0</strong>分别为<strong>m</strong>维和<strong>n</strong>维向量，表示节点，<strong>z0为n$\times$m维度矩阵</strong>，表示节点的值，x,y为一维数组，指插值点，</p>
<p>x与y应当是方向不同的向量，即一个是行向量，一个是列向量（y需要转置）</p>
<p>输出内容为矩阵，Row=y的维数，Col=x的维数，表示得到的插值</p>
<h5 id="（2）二维三次样条插值"><a href="#（2）二维三次样条插值" class="headerlink" title="（2）二维三次样条插值"></a>（2）二维三次样条插值</h5><p>Code : <code>pp = csape(&#123;x0, y0&#125;, z0, conds, valconds)</code></p>
<p>​            <code>&lt;ValName&gt; = fnval(pp, &#123;x, y&#125;)</code></p>
<p>对其内容的解释同上</p>
<h5 id="（3）显示相应的三维网格图"><a href="#（3）显示相应的三维网格图" class="headerlink" title="（3）显示相应的三维网格图"></a>（3）显示相应的三维网格图</h5><p>Code : <code>mesh(y,x,z)</code></p>
<p>mesh函数的x为列，y为行，需要将xy反写</p>
<p><a href="# Eg5.3 丘陵曲面最高点">Eg5.3 丘陵曲面最高点</a></p>
<h4 id="2-插值节点为散乱节点"><a href="#2-插值节点为散乱节点" class="headerlink" title="2. 插值节点为散乱节点"></a>2. 插值节点为散乱节点</h4><p>已知n个节点$(x_i,y_i,z_i)\ (i=1,2,\cdots,n)$，求点$(x,y)$处的插值z</p>
<p>Code：<code>&lt;ValName&gt; = griddata(x, y, z, XI, YI)</code></p>
<p>其中x、y、z均为n维向量，指明所给出数据的横坐标、纵坐标和竖坐标 </p>
<p>向量XI、YI是给定的网格点的横坐标和纵坐标</p>
<p>返回值<code>&lt;ValName&gt;</code>为网格(XI, YI)处的函数值，但是<strong>行为YI，列为XI</strong>，进行mesh的时候不需要反转XY</p>
<p>XI与YI应当是方向不同的向量，一行一列（YI需要转置）</p>
<blockquote>
<p>MATLAB中插值时，外插值是不确定的，可以使用混合插值的方法，把不确定的插值换成最近点的插值结果</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">ZI1=griddata(x,y,z,XI,YI&#x27;,<span class="string">&#x27;cubic&#x27;</span>); <span class="comment">%立方插值</span></span><br><span class="line">ZI2=griddata(x,y,z,XI,YI&#x27;,<span class="string">&#x27;nearest&#x27;</span>); <span class="comment">%最近点插值</span></span><br><span class="line">ZI = ZI1; <span class="comment">%</span></span><br><span class="line">ZI(<span class="built_in">isnan</span>(ZI1)) = ZI2(<span class="built_in">isnan</span>(ZI1));</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h2 id="四、实战例题"><a href="#四、实战例题" class="headerlink" title="四、实战例题"></a>四、实战例题</h2><h4 id="Eg5-1-机床加工"><a href="#Eg5-1-机床加工" class="headerlink" title="Eg5.1  机床加工"></a>Eg5.1  机床加工</h4><blockquote>
<p>待加工零件的外形根据工艺要求由一组数据$(x,y)$给出（在平面情况下），用程控铣床加工时每一刀只能沿$x$方向和$y$方向走非常小的一步，这就需要从已知数据得到加工所要求的步长很小的$(x,y)$坐标。<br>Data中给出的$x,y$数据位于机翼断面的下轮廓线上，假设需要得到$x$坐标==每改变0.1时==的$y$坐标。试完成加工所需数据，==画出曲线==，并==求出$x=0$处的曲线斜率和$13\le x\le15$范围内y的最小值==。要求用==分段线性==和==三次样条==两种插值方法计算。</p>
</blockquote>
<p>Data：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center">0</th>
<th style="text-align:center">3</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
<th style="text-align:center">13</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>y</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1.2</td>
<td style="text-align:center">1.7</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">2.1</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">1.8</td>
<td style="text-align:center">1.2</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">1.6</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% Data:</span></span><br><span class="line">x0 = [<span class="number">0</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>];</span><br><span class="line">y0 = [<span class="number">0</span> <span class="number">1.2</span> <span class="number">1.7</span> <span class="number">2.0</span> <span class="number">2.1</span> <span class="number">2.0</span> <span class="number">1.8</span> <span class="number">1.2</span> <span class="number">1.0</span> <span class="number">1.6</span>];</span><br><span class="line">x = [<span class="built_in">min</span>(x0):<span class="number">0.1</span>:<span class="built_in">max</span>(x0)];</span><br><span class="line"><span class="comment">%% Linear</span></span><br><span class="line">y_linear = interp1(x0, y0, x);</span><br><span class="line"><span class="comment">%% Spline</span></span><br><span class="line">y_spline = interp1(x0, y0, x, <span class="string">&#x27;spline&#x27;</span>);</span><br><span class="line">pp_lagrange = csape(x0, y0);</span><br><span class="line">y_spline_lagrange = fnval(pp_lagrange, x);</span><br><span class="line">pp_second = csape(x0, y0, <span class="string">&#x27;second&#x27;</span>);</span><br><span class="line">y_spline_second = fnval(pp_second, x);</span><br><span class="line"><span class="comment">%% DispFigure</span></span><br><span class="line"><span class="comment">% linear</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Position&#x27;</span>, [<span class="number">800</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">800</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y_linear, <span class="string">&#x27;r&#x27;</span>,x0, y0,<span class="string">&#x27;bp&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Interp1-Linear&#x27;</span>)</span><br><span class="line"><span class="comment">% spline</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y_spline, <span class="string">&#x27;r&#x27;</span>,x0, y0,<span class="string">&#x27;bp&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Interp1-Spline&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y_spline_lagrange, <span class="string">&#x27;r&#x27;</span>,x0, y0,<span class="string">&#x27;bp&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Csape-Lagrange&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y_spline_second, <span class="string">&#x27;r&#x27;</span>,x0, y0,<span class="string">&#x27;bp&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Csape-Second&#x27;</span>)</span><br><span class="line"><span class="comment">%% Other Tasks</span></span><br><span class="line"><span class="comment">% 求x=0处的斜率</span></span><br><span class="line">dx = diff(x); <span class="comment">% diff逐差函数</span></span><br><span class="line">dy = diff(y_spline_lagrange);</span><br><span class="line">dy_dx = dy./dx;</span><br><span class="line">dy_dx_0 = dy_dx(<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 求13~15范围内y的最小值</span></span><br><span class="line">ymin = <span class="built_in">min</span>(y_spline_lagrange(<span class="number">131</span>:<span class="number">151</span>)); <span class="comment">% 找出ymin</span></span><br><span class="line">yloc = <span class="built_in">find</span>(y_spline_lagrange == ymin); <span class="comment">% find ymin的index</span></span><br><span class="line">xloc = x(yloc); <span class="comment">% 用ymin的index定位xloc</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;k(0) = &#x27;</span> num2str(dy_dx_0)])</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;xloc: &#x27;</span> num2str(xloc)])</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;ymin: &#x27;</span> num2str(ymin)])</span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k(0) = 0.49716</span><br><span class="line">xloc: 13.8</span><br><span class="line">ymin: 0.98511</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="F:/LeaG/Mathematical Modeling/Program/预测模型/01插值/output/eg51output.jpg" style="zoom: 50%;" /></p>
<h4 id="Eg5-2-求速度曲线的位移"><a href="#Eg5-2-求速度曲线的位移" class="headerlink" title="Eg5.2 求速度曲线的位移"></a>Eg5.2 求速度曲线的位移</h4><blockquote>
<p>已知速度曲线$v(t)$上的四个数据点如下表，用三次样条插值求位移</p>
<script type="math/tex; mode=display">
S = \int_{0.15}^{0.18}v(t)\,{\rm d}t</script></blockquote>
<p>Data:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$t$</th>
<th>0.15</th>
<th>0.16</th>
<th>0.17</th>
<th>0.18</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>$v(t)$</strong></td>
<td>3.5</td>
<td>1.5</td>
<td>2.5</td>
<td>2.8</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% DataLoad</span></span><br><span class="line">t0 = <span class="number">0.15</span>:<span class="number">0.01</span>:<span class="number">0.18</span>;</span><br><span class="line">v0 = [<span class="number">3.5</span>,<span class="number">1.5</span>,<span class="number">2.5</span>,<span class="number">2.8</span>];</span><br><span class="line"><span class="comment">%% Spline</span></span><br><span class="line">pp = csape(t0, v0); <span class="comment">% 使用默认边界条件Lagrange</span></span><br><span class="line">format long g <span class="comment">% 设置长小数格式</span></span><br><span class="line">xs = pp.coefs <span class="comment">% 显示每个区间上三次多项式的系数</span></span><br><span class="line">s = integral(@(t)ppval(pp,t),<span class="number">0.15</span>,<span class="number">0.18</span>) <span class="comment">% 求数值积分</span></span><br><span class="line">    <span class="comment">% @(t) 为匿名函数的书写格式 </span></span><br><span class="line">    <span class="comment">% integral(fx,xmin,ymin) 求数值积分</span></span><br><span class="line">        <span class="comment">% 使用全局自适应积分和默认误差容限在 xmin 至 xmax 间以数值形式为函数</span></span><br><span class="line">    <span class="comment">% ppval(pp,xq)计算分段多项式:查询点 xq 处计算分段多项式 pp</span></span><br><span class="line">format <span class="comment">% 恢复短小数小时格式</span></span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xs =     -616666.666666667                     33500         -473.333333333334                       3.5</span><br><span class="line">         -616666.666666667                     15000          11.6666666666671                       1.5</span><br><span class="line">         -616666.666666668         -3499.99999999999          126.666666666667                       2.5</span><br><span class="line">s =0.068625</span><br></pre></td></tr></table></figure>
<h4 id="Eg5-3-丘陵曲面最高点"><a href="#Eg5-3-丘陵曲面最高点" class="headerlink" title="Eg5.3 丘陵曲面最高点"></a>Eg5.3 丘陵曲面最高点</h4><blockquote>
<p>在一丘陵地带测量高程，==x和y方向每隔100米==测一个点，得高程如表，试插值一==曲面==，确定合适的模型，并由此找出==最高点和该点的高程==</p>
</blockquote>
<p>Data:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">y\x</th>
<th style="text-align:center">100</th>
<th style="text-align:center">200</th>
<th style="text-align:center">300</th>
<th style="text-align:center">400</th>
<th style="text-align:center">500</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>100</strong></td>
<td style="text-align:center">636</td>
<td style="text-align:center">697</td>
<td style="text-align:center">624</td>
<td style="text-align:center">478</td>
<td style="text-align:center">450</td>
</tr>
<tr>
<td style="text-align:center"><strong>200</strong></td>
<td style="text-align:center">698</td>
<td style="text-align:center">712</td>
<td style="text-align:center">630</td>
<td style="text-align:center">478</td>
<td style="text-align:center">420</td>
</tr>
<tr>
<td style="text-align:center"><strong>300</strong></td>
<td style="text-align:center">680</td>
<td style="text-align:center">674</td>
<td style="text-align:center">598</td>
<td style="text-align:center">412</td>
<td style="text-align:center">400</td>
</tr>
<tr>
<td style="text-align:center"><strong>400</strong></td>
<td style="text-align:center">662</td>
<td style="text-align:center">626</td>
<td style="text-align:center">552</td>
<td style="text-align:center">334</td>
<td style="text-align:center">310</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意此处直接列写矩阵，则xy与正常的对应相反</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% DataLoad</span></span><br><span class="line">x0 = <span class="number">100</span>:<span class="number">100</span>:<span class="number">500</span>;</span><br><span class="line">y0 = <span class="number">100</span>:<span class="number">100</span>:<span class="number">400</span>;</span><br><span class="line">z0 = [<span class="number">636</span> <span class="number">697</span> <span class="number">624</span> <span class="number">478</span> <span class="number">450</span></span><br><span class="line">      <span class="number">698</span> <span class="number">712</span> <span class="number">630</span> <span class="number">478</span> <span class="number">420</span></span><br><span class="line">      <span class="number">680</span> <span class="number">674</span> <span class="number">598</span> <span class="number">412</span> <span class="number">400</span></span><br><span class="line">      <span class="number">662</span> <span class="number">626</span> <span class="number">552</span> <span class="number">334</span> <span class="number">310</span>]&#x27;;</span><br><span class="line"><span class="comment">% 此处的z0两坐标方向交叉，需要转置</span></span><br><span class="line">step = <span class="number">5</span>;</span><br><span class="line">x = <span class="number">100</span>:step:<span class="number">500</span>;</span><br><span class="line">y = <span class="number">100</span>:step:<span class="number">400</span>;</span><br><span class="line"><span class="comment">%% interp</span></span><br><span class="line"><span class="comment">% interp2要求矩阵和向量交叉对应，且y为列向量</span></span><br><span class="line">z1 = interp2(x0,y0,z0&#x27;,x,y&#x27;);</span><br><span class="line">z1 = z1&#x27;; <span class="comment">% 转置z1回正常的对应</span></span><br><span class="line"><span class="comment">% csape正常进行</span></span><br><span class="line">pp = csape(&#123;x0,y0&#125;,z0);</span><br><span class="line">z2 = fnval(pp,&#123;x,y&#125;);</span><br><span class="line"><span class="comment">%% DispMesh</span></span><br><span class="line"><span class="comment">% mesh函数的x为列，y为行，需要将xy反写</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Position&#x27;</span>,[<span class="number">500</span>,<span class="number">300</span>,<span class="number">1000</span>,<span class="number">600</span>])</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">mesh(y,x,z1) </span><br><span class="line">title(<span class="string">&#x27;Interp1-Linear&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">mesh(y,x,z2)</span><br><span class="line">title(<span class="string">&#x27;Spline&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">20</span>)</span><br><span class="line"><span class="comment">%% MAXValue</span></span><br><span class="line"><span class="comment">% interp-Linear</span></span><br><span class="line">[maxls1,xlocls1] = <span class="built_in">max</span>(z1); <span class="comment">% 按列取max</span></span><br><span class="line">[vmax1,yloc1] = <span class="built_in">max</span>(maxls1); <span class="comment">% 按行取max</span></span><br><span class="line">info1 = [<span class="string">&quot;interp-Linear&quot;</span>,x(xlocls1(yloc1)),y(yloc1),vmax1]; </span><br><span class="line">    <span class="comment">% 行loc索引列ls的loc,并用loc索引相应的x,y的值</span></span><br><span class="line"><span class="comment">% Spline</span></span><br><span class="line">[maxls2,xlocls2] = <span class="built_in">max</span>(z2);</span><br><span class="line">[vmax2,yloc2] = <span class="built_in">max</span>(maxls2);</span><br><span class="line">info2 = [<span class="string">&quot;Spline&quot;</span>,x(xlocls2(yloc2)),y(yloc2),vmax2]; </span><br><span class="line">info = [info1;info2];</span><br><span class="line"><span class="comment">% 更好的位置索引方法</span></span><br><span class="line">[<span class="built_in">i</span>,<span class="built_in">j</span>]=<span class="built_in">find</span>(z2==<span class="built_in">max</span>(<span class="built_in">max</span>(z2)));  <span class="comment">%找最高点的地址</span></span><br><span class="line">xm=x(<span class="built_in">i</span>),ym=y(<span class="built_in">j</span>),zm=z2(<span class="built_in">i</span>,<span class="built_in">j</span>);  <span class="comment">%求最高点的坐标 </span></span><br><span class="line">[zm,xm,ym]</span><br><span class="line"><span class="comment">%% DispMAX</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;Step:&#x27;</span> num2str(step)])</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;Type:&#x27;</span> num2str(info(<span class="built_in">i</span>,<span class="number">1</span>))]) </span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;max = &#x27;</span> num2str(info(<span class="built_in">i</span>,<span class="number">4</span>)) ...</span><br><span class="line">        <span class="string">&#x27;    x = &#x27;</span> num2str(info(<span class="built_in">i</span>,<span class="number">2</span>)) ...</span><br><span class="line">        <span class="string">&#x27;    y = &#x27;</span> num2str(info(<span class="built_in">i</span>,<span class="number">3</span>))])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  720.7217  165.0000  175.0000</span><br><span class="line">Step:5</span><br><span class="line">Type:interp-Linear</span><br><span class="line">max = 712    x = 200    y = 200</span><br><span class="line">Type:Spline</span><br><span class="line">max = 720.7217    x = 165    y = 175</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/XLY23333/picture01/img01/eg53output.jpg" style="zoom: 50%;" /></p>
<h4 id="Eg5-4-海底图像"><a href="#Eg5-4-海底图像" class="headerlink" title="Eg5.4 海底图像"></a>Eg5.4 海底图像</h4><blockquote>
<p>在某海域测得一些点（x,y）处的水深z由表5.4给出，在适当的矩形区域内画出海底曲面的图形。</p>
</blockquote>
<p>Data：</p>
<blockquote>
<p>x=[129,140,103.5,88,185.5,195,105,157.5,107.5,77,81,162,162,117.5];</p>
<p>y=[7.5,141.5,23,147,22.5,137.5,85.5,-6.5,-81,3,56.5,-66.5,84,-33.5];</p>
<p>z=-[4,8,6,8,6,8,8,9,9,8,8,9,4,9];</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% DataLoad</span></span><br><span class="line">x=[<span class="number">129</span>,<span class="number">140</span>,<span class="number">103.5</span>,<span class="number">88</span>,<span class="number">185.5</span>,<span class="number">195</span>,<span class="number">105</span>,<span class="number">157.5</span>,<span class="number">107.5</span>,<span class="number">77</span>,<span class="number">81</span>,<span class="number">162</span>,<span class="number">162</span>,<span class="number">117.5</span>];</span><br><span class="line">y=[<span class="number">7.5</span>,<span class="number">141.5</span>,<span class="number">23</span>,<span class="number">147</span>,<span class="number">22.5</span>,<span class="number">137.5</span>,<span class="number">85.5</span>,<span class="number">-6.5</span>,<span class="number">-81</span>,<span class="number">3</span>,<span class="number">56.5</span>,<span class="number">-66.5</span>,<span class="number">84</span>,<span class="number">-33.5</span>];</span><br><span class="line">z=-[<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>];</span><br><span class="line">step = <span class="number">1</span>;</span><br><span class="line">XI = <span class="built_in">min</span>(x):step:<span class="built_in">max</span>(x)</span><br><span class="line">YI = <span class="built_in">min</span>(y):step:<span class="built_in">max</span>(y)</span><br><span class="line"><span class="comment">%% grid</span></span><br><span class="line">ZI1=griddata(x,y,z,XI,YI&#x27;,<span class="string">&#x27;cubic&#x27;</span>); <span class="comment">%立方插值</span></span><br><span class="line">ZI2=griddata(x,y,z,XI,YI&#x27;,<span class="string">&#x27;nearest&#x27;</span>); <span class="comment">%最近点插值</span></span><br><span class="line">ZI = ZI1; <span class="comment">% 设置ZI初始值为ZI1</span></span><br><span class="line">ZI(<span class="built_in">isnan</span>(ZI1)) = ZI2(<span class="built_in">isnan</span>(ZI1)); <span class="comment">% 用ZI2填充ZI1外插值(为NaN)的部分</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">mesh(XI,YI,ZI)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,<span class="string">&#x27;or&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="F:\Blog\BOX\output\eg54output.jpg" style="zoom: 80%;" /></p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>智能医疗导诊系统官网</title>
    <url>/Software/MedV2/</url>
    <content><![CDATA[<h1 id="智能医疗导诊系统"><a href="#智能医疗导诊系统" class="headerlink" title="智能医疗导诊系统"></a>智能医疗导诊系统</h1><p><img src="https://cdn.jsdelivr.net/gh/XLY23333/picture01/img01/Grp1.png" style="zoom: 25%;" /></p>
<hr>
<h3 id="最新版下载链接"><a href="#最新版下载链接" class="headerlink" title="最新版下载链接"></a>最新版下载链接</h3><p>123网盘不限速下载连接：<a href="https://www.123pan.com/s/kopSVv-9oc4H.html">点击此处开始下载</a></p>
<p>百度网盘下载连接：<a href="https://pan.baidu.com/s/1zZUerTOkBZ1kl_1mGRsSLA?pwd=gyh1">点击此处开始下载</a></p>
<hr>
<h3 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h3><p>欢迎使用智能医疗导诊系统 !</p>
<p>本系统致力于通过当今社会的各项AI技术，<br>以LLMs为主建立一个智能化的医疗预导诊系统，<br>以求在快速化发展的时代建立一个更快的医疗预服务体验。</p>
<p>智能医疗导诊系统基于先进的人工智能技术，旨在提升医疗服务效能并优化患者的就医经历。此系统结合了大语言模型(LLMs)、语音转文本(ASR)、光学字符识别(OCR)技术，通过对开源大语言模型的定向化微调，实现症状精确识别、智能疾病诊断和科室推荐，并模拟输出相应的初步导诊报告。</p>
<h3 id="系统功能"><a href="#系统功能" class="headerlink" title="系统功能"></a>系统功能</h3><ul>
<li><strong>基于微调<em>LLMs</em>的智能医疗诊断</strong>：通过调用租赁服务器上的微调MED大语言模型，精确的为您判断相应的医学专业病症名词和推荐的诊疗科室。</li>
<li><strong><em>OCR</em>病历识别</strong>：用户可使用扫描其他来源的病例或手写材料，通过光学字符识别转化为导诊文本信息。</li>
<li><strong>二维码导诊记录</strong>：支持通过扫描二维码快速导入患者既往的诊疗记录。</li>
<li><strong><em>ASR</em>语音输入</strong>：用户可通过自然语言口述其病情，系统即时将语音转换为结构化医疗信息。</li>
<li><strong>导诊报告自动生成</strong>：系统能够自动生成详尽的导诊报告，并为其生成可分享的导诊二维码，简化医疗信息传递与查询过程。</li>
<li><strong>模拟数据库可预约科室</strong>：通过模拟生成的数据库，并结合当前导诊的真实时间，输出相应时间段可以预约的科室和医生。</li>
</ul>
<h3 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h3><p>智能医疗导诊系统提供易于安装的执行文件，用户可以通过以下步骤在个人电脑上进行安装：</p>
<ol>
<li>从 <a href="https://www.XLY23333.xyz/Software/MedV2/">官方网站</a> 下载最新的压缩包。</li>
<li>解压文件包，双击包内的<code>智能医疗导诊系统.exe</code>文件，即可使用。</li>
</ol>
<h3 id="快速开始指南"><a href="#快速开始指南" class="headerlink" title="快速开始指南"></a>快速开始指南</h3><ol>
<li><strong>启动系统</strong>：打开应用程序，通过 <a href="https://www.XLY23333.xyz/Software/MedV2/">官方网站</a> 的测试账密进入主界面。</li>
<li><strong>数据输入</strong>：<ul>
<li>直接在输入框中输入病症内容 </li>
<li>点击<kbd>CAM</kbd>，进入CAM界面<ul>
<li>选择<kbd>OCR 病历识别</kbd>进行文字光学字符识别 或<kbd>QR Code 二维码识别</kbd>进行二维码识别</li>
<li>OCR将自动使用模糊推理，并导入病症框</li>
<li>二维码加载后自动显示上次的导诊信息并显示可约科室</li>
</ul>
</li>
<li>点击<kbd>ASR</kbd>，进入ASR界面<ul>
<li>使用<kbd>Start</kbd>开始录音</li>
<li>使用<kbd>END</kbd>结束录音并进行模糊推理</li>
<li>使用<kbd>导入数据</kbd>最终数据导入病症框</li>
</ul>
</li>
</ul>
</li>
<li><strong>查看诊断结果</strong>：提交信息后，系统将显示初步诊断结果和推荐科室，并通过当前时间返回模拟数据库当中的模拟可约诊室。</li>
<li><strong>导诊报告</strong>：用户可以点击<kbd>Print</kbd>模拟打印导诊报告和二维码。</li>
<li><strong>清除记录</strong>：点击<kbd>clear</kbd>可以清除已有的记录</li>
<li><strong>设置</strong>：通过右下角的<kbd>Setting</kbd>按键</li>
</ol>
<h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p>若在使用过程中遇到任何技术问题，或需要帮助、加入开发团队、授权开源代码，可以通过以下方式联系我们的技术支持团队：</p>
<ul>
<li><strong>电子邮箱</strong>：XLY23333@126.com</li>
<li><strong>联系电话</strong>：176-1565-7737</li>
</ul>
<h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><h4 id="V1-Demo"><a href="#V1-Demo" class="headerlink" title="V1 Demo"></a>V1 Demo</h4><blockquote>
<p>Update date: 2024-03-09</p>
</blockquote>
<ul>
<li>初步创建了主窗口界面</li>
<li>通过API调用实现了最基本的导诊逻辑功能<ul>
<li>软件使用的API为测试用，有一定的限额，Key的购买将会在 <a href="https://www.XLY23333.xyz/Software/MedV2/">官方网站</a> 放入第三方友情链接</li>
</ul>
</li>
<li>初步建立了底层逻辑结构</li>
</ul>
<h4 id="V2-Demo"><a href="#V2-Demo" class="headerlink" title="V2 Demo"></a>V2 Demo</h4><blockquote>
<p>Update date: 2024-03-10</p>
</blockquote>
<ul>
<li>更新UI界面，增设Camera和ASR界面</li>
<li>接入硬件Camera处理和PyAudio音频录制接口</li>
<li>随进度更新底层逻辑结构</li>
</ul>
<h4 id="V3-Demo"><a href="#V3-Demo" class="headerlink" title="V3 Demo"></a>V3 Demo</h4><blockquote>
<p>Update date: 2024-03-24</p>
</blockquote>
<ul>
<li>更新UI界面，新增设置(Setting)页面</li>
<li>随进度更新底层逻辑结构</li>
</ul>
<h4 id="V1-BETA"><a href="#V1-BETA" class="headerlink" title="V1 BETA"></a>V1 BETA</h4><blockquote>
<p>Update date: 2024-04-19</p>
</blockquote>
<ul>
<li><em>第一个发布版本</em></li>
<li>接入微调大语言模型MED</li>
<li>建立服务器备用API通道</li>
<li>随进度更新底层逻辑结构</li>
</ul>
<h4 id="V2-Latest"><a href="#V2-Latest" class="headerlink" title="V2 [Latest]"></a>V2 <u>[Latest]</u></h4><blockquote>
<p>Update date: 2024-04-25</p>
</blockquote>
<ul>
<li>更新全新的UI界面</li>
<li>重新调整底层代码结构，建立Python功能包<em>Medpkg</em>，规范化源码</li>
<li>尝试接入本地音频解码器<ul>
<li>音频解码器可能因为安装不成功而提示转码错误，可通过手动下载解码器并设置环境变量后使用</li>
</ul>
</li>
</ul>
<h3 id="第三方API购买"><a href="#第三方API购买" class="headerlink" title="第三方API购买"></a>第三方API购买</h3><p>软件提供了一个有限的API-KEY用于测试，如需长期使用可以购买第三方API-KEY并通过调整Setting使用</p>
<p>链接：<a href="https://buyca.top/">点击进入</a></p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>感谢所有参与项目开发和测试的团队成员，感谢该项目建立过程当中提供帮助的老师和同学，以及为项目提供数据支持和反馈的所有用户和合作伙伴。</p>
<hr>
<p><center><time>2024/04/25</time> <team>MEDGS-AI Team</team></center>&lt;/u&gt;</p>
]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式快速入门</title>
    <url>/Coding/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="正则表达式快速入门"><a href="#正则表达式快速入门" class="headerlink" title="正则表达式快速入门"></a>正则表达式快速入门</h1><blockquote>
<p>学习源视频：<a href="https://www.bilibili.com/video/BV1da4y1p7iZ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=1437b1798845fbcba4cf09d5a889e546">奇乐编程学院-[Bilibili]</a><br>Note：<a href="https://www.xly23333.xyz">XLY23333-[Blog]</a><br>NoteBy：Typora[Markdown] + $\rm\LaTeX$ Themes by:<a href="https://github.com/Keldos-Li/typora-latex-theme">Keldos-Li-[Github]</a></p>
</blockquote>
<hr>
<h2 id="限定符-Quantifiers"><a href="#限定符-Quantifiers" class="headerlink" title="限定符 [Quantifiers]"></a>限定符 [Quantifiers]</h2><h3 id="单个字符的限定"><a href="#单个字符的限定" class="headerlink" title="单个字符的限定"></a>单个字符的限定</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$\quad$限定符$\quad$</th>
<th style="text-align:left">Description</th>
<th style="text-align:center">$\quad$Eg$\quad$</th>
<th style="text-align:left">Egmeans</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:left">?前字符出现<strong>0</strong>或1次(?前字符<strong>可有可无</strong>)</td>
<td style="text-align:center"><code>used?</code></td>
<td style="text-align:left">查找所有use和used</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:left">*前字符出现<strong>0</strong>或<strong>多次</strong>(*前字符<strong>可有多次可无</strong>)</td>
<td style="text-align:center"><code>ab?c</code></td>
<td style="text-align:left">可查找abc,ac,abbbc等</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:left">+前字符出现<strong>1</strong>或<strong>多次</strong>(+前字符<strong>可有一次或多次</strong>)</td>
<td style="text-align:center"><code>ab+c</code></td>
<td style="text-align:left">可查找abc,abbbc等</td>
</tr>
<tr>
<td style="text-align:center"><code>&#123;&lt;num&gt;&#125;</code></td>
<td style="text-align:left">指定{…}前字符<strong>出现次数</strong>为<code>&lt;num&gt;</code>次</td>
<td style="text-align:center"><code>ab&#123;2&#125;c</code></td>
<td style="text-align:left">可查找abbc等</td>
</tr>
<tr>
<td style="text-align:center"><code>&#123;&lt;min&gt;,&lt;max&gt;&#125;</code></td>
<td style="text-align:left">指定{…}前字符<strong>出现次数范围</strong>,可以<strong>缺省<code>max</code>值</strong></td>
<td style="text-align:center"><code>ab&#123;3,&#125;c</code></td>
<td style="text-align:left">可查找abbbbc,abbbc等</td>
</tr>
</tbody>
</table>
</div>
<h3 id="多个字符的限定"><a href="#多个字符的限定" class="headerlink" title="多个字符的限定"></a>多个字符的限定</h3><p>可以使用<code>()</code>将多个字符括起,随后操作同上方的单个字符限定</p>
<p><strong><em>Eg:</em></strong><code>a(bc)&#123;1,2&#125;d</code>可以搜索 ‘abcd’ 和 ‘abcbcd’</p>
<h2 id="或运算符-OR-Operation"><a href="#或运算符-OR-Operation" class="headerlink" title="或运算符 [OR Operation]"></a>或运算符 [OR Operation]</h2><p>同时匹配所有出现的情况,只要有就匹配</p>
<p>Code: <code>(&lt;word1&gt;|&lt;words2&gt;|&lt;words3&gt;|...)</code></p>
<p>使用<code>()</code>将或运算内容括起,用<code>|</code>将内容隔开,则括号中所有的内容执行或运算,均可以被查找到</p>
<p><strong><em>Eg:</em></strong><code>a (cat|dog)</code>可以搜索 ‘a cat’ 和 ‘a dog’ [注意:a后方的空格也算作检索内容]</p>
<h2 id="字符类-Character-Classes"><a href="#字符类-Character-Classes" class="headerlink" title="字符类 [Character Classes]"></a>字符类 [Character Classes]</h2><p>匹配由指定字符所构成的内容,无需完全匹配,拥有其中之一即可</p>
<p>Code: <code>[&lt;char1&gt;&lt;char2&gt;...]</code>并列查找由他们构成的内容</p>
<p>​           <code>[&lt;char1&gt;-&lt;char2&gt;]</code> 定义查找范围<code>&lt;char1&gt;-&lt;char2&gt;</code></p>
<p>​            <code>[^&lt;char&gt;]</code>查找除了方括号的其他内容</p>
<p><strong><em>Eg</em></strong>: <code>[^\nA-Za-z]+</code> 查找所有的数字(非换行符,非大写字母,非小写字母)</p>
<h2 id="元字符-Meta-Characters"><a href="#元字符-Meta-Characters" class="headerlink" title="元字符 [Meta-Characters]"></a>元字符 [Meta-Characters]</h2><div class="table-container">
<table>
<thead>
<tr>
<th>$\quad$Meta-Char$\quad$</th>
<th style="text-align:left">$\quad$Description$\quad$</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\d</code></td>
<td style="text-align:left"><strong>数字</strong>字符</td>
</tr>
<tr>
<td><code>\w</code></td>
<td style="text-align:left"><strong>单词</strong>字符(英文字母+数字+下划线)</td>
</tr>
<tr>
<td><code>\s</code></td>
<td style="text-align:left"><strong>空白</strong>符(TAB+换行符)</td>
</tr>
<tr>
<td><code>\D</code></td>
<td style="text-align:left"><strong>非数字</strong>字符</td>
</tr>
<tr>
<td><code>\W</code></td>
<td style="text-align:left"><strong>非单词</strong>字符</td>
</tr>
<tr>
<td><code>\S</code></td>
<td style="text-align:left"><strong>非空白</strong>符</td>
</tr>
<tr>
<td><code>.</code></td>
<td style="text-align:left"><strong>任意</strong>字符(<strong>不包含换行符</strong>)</td>
</tr>
<tr>
<td><code>^&lt;char&gt;</code></td>
<td style="text-align:left">匹配<strong>行首</strong>的<code>&lt;char&gt;</code></td>
</tr>
<tr>
<td><code>&lt;char&gt;$</code></td>
<td style="text-align:left">匹配<strong>行尾</strong>的<code>&lt;char&gt;</code></td>
</tr>
<tr>
<td><code>\b&lt;chars&gt;\b</code></td>
<td style="text-align:left">规定该位置为<strong>单词边界</strong>,<strong>防止对超量的截取匹配</strong></td>
</tr>
<tr>
<td><code>\B&lt;chars&gt;\B</code></td>
<td style="text-align:left">规定该位置为<strong>非单词边界</strong></td>
</tr>
</tbody>
</table>
</div>
<p>如果要使用<code>.</code>则可以通过转义后的<code>\.</code>进行匹配</p>
<h2 id="贪婪与懒惰匹配-Greedy-vs-Lazy-Match"><a href="#贪婪与懒惰匹配-Greedy-vs-Lazy-Match" class="headerlink" title="贪婪与懒惰匹配 [Greedy vs Lazy Match]"></a>贪婪与懒惰匹配 [Greedy vs Lazy Match]</h2><p>假设对一下的html内容,需要匹配<code>&lt;center&gt;</code>和<code>&lt;/center&gt;&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span>TEXT<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果使用<code>&lt;.+&gt;</code>,由于<code>&gt;</code>和<code>&lt;</code>同样属于<code>.</code>,所以将匹配整行的全部代码</p>
<p>可以将代码更改为<code>&lt;.+?&gt;</code>由贪婪模式匹配为<strong>懒惰匹配</strong>,从而精确匹配</p>
<p>也可以在不切换模式的情况下,改用<code>&lt;[^&lt;&gt;]+&gt;</code>去掉可能出现的<code>&gt;</code>和<code>&lt;</code>查找</p>
<h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><h3 id="匹配16进制的颜色值"><a href="#匹配16进制的颜色值" class="headerlink" title="匹配16进制的颜色值"></a>匹配16进制的颜色值</h3><p>颜色值#开头,为十六进制(由0~9,a~f,A~F构成),共6位字符</p>
<p><img src="https://cdn.jsdelivr.net/gh/XLY23333/picture01/img01/eg1.png" style="zoom:40%"></p>
<h3 id="IPv4-地址匹配"><a href="#IPv4-地址匹配" class="headerlink" title="IPv4 地址匹配"></a>IPv4 地址匹配</h3><p>IPv4由四段数字组成,中间由符号.隔开,且数字的范围为0~255</p>
<p><img src="https://cdn.jsdelivr.net/gh/XLY23333/picture01/img01/eg2.png" style="zoom:50%"></p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
        <tag>Search</tag>
      </tags>
  </entry>
  <entry>
    <title>非公开链接传送Gather</title>
    <url>/URL/%E9%9D%9E%E5%85%AC%E5%BC%80%E9%93%BE%E6%8E%A5%E4%BC%A0%E9%80%81Gather/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="25d905d0277335b5e6b872590b9538cb6395304c174faf23f99d54e188c89d7e">2d0cc57e0ca0d95b94a86d2858934c236a929973a1341844210faac8bd7bf73c011b5ad40b23a60d4629d561c061a8d90c6cd17f948a014811b5358f1cd13cc69ec60ed77ef384685c68c58676b9cd84f19ce67f2ef07f32db57fa395db46a039032aecffdeeeeb6b0badf82d72e3d737bd5efa29396e702fcca920633f20510fab60595f368a14b37fd1be161531a31f35387da9262ed7cbaab5b2f8959ecefbe8abf6f55ab498fead13e854fa4fb65d7a3b4f599c909b799fe0901bbecf8bc82e3d787db5a6aa7bf151a32681f13d1fc878424cc39f1fe1a80f4b3ae96d748828d19c5cdda330f819c425431e1ebc40622ab28f4c824d958869d6c587493ca64fa823bdae7024bf8ad225cddda1994df387b57887d7b6a9200378e57f633733f35a6559e30f960e1f694fcedd1e99a9b19d64843194331c2455c547e291ba77953cee1ca6a9c68ba45b2a01a755e2ae9604a30c33a8b9602f027f15df2ca23382acf95af1d72f6e5ec6943f59d838b75d79ed47b2ced66fe4ad2ffad828804155c57e2289eb8fa054808d9a0bebb239c7bee3d241e677010093696f392af14c88d1cdba9db67bea10dd2df1bdfb589ce954cc6c6ce736d07eb84146b03c4588ac3520e637cf440005b1fe72f67ed8e1ed9a87d258e842c5ab01123b64ff4383344a580e5a28529b2c226e6fce558eecaf35742ce6b382ffd7a73bf8c39be9cde1a5b144eb36bbb2ceea4ca83346fdb8898a6b0d3e8e031c148c61f56412550792e5a3b6034abfb960e44a98b0811c96fb3e3d117e48f989e741d3bd5ac4be19bb913b70f42f57e3d29f4e7db85a58761684531d4ca396b48da99ab912da7aea2c5d4ed486c5ecdc96f2df53207e34e727bc79cc840713197c3ecb6e4073ec2e1956793edc4ccea5669db6067dc5ac37d46e2aa97719052f916eeeecf8f6ed61a5a80c9cbc60835c45cc7ee66f3c23570330246cf578c3e4653157a459265e3f485e41887ad192aa12cd790ce4d61427315b47fdfdbf8d02df8dc4675f347b60126eabb25e6cdd99e821b12b34876485e7f82e8cf32e545458c65a0d9217f1fec62763d0ec2407f4e64b27f10870cb766f135b89e4a3701ef746bf8af7730a1d01c176d5ec2b84c925ef9bbc6afc195dcdf9916d6cca33d87f88108d230a8773649e8b7e710746a7ddc6d954cac4dba6903a4fdf559c4583d46dcef6c732b9384a740ec53a149b104169fa01ea7a0df7730138e33f67241cb93462ee71a27cda49ed8afa9f8f989071d7e19d872e25a1ad387ab2d5ff8651334d680ed8711b81b8869ce373cedea618606f2659b262a71e7b11afefbfd9c4e3a16b9290326b9edafa737d1b59b2b0dfd523a83c01f315eb7c36a669c21b103a78395c4da83d44a77001afdc26bb8d7be64639c66aa1e19335fdf36348804a6c95478e004c39410d8d0033e934640f31d862c4b652b321654b71225928ffe11ae4d23274bed6188f27ef2a13ea7cc9b863505c1adcac1238f9acf8f1bbae3a9187c207428f11bb38fac630f359a9f8ce743aabfa5da402c5fa010e3802dce4d0a0ca89126a0f88ebd38f438aa28ce317554bddd3f2271c6482d8d656bdaa80f52381f0544a6c9faff9be20c405f7956afab44c9666ebd14876b04b67c592255d8e3db8f1c37fdc377bb528a3f5814cd4a11068660421ef6ff67b40fd3d46ed97c308601dc2a46c41cef8768d669127e256fcf59e3a338910662e946855fd1b0fdaf7a297e84c561431e57f609217f1bb16302d288d451b1a15c39f396d38d874fc9513413fd79b389ae94fcdb5673f9a439dce8315ad703aa5a28d86b8df345755d98e70d76d4a2961ee988240918d765286274658b6010ee9af2d799de0e5ab73ad491a8751d286994392c144de83d5c6b5c404cb73cd386daa57118520c58b09605eeb6ad3f451d75f33d71de7097b4c7d09bb2d9ac41873722a2ac3136236fa0d8c638679a9808e17e287611a87677e56bb3ff5083a70b12c647c88401947c6e4382796cf581ec57ea567b6636a84e22f448d03ce7fd36a7b8835ad5cf8236f0fcf2e0b881483cc530b0f78bce144c95a1a239933563b3c76005ce717c767d2ac6b3636457b4c5ee798ac410856558cdd609a94c822f1bbdf75b416a54965a0b58327de97f2c2aede0de4c9cf00ceccfc37a55aad3c55a48455fe65e38eac8a2d0d50b33592c649c16801bfcf4660b7dd4c94a491131ff63080ec4a2dbe7017f9dd7de21cadde8abd2f4c6ca195a63f2cab61d1ef170d87f5d8c1ed73c09a571ca8906a76552b088402c3dfeebd0e48abca3b395b8f95b55f6e34ed670a8b10ff71599fe47714710dd21a74b55b4525f042d936f04fec459b75b14a97779d6015a4d64f656339eafcee70543f6c894d7da6cdf0e41e3b0ff5156412a1c3ddf04f4b1449fd33f0db8d5ef65e5fbc4bfa07534669f28457f5a2c0e94013394b940ce05a2f089e05f1edee2e759ee1e74790fb47ee28f197271958804d6586ac8c85bb7065792fd68a4d517f579b2a148eaf0f88d9fc59876eb8e3825583ac7892afd430df04238a58c1143c60bcae3e2ca294452737edc10ae54400051d43b268bfc561d0ea1bb37b90ba7ebfea0e2cf6b50d914aa1ad84cc3446886c349a9bc8f3ae601c44d09b00641db3853d754d88f62db1ae06266451c9272e92177ea01d4b224d766b9935ca9c5a2dfe73a1328e6da5e6d249795fcd5072672cc15a5e87317462ae96506af42b4f9a90b06c781e982e403fa14a4ba4c989ebd9c4c0d5176a150d63fbeffd6bde361b346a74fd6c6d2bacff7f637f991fec4240fe950224c1ae0492302eba1d9a7a101a78180ff54201b60719af63f7f14b33aab584aae34c6faa3144c1049ee34a3a77010c892e81a60fd8ab197278d172c410236be02c16569b7133effe6fe69944c35a77ced061a6e91aeeaf64879b7b693da579d55da4474c8eb15f8d67e49635c4969e8500fe6f96e91252f7a0076eb8291fcac9ea6379410e0f94c358d7d73617d2febec22409e22e4facc9ad3c9ed3a347cdf07996d4f628fbbe1891d1e491cbf868bb39cfc77c666d819678ae737c6b3eb1abe2f109d688ba86a4f5b4d9715035bb4bad5af84b173d9b387a39a1d9f4524f31a0df14cf69064ea72ed26ae2768c13add054001d159aacccbeb2d46e1f26a092ffbe4a07e049c7b9c42d56b2d3cbcfcfdc4d9c9b7fdb675304760f2e05abb9dff10c318c38f1dc94758d5bf7a24a80c9bd446f0aa5894f68a9972e8b543af4b545baf0b54b1ba4130fc7fa8839b93656135f9ec6013c9</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This blog post requires a password to view.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>URL</category>
      </categories>
      <tags>
        <tag>链接</tag>
        <tag>工具</tag>
        <tag>软体</tag>
      </tags>
  </entry>
  <entry>
    <title>数模M06-回归</title>
    <url>/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B/M06-%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h1 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h1><blockquote>
<p>用于在难以选择建模模型时，分析自变量和因变量的关系</p>
</blockquote>
<h2 id="一、多元线性回归"><a href="#一、多元线性回归" class="headerlink" title="一、多元线性回归"></a>一、多元线性回归</h2><h3 id="（一）原理理论"><a href="#（一）原理理论" class="headerlink" title="（一）原理理论"></a>（一）原理理论</h3><h4 id="1-模型"><a href="#1-模型" class="headerlink" title="1. 模型"></a>1. 模型</h4><p>多元线性回归分析的模型为</p>
<script type="math/tex; mode=display">
\begin{cases}
y=\beta_0+\beta_1x_1+\cdots+\beta_mx_m+\varepsilon\\
\varepsilon \sim N(0,\sigma^2)
\end{cases}</script><p>其中$\beta_0,\beta_1,\cdots,\beta_m,\sigma^2$都是与$x_1,x_2,\cdots,x_m$无关的位置参数，其中$\beta_0,\beta_1,\cdots,\beta_m,$称为回归系数</p>
<p>现得到$n$个独立观测数据$[b<em>i,a{\small i1},\cdots,a</em>{i2}]$，其中$b<em>i$为$y$的观察值，$a{\small i1},\cdots,a</em>{im}$分别是$x_1,x_2,\cdots,x_m$的观测值，$i=1,\cdots,n\quad,n&gt;m$，即</p>
<script type="math/tex; mode=display">
\begin{cases}
b_i=\beta_0+\beta_1a_{i1}+\cdots+\beta_ma_{im}+\varepsilon_i\\
\varepsilon_i \sim N(0,\sigma^2)\quad,i=1,\cdots,n
\end{cases}</script><p>记</p>
<script type="math/tex; mode=display">
X = 
\begin{bmatrix}
1 & a_{11} & \cdots & a_{1m} \\
\vdots & \vdots & \ddots & \vdots\\
1 & a_{n1} & \cdots & a_{nm} \\
\end{bmatrix}\ ,\quad
Y=\begin{bmatrix}
b_1\\\vdots\\b_n
\end{bmatrix}\ ,\quad
\varepsilon=[\varepsilon_1,\cdots,\varepsilon_n]^{\rm T}\ ,\quad
\beta=[\beta_0,\beta_1,\cdots,\beta_m]^{\rm T}</script><p>则上式可表示为</p>
<script type="math/tex; mode=display">
\begin{cases}
Y=X\beta+\varepsilon\\
\varepsilon\sim N(0,\sigma^2E_n)
\end{cases}</script><p>其中$E_n$为$n$阶单位矩阵</p>
<h4 id="2-参数估计"><a href="#2-参数估计" class="headerlink" title="2. 参数估计"></a>2. 参数估计</h4><p>模型式中的参数$\beta_0,\beta_1,\cdots,\beta_m$<strong>用最小二乘法进行估计</strong>，即应选取估计值$\hat{\beta}{\small j}$，使当$\beta_j=\hat{\beta}{\small j}\quad j=0,1,\cdots,m$时，误差平方和</p>
<script type="math/tex; mode=display">
Q = \sum^n_{i=1}\varepsilon_i^2=\sum^n_{i=1}(b_i-\hat{b}_i)^2=\sum^n_{i=1}(b_i-\beta_0-\beta_1a_{i1}-\cdots-\beta_ma_{im})^2</script><p>达到最小，为此，令</p>
<script type="math/tex; mode=display">
\frac{\partial Q}{\partial\beta_i}=0\quad,j=0,1,2,\cdots,n</script><p>得</p>
<script type="math/tex; mode=display">
\begin{cases}
\dfrac{\partial Q}{\partial\beta_0}-2\sum\limits^n_{i=1}(b_i-\beta_0-\beta_1a_{i1}-\cdots-\beta_ma_{im})=0\\
\dfrac{\partial Q}{\partial\beta_i}-2\sum\limits^n_{i=1}(b_i-\beta_0-\beta_1a_{i1}-\cdots-\beta_ma_{im})a_{ij}=0\quad j=1 ,2,\cdots,m
\end{cases}</script><p>经整理化为以下正规方程组</p>
<script type="math/tex; mode=display">
\begin{cases}
\beta_0n+\beta_1\sum\limits^n_{i=1}a_{i1}+\beta_2\sum\limits^n_{i=1}a_{i2}+\cdots+\beta_m\sum\limits^n_{i=1}a_{im}&=\sum\limits^n_{i=1}b_i\\
\beta_0\sum\limits^n_{i=1}a_{i1}+\beta_1\sum\limits^n_{i=1}a^2_{i1}+\beta_2\sum\limits^n_{i=1}a_{i1}a_{i2}+\cdots+\beta_m\sum\limits^n_{i=1}a_{i1}a_{im}&=\sum\limits^n_{i=1}a_{i1}b_i\\
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\vdots\\
\beta_0\sum\limits^n_{i=1}a_{im}+\beta_1\sum\limits^n_{i=1}a^2_{im}+\beta_2\sum\limits^n_{i=1}a_{im}a_{i2}+\cdots+\beta_m\sum\limits^n_{i=1}a^2_{im}&=\sum\limits^n_{i=1}a_{im}b_i\\
\end{cases}</script><p>正规方程组的矩阵形式为：$X^{\rm T}X\beta=X^{\rm T}Y$</p>
<p>当矩阵$X$列满秩时，$X^{\rm T}X$为可逆方阵，$X^{\rm T}X\beta=X^{\rm T}Y$的解为：</p>
<script type="math/tex; mode=display">
\hat{\beta}=(X^{\rm T}X)^{-1}X^{\rm T}Y</script><p>将$\hat{\beta}$代回原模型得到y的估计值</p>
<script type="math/tex; mode=display">
\hat{y} = \hat{\beta}_0+\hat{\beta}_1x_1+\cdots+\hat{\beta}_mx_m</script><p>而这组数据的拟合值为</p>
<script type="math/tex; mode=display">
\hat{b}_i = \hat{\beta}_0+\hat{\beta}_1a_{i1}+\cdots+\hat{\beta}_ma_{im}\quad(i=1,2,\cdots,n)</script><p>记$\hat{Y}=X\hat{\beta}=[\hat{b}_1,\cdots,\hat{b}{\small n}]^{\rm T}$，拟合误差$e=Y-\hat{Y}$称为残差，可作为随机误差$\varepsilon$的估计，</p>
<p>而 </p>
<script type="math/tex; mode=display">
Q=\sum\limits^n_{i=1}e_i^2=\sum\limits^n_{i=1}(b_i-\hat{b}_i)^2</script><p>为残差平方和（或剩余平方和）</p>
<h4 id="3-统计分析"><a href="#3-统计分析" class="headerlink" title="3. 统计分析"></a>3. 统计分析</h4><p>不加证明的给出以下结果</p>
<p>（1）$\hat{\beta}$是$\beta$的线性无偏最小方差估计，$\hat{\beta}$的期望=$\beta$，在$\beta$的线性无偏估计中,$\hat{\beta}$的方差最小</p>
<p>（2）$\hat{\beta}$服从正态分布： $\hat{\beta}\sim N(\beta,\sigma^2(X^{\rm T}X)^{-1})$  ,记$(X^{\rm T}X)^{-1} = (c{\small ij})_{n\times n}$</p>
<p>（3）对残差平方和$Q$，$EQ=(n-m-1)\sigma^2$，且 $\dfrac{Q}{\sigma^2}\sim \chi^2(n-m-1)$，由此得到$\sigma^2$的无偏估计</p>
<script type="math/tex; mode=display">
s^2=\frac{Q}{n-m-1}=\hat{\sigma}^2</script><p>其中$s^2$是剩余方差（残差的方差）,$s$称为剩余标准差</p>
<p>（4）对总平方和$SST$进行分解，有</p>
<script type="math/tex; mode=display">
SST=Q+U\\</script><p>其中，</p>
<script type="math/tex; mode=display">
\bar{b}=\dfrac{1}{n}\sum\limits^n_{i=1}b_i</script><script type="math/tex; mode=display">
Q=\sum\limits^n_{i=1}e_i^2=\sum\limits^n_{i=1}(b_i-\hat{b}_i)^2</script><p>为残差平方和，反应随机误差对$y$的影响；</p>
<script type="math/tex; mode=display">
U=\sum\limits^n_{i=1}(\hat{b}_i-\bar{b})^2</script><p>称为回归平方和，反应自变量对$y$的影响。上述的分解利用了正规方程组。</p>
<h4 id="4-回归模型的假设检验"><a href="#4-回归模型的假设检验" class="headerlink" title="4. 回归模型的假设检验"></a>4. 回归模型的假设检验</h4><p>因变量$y$和自变量$x_1,\cdots,x_m$之间是否存在模型所示的线性关系是需要检验的</p>
<p>显然，如果所有的$|\hat{\beta}{\small j}|\ (j=1,\cdots,m)$都很小，则$y$与$x_1,\cdots,x_m$的线性关系就不明显了，所以可以令原假设为：</p>
<script type="math/tex; mode=display">
H_0:\beta_j=0,\ j=1,\cdots,m</script><p>当$H_0$成立时由分解式$SST=Q+U$定义的$Q、U$满足</p>
<script type="math/tex; mode=display">
F = \frac{U/m}{Q/(n-m-1)}\sim F(m,n-m-1)</script><p>在显著性水平$\alpha$下，对于上$\alpha$分位数$F{\small \alpha}(m,n-m-1)$，若$F&lt;F{\small \alpha}(m,n-m-1)$，接受$H_0$，否则拒绝</p>
<blockquote>
<p>接受$H_0$只能说明$y$与$x_1,\cdots,x_m$的线性关系不明显，可能存在非线性关系，如：平方关系</p>
</blockquote>
<p>其他用于衡量$y$与$x_1,\cdots,x_m$相关程度的指标：回归平方和在总平方和中的比值定义复判定系数</p>
<script type="math/tex; mode=display">
R^2=\frac{U}{SST}=\frac{U}{Q+U}</script><p>其中$R=\sqrt{R^2}$称为复相关系数，$R$越大，$y$与$x_1,\cdots,x_m$相关关系越密切。通常$R&gt;0.8$或$R&gt;0.9$才认为相关关系成立</p>
<h4 id="5-利用回归模型进行预测"><a href="#5-利用回归模型进行预测" class="headerlink" title="5. 利用回归模型进行预测"></a>5. 利用回归模型进行预测</h4><p>当回归模型和系数通过检验后，可由给定$[x<em>1,\cdots,x_m]$的取值$[a{\small 01},\cdots,a</em>{0m}]$预测$y$的取值$b_0$，$b_0$是随机的，显然其预测值（点估计）为</p>
<script type="math/tex; mode=display">
\hat{b}_0=\hat{\beta}_0+\hat{\beta}_1a_{01}+\cdots+\hat{\beta}_ma_{0m}</script><p>给定$\alpha$可以算出$b_0$的预测区间(区间估计)，结果较复杂，但当$n$较大且$a{\small 0i}$接近平均值$\barx_i$时，$b_0$的预测区间可简化为</p>
<script type="math/tex; mode=display">
[\hat{b}_0-z_{\frac{\alpha}{2}}s,\ \hat{b}_0+z_{\frac{\alpha}{2}}s]</script><p>其中$z{\small {\frac{\alpha}{2}}}$是标准正态分布的上$\dfrac{\alpha}{2}$分位数</p>
<p>对$b_0$的区间估计方法可用于给出已知数据残差$e_i=b_i-\hat{b}_i\ (i=1,\cdots,n)$的置信区间，$e_i$服从均值为0的正态分布（$e_i\sim N(0,\sigma^2)$），所以若某个$e_i$的置信区间不包含零点，则认为这个数据是异常的，可予以剔除</p>
<h3 id="（二）MATLAB中的多元线性回归分析"><a href="#（二）MATLAB中的多元线性回归分析" class="headerlink" title="（二）MATLAB中的多元线性回归分析"></a>（二）MATLAB中的多元线性回归分析</h3><p>MATLAB统计工具箱中有一个实现多元线性回归的函数<code>regress</code></p>
<p>Code : <code>b = regress(Y, X)</code></p>
<p>其中，Y和X为按(22)式排列的数据，b为回归系数估计值 </p>
<script type="math/tex; mode=display">
\hat{\beta}_0,\hat{\beta}_1,\cdots,\hat{\beta}_m</script><p>Code : <code>[b, bint, r, rint, stats] = regress(Y, X, alpha)</code></p>
<p>其中，Y和X为按(22)式排列的数据，alpha为显著性水平（缺省值为0.05），b和bint为回归系数估计值和它们的置信区间，r和rint为残差(向量)及其置信区间</p>
<p>stats是用于检验回归模型的统计量，有四个数值：</p>
<p>第一个是$R^2$；第二个是$F$；第三个是与$F$对应的概率$p\ \ ,p&lt;\alpha$拒绝$H_0$，回归模型成立；第四个是残差的方差$s^2$</p>
<p>残差及其置信区间可以用<code>rcoplot(r, rint)</code>画图</p>
<h2 id="二、多元二项式回归"><a href="#二、多元二项式回归" class="headerlink" title="二、多元二项式回归"></a>二、多元二项式回归</h2><p>MATLAB统计工具箱提供了一个作多元二项式回归的命令<code>rstool</code>，它能够产生一个交互式画面，并输出有关信息</p>
<p>Code : <code>rstool(X, Y, medol, alpha)</code></p>
<p>其中<code>alpha</code>为显著性水平  $\alpha$（缺省值为0.05），<code>model</code>可以选择如下四种模型，缺省值为<code>&#39;linear&#39;</code>线性模型</p>
<p><img src="https://cdn.jsdelivr.net/gh/XLY23333/picture01/img01/image-20240216012623970.png" alt="image-20240216012623970"></p>
<p>$[y,x<em>1,\cdots,x_m]$的$n$个独立观测数据仍然记为。。$[b_i,a{\small i1},\cdots,a</em>{im}]\quad i=1,\cdots,n$</p>
<p>Y,XX分别为n维列向量和$n\times m$的矩阵</p>
<script type="math/tex; mode=display">
Y=\begin{bmatrix}
b_1\\\vdots\\b_n
\end{bmatrix}\quad\quad
XX=\begin{bmatrix}
a_{11} & \cdots & a_{1m}\\
\vdots & & \vdots\\
a_{n1} & \cdots & a_{nm}
\end{bmatrix}_{n\times m}</script><blockquote>
<p>注意！</p>
<p>（1）此处的XX数据矩阵与线性回归分析中的数据矩阵X不同，X是构建的表达式系数矩阵，其第一列为全1列，XX是列向量观测值横向拼接成的矩阵</p>
<p>（2）在完全二次多项式回归中，二次项系数的排列次序<strong>是先交叉项的系数</strong>，<strong>最后是纯二次项的系数</strong></p>
</blockquote>
<p>在交互式图像界面可以通过键选或输入相应值来得出其预测值和置信区间</p>
<p>并且可以通过<kbd>导出</kbd>按钮导出显影的拟合系数到变量beta，RMSE到变量rmse，残差保存到变量residuals中</p>
<p>RMSE(Root Mean Squared Error)是<strong>均方根误差</strong>，是一种衡量预测值与实际值之间误差的方法，通常用于评估模型的预测性能，计算公式为：</p>
<script type="math/tex; mode=display">
RMSE = \sqrt{\frac{1}{n}\sum\limits^n_{i=1}(y_{pred(i)}-y_{actual(i)})^2}</script><p>外部实现代码为</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">y_actual = [actual values];</span><br><span class="line">y_predicted = [predicted values];</span><br><span class="line"><span class="comment">% 计算残差</span></span><br><span class="line">residuals = y_actual - y_predicted;</span><br><span class="line"><span class="comment">% 计算 RMSE</span></span><br><span class="line">rmse = <span class="built_in">sqrt</span>(<span class="built_in">mean</span>(residuals.^<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>但是rstool方法内置了数据标准化、添加截距项等步骤，所以外部实现的rmse不能直接同rstool输出的rmse进行比对的</p>
<h2 id="三、非线性回归"><a href="#三、非线性回归" class="headerlink" title="三、非线性回归"></a>三、非线性回归</h2><p>非线性回归是指因变量$y$对应系数$\beta_1,\cdots,\beta_m$（而不是自变量）是非线性的</p>
<p>MATLAB统计工具箱中提供了四个命令用于非线性回归问题</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nlinfit</code></td>
<td>计算回归系数</td>
</tr>
<tr>
<td><code>nlparci</code></td>
<td>计算回归系数的置信区间</td>
</tr>
<tr>
<td><code>nlpredci</code></td>
<td>计算预测值及其置信区间</td>
</tr>
<tr>
<td><code>nlintool</code></td>
<td>得到交互式画面</td>
</tr>
</tbody>
</table>
</div>
<p>命令方法解析</p>
<ul>
<li>非线性回归：<code>[beta, r, j] = nlinfit(xr, yr, &lt;xfx&gt;, beta0)</code><ul>
<li>其中beta、r和j分别承接回归系数beta，残差r和jacobian矩阵</li>
<li>xr、yr为x和y的原始数据，y为列向量，x为列向量横向拼接成的矩阵，</li>
<li><code>&lt;xfx&gt;</code>是匿名函数构建的目标拟合公式，beta0为beta的初始值，若未给可以自由选择</li>
</ul>
</li>
<li><p>回归系数的置信区间：<code>&lt;ValName&gt; = nlparci(beta, r, &#39;jacobian&#39;, j)</code></p>
<ul>
<li>这里使用最常见的jacobian矩阵方法进行拟合构建，所以Model选择’jacobian’</li>
<li>其他的条件由<code>nlinfit</code>命令得到</li>
</ul>
</li>
<li><p>预测值及其置信区间半径：<code>[Val_pred, delta] = nlpredci(&lt;xfx&gt;, Xt, beta, r, &#39;jacobian&#39;, j)</code></p>
<ul>
<li>val_pred和delta承接预测值及其置信区间半径</li>
<li>xt为预测值所需的自变量，构建方法同xr</li>
<li>这里同样使用最常见的jacobian矩阵方法进行拟合构建，所以Model选择’jacobian’</li>
</ul>
</li>
<li><p><em>tool</em> 交互式非线性拟合：<code>nlintool(xr, yr, &lt;xfx&gt;, beta0)</code></p>
<ul>
<li><p>交互式方法可以直接列用交互式图像完成上面的部分，只需要导入初始数据，默认使用’jacobian’模式</p>
</li>
<li><p>利用‘导出’功能，可以直接导出下面的参数：</p>
<p>  | 参数 | 参数CI | 预测  | 预测CI  | RMSE | 残差      |<br>  | —— | ——— | ——- | ———- | —— | ————- |<br>  | beta | betaci | ypred | ypredci | rmse | residuals |</p>
<blockquote>
<p>注意，这里的ypred和ypredci是交互式界面键入所得的值，而不能直接将其与实际结果的预测输出</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>所以<code>nlintool</code>交互式画面更容易求解基础的问题和RMSE等没有确定函数的问题</p>
<p><code>nlinfit</code> \ <code>nlparci</code> \ <code>nlpredci</code>更适合建立一个复杂问题的模型，也更方面对大量的数据进行预测</p>
<h2 id="四、实战例题"><a href="#四、实战例题" class="headerlink" title="四、实战例题"></a>四、实战例题</h2><h3 id="Eg-s1-合金强度拟合的回归分析"><a href="#Eg-s1-合金强度拟合的回归分析" class="headerlink" title="Eg.s1 合金强度拟合的回归分析"></a>Eg.s1 合金强度拟合的回归分析</h3><blockquote>
<p>合金强度y与其中的碳含量x有比较密切的关系，今从生产中收集了一批数据如下表，试先拟合一个函数y(x)，再用回归分析对它进行检验</p>
</blockquote>
<p>Data:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>x</th>
<th>0.10</th>
<th>0.11</th>
<th>0.12</th>
<th>0.13</th>
<th>0.14</th>
<th>0.15</th>
<th>0.16</th>
<th>0.17</th>
<th>0.18</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>y</strong></td>
<td>42.0</td>
<td>41.5</td>
<td>45.0</td>
<td>45.5</td>
<td>45.0</td>
<td>47.5</td>
<td>49.0</td>
<td>55.0</td>
<td>50.0</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% Data</span></span><br><span class="line">x1 = [<span class="number">0.10</span>:<span class="number">0.01</span>:<span class="number">0.18</span>]&#x27;; <span class="comment">% 仅有一个变量，尝试一元线性模型</span></span><br><span class="line">y1 = [<span class="number">42.0</span> <span class="number">41.5</span> <span class="number">45.0</span> <span class="number">45.5</span> <span class="number">45.0</span> <span class="number">47.5</span> <span class="number">49.0</span> <span class="number">55.0</span> <span class="number">50.0</span>]&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(x1,y1,<span class="string">&#x27;+&#x27;</span>) <span class="comment">% 大致预览数据</span></span><br><span class="line"><span class="comment">%% 拟合</span></span><br><span class="line">a = [<span class="built_in">ones</span>(<span class="built_in">size</span>(x1)),x1];</span><br><span class="line">[b,bint,r,rint,stats] = regress(y1,a);</span><br><span class="line">b,bint <span class="comment">% 查看b值是否在置信区间内</span></span><br><span class="line">stats <span class="comment">%</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">rcoplot(r, rint) <span class="comment">% 第8个数据出现问题，删除该数据</span></span><br><span class="line"><span class="comment">%% ReData</span></span><br><span class="line">clear</span><br><span class="line">x1 = [<span class="number">0.10</span>:<span class="number">0.01</span>:<span class="number">0.18</span>]&#x27;; <span class="comment">% 仅有一个变量，尝试一元线性模型</span></span><br><span class="line">y1 = [<span class="number">42.0</span> <span class="number">41.5</span> <span class="number">45.0</span> <span class="number">45.5</span> <span class="number">45.0</span> <span class="number">47.5</span> <span class="number">49.0</span> <span class="number">55.0</span> <span class="number">50.0</span>]&#x27;;</span><br><span class="line">x1(<span class="number">8</span>)=[];</span><br><span class="line">y1(<span class="number">8</span>)=[];</span><br><span class="line"><span class="comment">%% Re拟合</span></span><br><span class="line">a = [<span class="built_in">ones</span>(<span class="built_in">size</span>(x1)),x1];</span><br><span class="line">[b,bint,r,rint,stats] = regress(y1,a);</span><br><span class="line">b,bint <span class="comment">% 查看b值是否在置信区间内</span></span><br><span class="line">stats <span class="comment">%</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">rcoplot(r, rint) <span class="comment">% 第8个数据出现问题(异常点)，删除该数据</span></span><br><span class="line"><span class="comment">%% Others</span></span><br><span class="line">clc</span><br><span class="line"><span class="comment">% CalTest最小二乘计算相应值</span></span><br><span class="line">b1 = a\y1</span><br><span class="line"><span class="comment">% 拟合图像</span></span><br><span class="line">x = <span class="built_in">min</span>(x1):<span class="number">0.001</span>:<span class="built_in">max</span>(x1);</span><br><span class="line">y = b(<span class="number">1</span>)+b(<span class="number">2</span>)*x;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y,x1,y1,<span class="string">&#x27;r+&#x27;</span>)</span><br><span class="line"><span class="comment">% MSE</span></span><br><span class="line">y1_fit = b(<span class="number">1</span>)+b(<span class="number">2</span>)*x1;</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;MSE: &#x27;</span> num2str(mse(y1-y1_fit))])</span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b =</span><br><span class="line">   27.4722</span><br><span class="line">  137.5000</span><br><span class="line">bint =</span><br><span class="line">   18.6851   36.2594</span><br><span class="line">   75.7755  199.2245</span><br><span class="line">stats =</span><br><span class="line"></span><br><span class="line">    0.7985   27.7469    0.0012    4.0883</span><br><span class="line">    </span><br><span class="line">b =</span><br><span class="line">   30.7820</span><br><span class="line">  109.3985</span><br><span class="line">bint =</span><br><span class="line">   26.2805   35.2834</span><br><span class="line">   76.9014  141.8955</span><br><span class="line">stats =</span><br><span class="line">    0.9188   67.8534    0.0002    0.8797</span><br><span class="line"></span><br><span class="line">b1 =</span><br><span class="line">   30.7820</span><br><span class="line">  109.3985</span><br><span class="line">MSE: 0.65977</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="./output/egs1.jpg" style="zoom: 67%;" /></p>
<h3 id="Eg-s2-电器的销售量预测"><a href="#Eg-s2-电器的销售量预测" class="headerlink" title="Eg.s2 电器的销售量预测"></a>Eg.s2 电器的销售量预测</h3><blockquote>
<p>某厂生产的一种电器的销售量y与竞争对手的价格x1和本厂的价格x2有关。下表是该商品在10个城市的销售记录。试根据这些数据建立y与x1和x2的关系式，对得到的模型和系数进行检验。若某市本厂产品售价160 (元)，竞争对手售价170(元)，预测商品在该市的销售量。</p>
</blockquote>
<p>Data:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$x_1$元</th>
<th>120</th>
<th>140</th>
<th>190</th>
<th>130</th>
<th>155</th>
<th>175</th>
<th>125</th>
<th>145</th>
<th>180</th>
<th>150</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>$x_2$元</strong></td>
<td>100</td>
<td>110</td>
<td>90</td>
<td>150</td>
<td>210</td>
<td>150</td>
<td>250</td>
<td>270</td>
<td>300</td>
<td>250</td>
</tr>
<tr>
<td><strong>$y$个</strong></td>
<td>102</td>
<td>100</td>
<td>120</td>
<td>77</td>
<td>46</td>
<td>93</td>
<td>26</td>
<td>69</td>
<td>65</td>
<td>85</td>
</tr>
</tbody>
</table>
</div>
<p>分别用多元线性回归 和 多元二项式回归进行预测</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear,clc</span><br><span class="line"><span class="comment">%% Data:</span></span><br><span class="line">x1 = [<span class="number">120</span> <span class="number">140</span> <span class="number">190</span> <span class="number">130</span> <span class="number">155</span> <span class="number">175</span> <span class="number">125</span> <span class="number">145</span> <span class="number">180</span> <span class="number">150</span>]&#x27;;</span><br><span class="line">x2 = [<span class="number">100</span> <span class="number">110</span> <span class="number">90</span> <span class="number">150</span> <span class="number">210</span> <span class="number">150</span> <span class="number">250</span> <span class="number">270</span> <span class="number">300</span> <span class="number">250</span>]&#x27;;</span><br><span class="line">y = [<span class="number">102</span> <span class="number">100</span> <span class="number">120</span> <span class="number">77</span> <span class="number">46</span> <span class="number">93</span> <span class="number">26</span> <span class="number">69</span> <span class="number">65</span> <span class="number">85</span>]&#x27;;</span><br><span class="line"><span class="comment">%% ShowRawData</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x1,y,<span class="string">&#x27;r+&#x27;</span>)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(x2,y,<span class="string">&#x27;r+&#x27;</span>)</span><br><span class="line"><span class="comment">%% FitRegressAnalysis 拟合回归分析</span></span><br><span class="line">a = [<span class="built_in">ones</span>(<span class="built_in">size</span>(x1)), x1, x2];</span><br><span class="line">[b,bint,r,rint,stats] = regress(y,a);</span><br><span class="line">b,bint,stats</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">rcoplot(r,rint)</span><br><span class="line"><span class="comment">% 如果计算RMSE，其值将不与rstool得出的结果相同</span></span><br><span class="line"><span class="comment">% 原因是没有进行rstool内置的数据标准化、添加截距项等</span></span><br><span class="line"><span class="comment">% 所以regress得出的方法不能跟rstool得出的RMSE直接比对</span></span><br><span class="line"><span class="comment">%% x1:170 x2:160 y?</span></span><br><span class="line">y_pred_1716 = b(<span class="number">1</span>) + b(<span class="number">2</span>)*<span class="number">170</span> + b(<span class="number">3</span>)*<span class="number">160</span></span><br><span class="line"><span class="comment">%% Rstool 多元二项式回归</span></span><br><span class="line">rstool([x1,x2],y,<span class="string">&#x27;purequadratic&#x27;</span>)</span><br><span class="line">rstool([x1,x2],y,<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line"><span class="comment">% beta</span></span><br><span class="line"><span class="comment">% rmse</span></span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b =</span><br><span class="line">   66.5176</span><br><span class="line">    0.4139</span><br><span class="line">   -0.2698</span><br><span class="line">bint =</span><br><span class="line">  -32.5060  165.5411</span><br><span class="line">   -0.2018    1.0296</span><br><span class="line">   -0.4611   -0.0785</span><br><span class="line">stats =</span><br><span class="line">    0.6527    6.5786    0.0247  351.0445</span><br><span class="line"></span><br><span class="line">y_pred =</span><br><span class="line">   93.7182</span><br><span class="line">   </span><br><span class="line">--------</span><br><span class="line">beta =</span><br><span class="line"></span><br><span class="line"> -312.5871</span><br><span class="line">    7.2701</span><br><span class="line">   -1.7337</span><br><span class="line">   -0.0228</span><br><span class="line">    0.0037</span><br><span class="line">rmse =</span><br><span class="line">   16.6436</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="./output/egs21.jpg" style="zoom:67%;" /></p>
<p><img src="./output/egs22.jpg" style="zoom:67%;" /></p>
<h3 id="Eg-s3-运动员问题"><a href="#Eg-s3-运动员问题" class="headerlink" title="Eg.s3 运动员问题"></a>Eg.s3 运动员问题</h3><blockquote>
<p>将17至29岁的运动员每两岁一组分为7组,每组两人测量其旋转定向能力,以考察年龄对这种运动能力的影响。现得到一-组数据如下，试建立两者之间的关系</p>
</blockquote>
<p>Data:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Age</th>
<th>17</th>
<th>19</th>
<th>21</th>
<th>23</th>
<th>25</th>
<th>27</th>
<th>29</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Person1</strong></td>
<td>20.48</td>
<td>25.13</td>
<td>26.15</td>
<td>30.0</td>
<td>26.1</td>
<td>20.3</td>
<td>19.35</td>
</tr>
<tr>
<td><strong>Person2</strong></td>
<td>24.35</td>
<td>28.11</td>
<td>26.3</td>
<td>31.4</td>
<td>26.92</td>
<td>25.7</td>
<td>21.3</td>
</tr>
</tbody>
</table>
</div>
<p>注意当前问题，虽然看似是含有两个自变量的多元问题，实际上是一个Age对应两个Person的值，所以在此处尝试使用多项式拟合poly的方法进行建模</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc,clear</span><br><span class="line"><span class="comment">%% Data</span></span><br><span class="line">age = [<span class="number">17</span>:<span class="number">2</span>:<span class="number">29</span>];</span><br><span class="line">ages = [age,age];</span><br><span class="line">h1 = [<span class="number">20.48</span> <span class="number">25.13</span> <span class="number">26.15</span> <span class="number">30.0</span> <span class="number">26.1</span> <span class="number">20.3</span> <span class="number">19.35</span>];</span><br><span class="line">h2 = [<span class="number">24.35</span> <span class="number">28.11</span> <span class="number">26.3</span> <span class="number">31.4</span> <span class="number">26.92</span> <span class="number">25.7</span> <span class="number">21.3</span>];</span><br><span class="line">h0 = [h1,h2];</span><br><span class="line"><span class="comment">%% poly</span></span><br><span class="line">[p, s] = polyfit(ages, h0, <span class="number">2</span>);</span><br><span class="line">p</span><br><span class="line">[y, delta] = polyconf(p,age,s); <span class="comment">% 带入模型进行预测</span></span><br><span class="line">y <span class="comment">% 拟合值</span></span><br><span class="line">delta; <span class="comment">% 预测区间的半径</span></span><br><span class="line"></span><br><span class="line">polytool(ages, h0, <span class="number">2</span>) <span class="comment">%  预测模型交互式图像</span></span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p =</span><br><span class="line">   -0.2003    8.9782  -72.2150</span><br><span class="line"></span><br><span class="line">y =</span><br><span class="line">   22.5243   26.0582   27.9896   28.3186   27.0450   24.1689   19.6904</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="./output/egs3.jpg" style="zoom:67%;" /></p>
<h3 id="Eg7-20-化学动力反应模型"><a href="#Eg7-20-化学动力反应模型" class="headerlink" title="Eg7.20 化学动力反应模型"></a>Eg7.20 化学动力反应模型</h3><blockquote>
<p>在研究化学动力学反应过程中，建立了一个反应速度和反应物含量的数学模型，形式为</p>
<script type="math/tex; mode=display">
y=\frac{\beta_4x_2-\dfrac{x_3}{\beta_5}}{1+\beta_1x_1+\beta_2x_2+\beta_3x_3}</script><p>其中$\beta_1,\cdots,\beta_5$是位置的参数，$x_1,x_2,x_3$是三种反应物(氢、n戊烷，异构戊烷)的含量，$y$是反应速度。</p>
<p>今测得一组数据入下表，试由此确定参数$\beta_1,\cdots,\beta_5$，并给出其置信区间</p>
<p>$\beta_1,\cdots,\beta_5$的参考值为$[0.1,0.05,0.02,1,2]$</p>
<blockquote>
<p>此处可以看作给出了回归系数的初始值，若没有提供则可以随机取</p>
</blockquote>
</blockquote>
<p>Data:</p>
<p>序号 反应速度  氢  戊烷  异构戊烷<br>1    8.55    470    300    10<br>2    3.79    285    80    10<br>3    4.82    470    300    120<br>4    0.02    470    80    120<br>5    2.75    470    80    10<br>6    14.39    100    190    10<br>7    2.54    100    80    65<br>8    4.35    470    190    65<br>9    13.00    100    300    54<br>10    8.50    100    300    120<br>11    0.05    100    80    120<br>12    11.32    285    300    10<br>13    3.13    285    190    120</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear,clc</span><br><span class="line"><span class="comment">%% Data</span></span><br><span class="line">yr = [<span class="number">8.55</span> <span class="number">3.79</span> <span class="number">4.82</span> <span class="number">0.02</span> <span class="number">2.75</span> <span class="number">14.39</span> ...</span><br><span class="line">      <span class="number">2.54</span> <span class="number">4.35</span> <span class="number">13.00</span> <span class="number">8.50</span> <span class="number">0.05</span> <span class="number">11.32</span> <span class="number">3.13</span>]&#x27;;</span><br><span class="line">x1 = [<span class="number">470</span> <span class="number">285</span> <span class="number">470</span> <span class="number">470</span> <span class="number">470</span> <span class="number">100</span> <span class="number">100</span> ...</span><br><span class="line">      <span class="number">470</span> <span class="number">100</span> <span class="number">100</span> <span class="number">100</span> <span class="number">285</span> <span class="number">285</span>]&#x27;;</span><br><span class="line">x2 = [<span class="number">300</span> <span class="number">80</span> <span class="number">300</span> <span class="number">80</span> <span class="number">80</span> <span class="number">190</span> <span class="number">80</span> <span class="number">190</span> ...</span><br><span class="line">      <span class="number">300</span> <span class="number">300</span> <span class="number">80</span> <span class="number">300</span> <span class="number">190</span>]&#x27;;</span><br><span class="line">x3 = [<span class="number">10</span> <span class="number">10</span> <span class="number">120</span> <span class="number">120</span> <span class="number">10</span> <span class="number">10</span> <span class="number">65</span> ...</span><br><span class="line">      <span class="number">65</span> <span class="number">54</span> <span class="number">120</span> <span class="number">120</span> <span class="number">10</span> <span class="number">120</span>]&#x27;;</span><br><span class="line">xr = [x1, x2, x3];</span><br><span class="line">beta0 = [<span class="number">0.1</span>,<span class="number">0.05</span>,<span class="number">0.02</span>,<span class="number">1</span>,<span class="number">2</span>]&#x27;;</span><br><span class="line"><span class="comment">%% Regress</span></span><br><span class="line"><span class="comment">% 用匿名函数定义拟合函数</span></span><br><span class="line">x = xr;</span><br><span class="line">hs = @(<span class="built_in">beta</span>,x) ((<span class="built_in">beta</span>(<span class="number">4</span>)*x(:,<span class="number">2</span>)-(x(:,<span class="number">3</span>))/(<span class="built_in">beta</span>(<span class="number">5</span>))) ...</span><br><span class="line">               ./(<span class="number">1</span>+<span class="built_in">beta</span>(<span class="number">1</span>)*x(:,<span class="number">1</span>)+<span class="built_in">beta</span>(<span class="number">2</span>)*x(:,<span class="number">2</span>)+<span class="built_in">beta</span>(<span class="number">3</span>)*x(:,<span class="number">3</span>)));</span><br><span class="line"><span class="comment">% 引入初始值</span></span><br><span class="line">beta0;</span><br><span class="line"><span class="comment">% [nlinfit]非线性回归计算回归系数beta，其中r和j是后续命令所需的中间量</span></span><br><span class="line">[<span class="built_in">beta</span>, r, <span class="built_in">j</span>] = nlinfit(xr,yr,hs,beta0)</span><br><span class="line"><span class="comment">% [nlparci]计算回归系数的置信区间</span></span><br><span class="line">betaci = nlparci(<span class="built_in">beta</span>,r,<span class="string">&quot;jacobian&quot;</span>,<span class="built_in">j</span>)</span><br><span class="line"><span class="comment">% [nlpredci]计算预测y值及其置信区间半径</span></span><br><span class="line">[y_pred, delta] = nlpredci(hs,xr,<span class="built_in">beta</span>,r,<span class="string">&#x27;jacobian&#x27;</span>,<span class="built_in">j</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Disp</span></span><br><span class="line"><span class="comment">% [nlintool]展示拟合图像结果的交互式画面</span></span><br><span class="line">nlintool(xr,yr,hs,beta0)</span><br><span class="line"><span class="comment">% rmse</span></span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beta =</span><br><span class="line">    0.0628</span><br><span class="line">    0.0400</span><br><span class="line">    0.1124</span><br><span class="line">    1.2526</span><br><span class="line">    1.1914</span><br><span class="line">betaci =</span><br><span class="line">   -0.0377    0.1632</span><br><span class="line">   -0.0312    0.1113</span><br><span class="line">   -0.0609    0.2857</span><br><span class="line">   -0.7467    3.2519</span><br><span class="line">   -0.7381    3.1208</span><br><span class="line">r =</span><br><span class="line">    0.1321</span><br><span class="line">   -0.1642</span><br><span class="line">   -0.0909</span><br><span class="line">    0.0310</span><br><span class="line">    0.1142</span><br><span class="line">    0.0498</span><br><span class="line">   -0.0262</span><br><span class="line">    0.3115</span><br><span class="line">   -0.0292</span><br><span class="line">    0.1096</span><br><span class="line">    0.0716</span><br><span class="line">   -0.1501</span><br><span class="line">   -0.3026</span><br><span class="line">y_pred =</span><br><span class="line">    8.4179</span><br><span class="line">    3.9542</span><br><span class="line">    4.9109</span><br><span class="line">   -0.0110</span><br><span class="line">    2.6358</span><br><span class="line">   14.3402</span><br><span class="line">    2.5662</span><br><span class="line">    4.0385</span><br><span class="line">   13.0292</span><br><span class="line">    8.3904</span><br><span class="line">   -0.0216</span><br><span class="line">   11.4701</span><br><span class="line">    3.4326</span><br><span class="line">delta =</span><br><span class="line">    0.2805</span><br><span class="line">    0.2474</span><br><span class="line">    0.1766</span><br><span class="line">    0.1875</span><br><span class="line">    0.1578</span><br><span class="line">    0.4236</span><br><span class="line">    0.2424</span><br><span class="line">    0.1638</span><br><span class="line">    0.3426</span><br><span class="line">    0.3281</span><br><span class="line">    0.3699</span><br><span class="line">    0.3237</span><br><span class="line">    0.1749</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="./output/eg720.jpg" style="zoom: 50%;" /></p>
]]></content>
      <categories>
        <category>数学建模</category>
        <category>预测模型</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>预测</tag>
        <tag>回归</tag>
      </tags>
  </entry>
</search>
