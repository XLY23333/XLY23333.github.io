<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数模M01-评价模型</title>
    <url>/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/M01-%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="评价模型"><a href="#评价模型" class="headerlink" title="评价模型"></a>评价模型</h1><h2 id="一、层次分析法-AHP"><a href="#一、层次分析法-AHP" class="headerlink" title="一、层次分析法 AHP"></a>一、层次分析法 AHP</h2><blockquote>
<p>学习源Video:<a href="https://www.bilibili.com/video/BV1qy4y1a7JJ?p=23&amp;vd_source=1437b1798845fbcba4cf09d5a889e546">Bilibili-ln异教徒 <strong>AHP</strong></a></p>
</blockquote>
<p>作用：层次分析法用来进行决策，求指标的权重</p>
<p>模型建立步骤：</p>
<ul>
<li><p>建立层次结构</p>
<ul>
<li>将决策问题分为三个部分：目标层、准则层和指标层/方案层</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/XLY23333/picture01/img01/AHPeg01.png" style="zoom: 50%;" /></p>
</li>
<li><p>对准则层构建判断矩阵</p>
<ul>
<li><p>判断矩阵为两两指标重要性的判断，一般判别矩阵构造如下：</p>
<script type="math/tex; mode=display">
A=(a_{ij}) _{m\times n}=
\begin{pmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{n1} & a_{n2} & \cdots & a_{nn}
\end{pmatrix}</script></li>
</ul>
<p>九级标度法表格</p>
<p>| 标度             | 含义                                      |<br>| ———————— | ————————————————————- |<br>| 1                | i和j具有<strong>相同</strong>的重要性(Eg:主对角线元素) |<br>| 3                | i比j<strong>稍微</strong>重要                          |<br>| 5                | i比j<strong>明显</strong>重要                          |<br>| 7                | i比j<strong>强烈</strong>重要                          |<br>| 9                | i比j<strong>极端</strong>重要                          |<br>| 2、4、6、8       | 上述标度的<strong>中间量</strong>                      |<br>| $\frac{1}{标度}$ | 矩阵下三角<strong>对称位置</strong>的值                |</p>
</li>
<li><p>一致性检验（特征根法）</p>
<blockquote>
<p>在通过主观想法确定两个属性之间的重要性差距标度时，可能出现不一致的情况，需要用一致性检验对所得的判断矩阵进行一致性的检验，确定所得的判断矩阵能够使用</p>
<p>一致性的例子：A~12~=2, A~13~=2,那么说明1 对 2和3 的重要程度相同，可以推出2和3的重要程度相同，</p>
<p>​                          即A~23~ = A~32~ =1，如果该值不为1则说明其不一致。</p>
</blockquote>
<p>用对应于A的最大特征根（记为$\lambda$）的特征向量（归一化后）作为权向量$w$，即$w$满足</p>
<script type="math/tex; mode=display">
A\lambda = \lambda w</script><p>当 $\lambda = n$ 时，该判断矩阵为一致阵，且任何判断矩阵的最大特征根 $\lambda\ge n$ 。因此，当最大特征根比 $n$ 大得多时，该判断矩阵的不一致程度越严重，所以可以用 $\lambda - n$ 的数值来衡量判断矩阵的不一致程度，并将</p>
<script type="math/tex; mode=display">
CI = \frac{\lambda_{\max}-n}{n-1}</script><p>作为一致性指标，当$CI=0$时判断矩阵为一致阵，并引入随机一致性指标$RI$，$RI$数值如下：</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>$n$</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>$RI$</td>
<td>0.58</td>
<td>0.9</td>
<td>1.12</td>
<td>1.24</td>
<td>1.32</td>
<td>1.41</td>
<td>1.45</td>
</tr>
</tbody>
</table>
</div>
<p>  将它的一致性指标$CI$与同阶（指$n$相同）的随机一致性指标$RI$之比称为一致性比率$CR$，当</p>
<script type="math/tex; mode=display">
  CR = \frac{CI}{RI}<0.1</script><p>  时，认为该判断矩阵的不一致程度在容许范围之内，可以用其特征向量作为权向量。最终得到每个指标的权重结果。</p>
<ul>
<li><ul>
<li>方法一：使用MATLAB的<code>eig()</code>方法直接求得特征根 $v$和特征向量$d$，随后通过求取特征向量和特征值的所在列，计算<code>w = v(:,loc)/sum(v(:,loc));</code>得到转为行向量，即权向量res_A。</li>
</ul>
</li>
</ul>
<p>​    <strong><em>Matlab-ModelCode</em></strong></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% 判断矩阵导入</span></span><br><span class="line">A = [<span class="number">1</span>   <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line">     <span class="number">4</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">6</span> <span class="number">6</span></span><br><span class="line">     <span class="number">4</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">6</span> <span class="number">6</span></span><br><span class="line">     <span class="number">1</span>/<span class="number">2</span> <span class="number">1</span>/<span class="number">6</span> <span class="number">1</span>/<span class="number">6</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">     <span class="number">1</span>/<span class="number">2</span> <span class="number">1</span>/<span class="number">6</span> <span class="number">1</span>/<span class="number">6</span> <span class="number">1</span> <span class="number">1</span>]</span><br><span class="line"><span class="comment">%% 一致性检验</span></span><br><span class="line">n = <span class="built_in">length</span>(A);</span><br><span class="line">[v, d] = eig(A); <span class="comment">% 计算特征根和特征向量</span></span><br><span class="line">[temp, loc] = <span class="built_in">max</span>(<span class="built_in">max</span>(d)); <span class="comment">% 返回loc为特征向量的所在列</span></span><br><span class="line">r = temp; <span class="comment">% 得到lambda_max的值</span></span><br><span class="line">CI = (r-n)/(n<span class="number">-1</span>); <span class="comment">% 计算一致性指标CI</span></span><br><span class="line">RI = [<span class="number">0</span> <span class="number">0</span> <span class="number">0.58</span> <span class="number">0.90</span> <span class="number">1.12</span> <span class="number">1.24</span> <span class="number">1.32</span> <span class="number">1.41</span> ... <span class="comment">% 换行输入</span></span><br><span class="line">      <span class="number">1.45</span> <span class="number">1.49</span> <span class="number">1.52</span> <span class="number">1.54</span> <span class="number">1.56</span> <span class="number">1.58</span> <span class="number">1.59</span>]; <span class="comment">% 引入随机一致性指标RI</span></span><br><span class="line">CR = CI/RI(n); <span class="comment">% 计算一致性比率CR</span></span><br><span class="line"><span class="keyword">if</span> CR &lt; <span class="number">0.1</span> || n == <span class="number">2</span> <span class="comment">% 确定其一致性比率&lt;0.1或只含有两个元素，两个元素一定一致</span></span><br><span class="line">    CR_Result = <span class="string">&#x27;Pass&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    CR_Result = <span class="string">&#x27;Nope&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 权向量计算</span></span><br><span class="line">w = v(:,loc)/sum(v(:,loc));</span><br><span class="line">w = w&#x27;;</span><br><span class="line"><span class="comment">%% DispResult</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;---------AHP---------&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;CI: &#x27;</span> num2str(CI)]) <span class="comment">% 一致性指标</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;CR: &#x27;</span> num2str(CR)]) <span class="comment">% 一致性比率</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;CR_Result: &#x27;</span> num2str(CR_Result)]) <span class="comment">% 一致性检验结果</span></span><br><span class="line"><span class="keyword">if</span> CR_Result == <span class="string">&#x27;Pass&#x27;</span> <span class="comment">% 若一致性检验通过则输出特征值和权向量</span></span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;lambda: &#x27;</span> num2str(r)]) <span class="comment">% 特征值</span></span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;w: &#x27;</span> num2str(w)]) <span class="comment">% 权向量</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>方法二：算术平均法求权重</li>
</ul>
</li>
</ul>
<blockquote>
<p>将判断矩阵按照列归一化$\to$将归一化的结果按行求和$\to$每个元素除以n</p>
</blockquote>
<script type="math/tex; mode=display">
w_i =  \frac{1}{n}\sum\limits_{j=1}^n\frac{a_{ij}}{\sum\limits^n_{k=1}a_{kj}}\quad\quad(i=1,2,\cdots,n)</script><ul>
<li>对指标层/方案层的内容构建<ul>
<li>每一个准则层性质中 多个指标间的判断矩阵并进行AHP（多个准则，每个准则指向多个指标）</li>
<li>每一个准则层性质的 每个方案间的判断矩阵并进行AHP（多个准则，多个主责指向多个方案）</li>
</ul>
</li>
<li>将准则层/方案层的每一个准则性质的$w$转成行向量<ul>
<li>准则层的所有值$w$值构成权向量res_B</li>
<li>方案层纵向拼接，所得的即为方案曾的权矩阵res_B，</li>
</ul>
</li>
<li>计算最终得分/综合权重<ul>
<li>指标：res_A(指标层集的大类准则)$\times$res_B所得结果</li>
<li>方案：res_A$\times$res_B得到综合权重res_Z</li>
</ul>
</li>
</ul>
<hr>
<h2 id="二、熵权法-EWM"><a href="#二、熵权法-EWM" class="headerlink" title="二、熵权法 EWM"></a>二、熵权法 EWM</h2><blockquote>
<p>学习源Video:<a href="https://www.bilibili.com/video/BV1qy4y1a7JJ?p=24&amp;vd_source=1437b1798845fbcba4cf09d5a889e546">Bilibili-ln异教徒 <strong>EWM</strong></a></p>
</blockquote>
<ul>
<li><p>数据的归一化处理</p>
<blockquote>
<p>由于各项指标计量单位并不统一，因此在计算综合权重前先要对它进行标准化处理，即把指标的绝对值转化为相对值，并令 $x{\small ij} = |x{\small ij}|$ ，从而解决各项不同质指标的同质化问题。</p>
</blockquote>
<ul>
<li><p>方法一：</p>
<p>由于正向指标和负向指标数值代表的含义不同（正向指标数值越高越好，负向指标数值越低越好），因此对于高低需求指标应当采取不同的算法进行数据标准化处理，具体处理方法为 :</p>
<p>对于正向指标：</p>
<script type="math/tex; mode=display">
x_{ij} = 0.998\frac{x_{ij}-\min\{x_{1j},\cdots,x_{nj}\}}{\max\{x_{1j},\cdots,x_{nj}\}-\min\{x_{1j},\cdots,x_{nj}\}}+0.002</script><p>对于负向指标：</p>
<script type="math/tex; mode=display">
x_{ij} = 0.998\frac{\max\{x_{1j},\cdots,x_{nj}\}-x_{ij}}{\max\{x_{1j},\cdots,x_{nj}\}-\min\{x_{1j},\cdots,x_{nj}\}}+0.002</script></li>
</ul>
</li>
</ul>
<blockquote>
<p>通常会采用一些稍微小一点的值来代替 0 和 1，以便更好地保留原始数据的分布特征。</p>
<p>且直接使用 0 和 1 作为归一化后的极值，可能会导致数据过于集中在边界附近，失去了部分信息。</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Matlab的归一化自定义函数 # Gy.m</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">Gy</span><span class="params">(x,type,ymin,ymax)</span></span></span><br><span class="line"><span class="comment">% 实现正向或负向指标归一化，返回归一化后的数据矩阵</span></span><br><span class="line"><span class="comment">% x为原始数据矩阵，一行代表一个样本，每列代表一种指标</span></span><br><span class="line"><span class="comment">% type设定正向指标1，负向指标2</span></span><br><span class="line"><span class="comment">% ymin，ymax为归一化的区间端点</span></span><br><span class="line">[n, m] = <span class="built_in">size</span>(x);</span><br><span class="line">y = <span class="built_in">zeros</span>(n,m);</span><br><span class="line">xmin = <span class="built_in">min</span>(x);</span><br><span class="line">xmax = <span class="built_in">max</span>(x);</span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">type</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:m</span><br><span class="line">            y(:,<span class="built_in">j</span>)=(ymax-ymin)*(x(:,<span class="built_in">j</span>)-xmin(<span class="built_in">j</span>))/(xmax(<span class="built_in">j</span>)-xmin(<span class="built_in">j</span>))+ymin;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    case2</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:m</span><br><span class="line">            y(:,<span class="built_in">j</span>)=(ymax-ymin)*(xmax(<span class="built_in">j</span>)-x(:,<span class="built_in">j</span>))/(xmax(<span class="built_in">j</span>)-xmin(<span class="built_in">j</span>))+ymin;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>方法二：Python scikit-learn MinMaxScaler</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据归一化(sklearn)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line">data = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">        [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">        [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],]</span><br><span class="line"><span class="comment"># 如果data为单列则需添加.values.reshape(-1,1)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data:&#x27;</span>,data[:<span class="number">5</span>]) <span class="comment"># 展示前五个数据</span></span><br><span class="line"></span><br><span class="line">MM_Scaler = MinMaxScaler(feature_range=(<span class="number">0</span>,<span class="number">1</span>)) <span class="comment"># 默认缩放范围(0,1)</span></span><br><span class="line">MMres = MM_Scaler.fit_transform(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;MMres:&#x27;</span>,np.<span class="built_in">round</span>(MMres[:<span class="number">5</span>,],<span class="number">2</span>)) <span class="comment"># 展示前五个数据,保留3位小数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>计算第$j$项指标下第$i$方案指标值的比重$p_{ij}$</p>
<script type="math/tex; mode=display">
p_{ij} = \frac{x_{ij}}{\sum\limits^n_{i=1}x_{ij}}\quad(j=1,2,\cdots,m)</script></li>
<li><p>计算第$j$项指标的熵值$e_j$</p>
<script type="math/tex; mode=display">
e_j = -k\sum^n_{i=1}p_{ij}\ln p_{ij}\quad(j=1,2,\cdots,m)</script><p>其中$k=\dfrac{1}{\ln(n)}$，满足$e_j\ge 0$</p>
</li>
<li><p>计算信息熵冗余度$g_{j}$</p>
<script type="math/tex; mode=display">
g_j = 1-e_j\quad(j=1,2,\cdots,m)</script></li>
<li><p>计算各项指标权重$w_j$</p>
</li>
</ul>
<script type="math/tex; mode=display">
w_j =\frac{g_j}{\sum\limits^m_{j=1}g_j}\quad(j=1,2,\cdots,m)</script><ul>
<li>计算综合评分$S_i$<script type="math/tex; mode=display">
S_i = \sum^m_{j=1}w_jx_{ij}</script></li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% DataLoad</span></span><br><span class="line">data = xlsread(<span class="string">&#x27;./HouseData.xlsx&#x27;</span>);</span><br><span class="line"><span class="comment">%% 归一化</span></span><br><span class="line">ind = <span class="built_in">ones</span>(<span class="built_in">size</span>(data,<span class="number">2</span>),<span class="number">1</span>); <span class="comment">% data列数作为RowCount,ColCount=1</span></span><br><span class="line"><span class="comment">% indArr的建立，正向写1，负向写2，在此处默认都是正向指标，所以建立全一的纵向Arr</span></span><br><span class="line"></span><br><span class="line">[n, m] = <span class="built_in">size</span>(data); <span class="comment">% n个样本，m个指标</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">    <span class="keyword">if</span> ind(<span class="built_in">j</span>) == <span class="number">1</span> <span class="comment">% 正向指标的归一化</span></span><br><span class="line">        X(:,<span class="built_in">j</span>) = Gy(data(:,<span class="built_in">j</span>),<span class="number">1</span>,<span class="number">0.002</span>,<span class="number">1</span>); <span class="comment">% 归一化最低值范围不能为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">% 负向指标的归一化</span></span><br><span class="line">        X(:,<span class="built_in">j</span>) = Gy(data(:,<span class="built_in">j</span>),<span class="number">2</span>,<span class="number">0.002</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 熵权法求取权向量</span></span><br><span class="line"><span class="comment">% 计算第j个指标下，第i个样本占该指标的比重p(i,j)</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">        p(<span class="built_in">i</span>,<span class="built_in">j</span>) = X(<span class="built_in">i</span>,<span class="built_in">j</span>)/sum(X(:,<span class="built_in">j</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 计算第j个指标的熵值e(j)</span></span><br><span class="line">k = <span class="number">1</span>/<span class="built_in">log</span>(n);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">    e(<span class="built_in">j</span>) = -k * sum(p(:,<span class="built_in">j</span>).*<span class="built_in">log</span>(p(:,<span class="built_in">j</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">g = <span class="built_in">ones</span>(<span class="number">1</span>,m)-e; <span class="comment">% 计算信息熵冗余度</span></span><br><span class="line">w = g./sum(g); <span class="comment">% 求权值w</span></span><br><span class="line">s = X*w&#x27;; <span class="comment">% 求综合评分</span></span><br><span class="line"><span class="comment">% DispPlot</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;Gyed_Data:&#x27;</span>);<span class="built_in">disp</span>(X)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;p(i,j):&#x27;</span>);<span class="built_in">disp</span>(p)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;e(j):&#x27;</span>);<span class="built_in">disp</span>(e)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;g(j):&#x27;</span>);<span class="built_in">disp</span>(g)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;w(j):&#x27;</span>);<span class="built_in">disp</span>(w)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;s(j):&#x27;</span>);<span class="built_in">disp</span>(s)</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">2017</span>:<span class="number">-1</span>:<span class="number">2010</span>,s)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学建模</category>
        <category>评价模型</category>
      </categories>
      <tags>
        <tag>AHP层次分析法</tag>
        <tag>EWM熵权法</tag>
        <tag>MATLAB</tag>
        <tag>评价模型</tag>
      </tags>
  </entry>
  <entry>
    <title>数模M03-Kmeans聚类论文可使用部分</title>
    <url>/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/M03-KmeansPaper/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="027efff8ee900bf8ff98ca7e830e37f8e40b69d685b69fb7bd669cf9b67e7c3a">2d0cc57e0ca0d95b94a86d2858934c236a929973a1341844210faac8bd7bf73c3d510240d6cf5d989f7d63f8c8db6b1b6de20346640f5bf50f274f81c03b231129d482910960ac219e778af4c7db4e28f847ec4295f626227dcafc651a81d083870862d9b60a25c285297c3841c2186709d6ca45d98fdca289c5962b5723b6f48aec913b14d84755eb8cd71be942815bac9bd0d7eb6b8c7ae786515eedee51d009412b6eb977aee6e4f6c389ae3f9d72c603f32c89edc619d1f286ea75e92b853a02a671cd475f25380c155d1bfa5298f5d3b8f93b484b4630c3e9c451f6d0e2d86249a1d58138a2d17c97c0340867ed82348899845dac8bc2e4a20ef38f707fbf85c2cf48bb68c7d33f1262dcdd5caf51f31ca6bcac75f942631e06029498d9d849d228d243b7a54ad4f1135a5fbb686823ba6044d4a90bd35d1679043129a7dc87b8315b58c4700e74da2475ae3a21e9120ac3cef3ffc438106f529f7a86b3a9173a9eadd713d8217c5b149ddd8a54fca18ed0dae1d62cf8f69fceed32219c7a2a5dd070dd4d91f158fbf14f8aa481ce67ac77334906a57342d86e4402b62c72b01fc4a4b603e6fcf4ddfd1614a432e70bf49195bb16f9515cfca4164ca43c6e6fac9c3dc70e3017cfbebbc9006a5e61e879076e86d9b629dc0172a8de77367b33fe1a25a47fa1f70a23bfb721d158d2030e05e9f57b1337ffc949b5dd99e45a153af549b5b7976a7c2dc83b5a62a5600d06148713cd4bcf6536f8209b717b3c7c2db9504290ee1d20bfe47349e9b3ff399a1992618d3ffa00c62e24810d43593838d69e95ab0a19806cccde49f51b0713cd0afb81714a94da0518fa07176b23b86c0cacaaeadabc2001ff9e5d29052f0b1e5d478d69373a9d1bd7ddc3c274f806373d3a1f870dbe2c687c8e3644eefc2ca4d85783949e54959df4be1d59c26f59d19b2382f8c5835ae08c5518a5f06c34c3fd64c6e9e57ea46bb5779fe645d6ef058ea20ef3ad1724765bdc1f7177e2a37930dfe7c116f05674eb22c7cb3b7507df0f87dbf3bd0c5ecea5be20e53e776a8e99197fa8d1ea6d2b57a9a805002a4c9eec6fcd2c482a531f29895b3f16068692f03b8957872a7d00e6176dec7748cea3980390cf0ee4338ce45bab2b05b56f2744bafb090e1689008f851b539e84df08b58ef0b5ae75ca168dd63beefc508566c2fd1937314c9ddaa3698b1b66757eb716de222c953321d26f44cc640668ec7a070762d9c8066fdd4585a77f8306c33e8daa6474b0a78a371c12d7f6bf3f6db5dc0f66a7861de08f0cf2e7d96af1b576ca6c00736045f88d630134c4bc1a05ed3c7987cd399ebd3fa1ea840d3f1f1ac895a0ba064a78c0c96fc6b663cc6b4ee181289dbd9b3397d0fa5331f5caa6612f36981b527b2adf87b56ede9639ac0e1e5d3dcd036c1356eba7cf9cd757716d29af81f0e27cd6dbfeffd583ef2b0cf7fb37635e67c06cd338d1b303f302f511299a6064a3d956d91e102a520ae1aac147e4295d5dc54f6368ebafd0b81d645f632ed81ddf0ce72922a4b4cee7ad47e0f7fa5d4bac21fbf743693cdb7adc036dfca5f49dd88d349842568853c6d918232babada3e62f51a9b6bbee5efdcd6501a3514cf098f4d76a7beaa1aed54dbbd34679d184d3090e89d38bf2b4170b93ece2c0c5cd7a43d3786b131d73c732a674aeaf56a384af5b73a0efff9f7f092cde095c5a7cbe0b30859fd66fe1250cfa467822410b1d9637202f782e5177670d6c715e84e2a8b1ae21b8fdbca545614525c768fc776cb07ff91ac12b808c165514024fa806e2e2708e9b09d3294252a35ea6f6c3b1ae2d6f51f356f228b4757982eb3392f12412b7a3db15d0c20ce97e24d3c55bfe52665ae813b9e76c0ae2c389dea9e04de631adb6a8868342c04181b6412200bbd956d2491fd4f8802f3f9ca4cb739220b81964eec3ab43cc53af23478855c40ee004191f17464101f275a00e0dc40ff56c5c34089444c24a6ec117a79e635ca080456dd9d1485f3494fe3f07551b34b2cff3a23e600363f29b79ba2379a390bffeb9b2a8179719b1993c1216bcf003faaf1723afde94cc075eed93810b3aa622606ea31e971ea7cafd63a4dba40b37582c8ea9c5f3ec14b70250802e1547ffa9e258bef1100d5149239e817d95dac3d9bc66801ae536714ca4c4eb6caf382caa7a82a36d96db930986615f764dbbf3020904678fa527300a537ac0ea64a31d5e6961e22eed3bbbbc904e808e4c6e006553cdef315ddc6a5748a69806573c2246b7ca9ebe727099ff9e1854fabdee68fb28d3844fe9f34094fcfcbb2a0bb820659e752cbd00da30517e3684354e2912545ee04a51d08e33239d1a37bbeae9c731fdca026d6de43a7cfd1de1c1562d6d5faf6673a86fabaf17494d7a5e0e0dc276adf773fb9f20416402d58a75b2601969c48a4b7083646ab12a532682acf80dce0caf0ceda80ab0ef17a3bfe3c93120305610b05d69a88cc35d7600a3ddf21738b2711ea55a8d287f1dc8f4d077c2bc4cd7409f6c76426e7b3ac2b2d4cdee93a1b4aa7477f383ec5a224bff8af7499b85b1e4d3449cd22cb6e0fdc36c2486c2b828f7d5dcb89434c6513fa95bdcd17ad03c978f7c1437c6c7b6b1e058dbbcab01f93f1b09838b781b9ef3e6c66cc6fc9665d167d714720f0e04364ee8df9c62eed98263215a74c2da8ee03279e891a88750b362deacfbb96ea60898b2b36287f7c97d62d92533111cab8b7ad3e11d0e7ec60d444cf7734f613c2007920e513364bd79fa965484a7a17f69399a4938243c1f64c7d646809b79bbe116f765e9cd0530642213fe0eb17e019cde75b750c7dcb9519f5f2ab60caa7a4fd09138ac1feffade0646d41651e2bde14c7ed6219f288d0db6b39c7401123d69e6c5dcba8c16a3dd4b1db219b4da4fe7f42d3ea3c1f2325f564e220afdbeafaa16a20ace8e7b5feb1fc8dee7f1cfed8220b3059f0b24799888cfd3ff3f48e8b9875d992148cb191a0cd19e1f1a114874518ed2479f41ed15d2f51eb4273adc8ae9d2a5120aa7d29334b67af80c420ed3cc12448a24150afdc27d52119008a47123d152962a1c84e2abc0543cad573820e5ac30f7a21d3957d7a5d9f72560f9759b318fde72321fba6628228c8528521a3d8a9e1c4ad7170f4fc1c4f0629b7bdfb41187a82597d91e0343d1ee14819bad418999b624df69f79330c895c99d6d2fff2c91e0122367d6bed3b520b98ead6c6b160e4bfc8999c8bb16b77b1512b8172bc0a576ccf9d4d9410c36b3d3f522db759a9508fcce5b4754bf8fa728950d3c737be07a55bdab673952742aef1c226d3f38227c8768c02f52920dd6be616833c85fe92933b505241244cfcd45052f74fe12c8c8e5a9b65e939d24049c8f9fa541356267e9ebe9619f26a2358db2421b95fd306b31cca6014d2f31c1abbc00dbf52014462f14780b0d0882b9f7b34947e1794d4ea06081b79a30d68941056c372ac1842102f604f0a811d44b623d74864f8318b365af1222f67402e6baf9f453121cc7f3e07a71d6b031eb5bdd888980ca9c8ff6e005f8a53a959acbc066f1c56e4ee95f3ce551fcdb605aad70df5c3d110a7e28d0940735e923bbb9c30d14dc4938e4267bf37829bdf80a6aa4db2f581ef15ade74422acddffe8180a32d1164c408a67606a679f8930e59c599c0e1b6068dda6bc1d3d70929447ed53820852340689d262ade039b12228c3eddc4425e997ae093e529eefba78a6235cace6f0448ac7d51005cde73202d5d59bdcfe707d826390a5e98f27b77ecad918c0cabde424016e5711eeaefec3c262d9098bddbdd75fea652a7b3bd1ac77cc2a6391399abf2856bbaa8a9dd64ee2700ab01258a45e94bd38e433934485aa736b6d8f122da17926cf01d85f24f65ce4c13b1302baf599b4f4938f03952d470c787a6caab185a618222928b51fbb3d0de483f44f2311f48421661a6db55d7eda77c9edf4b526a492a6adba76fe689440e9d40f8700e0f7aaff6cbe4051f1eadb6ca119ddfca7ff88fc0559a5ffdfc8c90e8e83e0b07f66268618b9ab3379a1b45599708cd8ad3f537ded4364ea166b214dbd091594f266a339c133b0d47c7e920c19a2ca570f3f99e487f0c85b91ff7f005228cff9d3968a7280e59e0c582fde67ae93bcb2c500daf7e9066b9f71d1bd5c2af6f0789b2935993a75e1ad4aa95e16eddb4989b978e66a35bd10a8f08bc482e62e4bc72fce412bd2730a84ebb70f852e5403fb1a8e655a81c08d90ae15caa7983778f2d4da4d37834b0b3957828e130f7822f6f8f1421db4a19cbebf07454ce6a34a7f11026370b94af391572b9f3084dd712a56dc013152122f1a091e7bca6cc8f78ae0a30a035f98b698e5cb9ba3af744ed8b7c18f1905dfa963829716be5b6ec86df7128695c1937cf2b2f629735069249c5a5dcd6078edcc0d3faab90bfe96454c4cfdf29574afabf07a0b35bdf987e563b6a6ccea39506f5e9234b51801e81917ae06805c752cfb63b065d0cd84167c4982fec1b685f516b3d6407e04f3fa67eba7ffe7f802d2ef10126922babdf9e7a2af916c3515815213b4ea6b1e3e7ebcb5e887008093e329971113c7b0ebc9d251c3cd0ab9a46ae2d4e1252279a38701af40c986becb6788a4ee7556240786b8859aad2b10e3e8d3543dd860f7fedeeb4bf906a4d9f275b42949a3ae6a44f1b51cfbd422a67075727e2c29eb2da0d93785bc7df0ce627ede7452f2f278e97933a13ae5454dc0a075b56916e93ef603b2ae524b4dfdd158fef3ee8b20e985f7568dd8f7f8feef15bde6416cf88400c65c8a89f179c7586e5846ffca776436cb5aebef79268d2ac72dc6e112b73dfa1c817cc83c5b7d8c646b832a602f98ca5de93b9bf290d61681be699b148bf3efbd92ace0d42fcc3572c6373fafadd7b638e23af6b2592ecd9ec9e482dc40b8c4b6db28fe60ac5187c36d05385f9f9ca292f6b7e63412019cb1d97da3dc7c2cd0ae479d5a95ac5436785edead7f92fa6cba3232c48e680603504c1cca0f2d8efb3fed6755eaaf0950e2dc59615f93152f59c875b79ed0c67bf9a980e4a6403521de1dc1c6b7b455430f88447ec86b8e87b01bb54cad8ea670fbd326dbec3b4a23da77a5b4ab2b3a99e306c6434f33750960dca68feb7fa199acac3754273ddb93edc53dc63e5abaac8729a3db1bddfe2af1ccce8ebc182820b213b7050263ca3aae92c5844c219543e1aecb4e651e3b56a2f5b088f8155c91e37231b97902d2d405ed271ad491a8b72003cdd997be9d605f32c296ef74c3f31c52976e4a39435fb08b0f3b019a5d4910ef212f1d7e6c66aefee09983b37ae871843f2bb74877603334da88f66e71192a71acd27f4adbac7116d7f96dba68ba7dc902e6bc9ead4f4791e9be91edbba45ab452fc78db5b435e7ad533643d6a4f0780320f2fa44433c888f6e065fcb3d7ffb768034f598f6884b0ec3b1a1ac87fafcb3fa711f46049c52483ade5c94450ff0fa21b36e09e6f9989137439c36680c36cc04db81a19777dcea4045d44f2da1b9a746c2715a4a9892fa878f37cc8aee388ef9779485651e81becd78f10ed37148f73e39d605a268186922d693216e1dcbfb41e050827d8f8f376332278d500d199f19e5ccf8c059fc9421c1b1788b7f90bc4383bef20bc939ff60e2ffd60da84c1cbdcf6a483ac12cf46ceecb7eb67adab7dc313df0decefb5f26b5a320ec6d2f8621dd7341d3ec11c71e844ad252a9617e463ed696eac128a46b4bc72ebfeaadedec61e591965dae54135889dac4a5e1b07fe4661e233b7ba3e8b9fd439697180f7148a468b56ae48129a9ade148f3bfd6c62772a07a3d0e8aad8acf265346d14d86af39f36b0eb58dd4b9d6ce44fb35c3fce52efe3f1f38ab79205f74ea787ab5bda936f38c4d19c61cf549eac83e8fff64a9fc8ae934921eac0ff0f8b816713ed26062318bf52030fe99c52f324b52753b3119df6a30488d8f0c24380ffa964e9c7d4ca8187173cbd73ecfe595241c76396d21f3b0c5c78094c893c35459aacad475e19f2672284555341dc36fa71249a960a4a1b0f00bc85854e930ee8f1dfa127d576ef39a155605703a62fb4713309bb3670abc2599b26b36b0e4607602509183983ab3e482d1671f8817113e60830e0ebab43b2143c2f0288534490f5007557e7e8756d89c10f8d4e68d980ccf038ede1681119bca9bf9e77b5f83530052504b3628c493c9aa96cc85253e533e3d89f7f1eeaeb2edd18c48932e0009251e57e37cd797dbeb7571bd651a8426652d106947495a426df88bc8f4ab0cd3c6a3aa85472f02279e22aba311a1d650b52753e5dfe61b821aad7d011f4b7503635e5264fabec5ed809b83a8c973c214a7cf8e5c29155c6d4f7295cb79abb1643d248d8c8966f029799335126efa0cf97802df87977e37e5b306cdeb5d99163e0c966b30c1fad54462e9886d14a5b464ac326fdbb733f240bbbe232e6c7040d0f5ab0905ec0c799f875c6f35e095097aebe31b1159d7c496152be3ed5aa135da47e6ef85cfda73e35a4564d3c0b436a16c36e180bf6085239b1bb3aa5deba3bf5cd059a51962416383df8cf671dc7c3bf50c3e7de45915245998c815a8a4055d943e013c7bdefa3e196747a675de58e316ae260609ecf7b986b445c4dca03be65c4e28bc36418a2204552bf18bd3e6438fe5445b1153440fecddac1bf7b029917e8ff45ed62efacdb52fe5f92451bd0466f76a718dbdab80bced0f3a6c247ed7d66c06e6602568ae7d8247a555d75826756dc2e31c9e5166ec3bda4585613f73f3a97ef26063b33a14a713497c4b71ce3629b18e6171aaa93725cacbd0eccf09dafcd933c05669b212601afde3fe13f6223f2b7252759e580efdd7939f1d38686f9b970721ab79aca6bff6ff511a6820b4867fd7a21caad491d364d935a03d0b221c8eb07d29049496637c31d06596d6c2ec9333b047498e805dea5e7cf0467ce92cec35c74ea6563b36390e2faa085b4ae96144f7896052cee8797f34b273ced2bf1b96165701e29915d0f43ee130fec0d6533c4f0ec1c94495ca4a3f6ee983faa33c10d48b8c3a81d8495f76f326000a63d674a8247e8e0b5198212fc917ab6576223c88acbc90f6fad8d8bf57fa8da73cf32eb7caf51d8a5f3f88ce53d4e4afb520af627c9bdb0e54dd650e2d1f175ec1248604a010ffa9e69af40965daf7e4d77691543776c0184d3d954bf6fbc5febce0b56b8c14af2f139713927c6df7f9fc2d4e4b61f6cba53d467c18992b87047f822a5684ebe892bde01d8e8a68734c60533d83cc6f0599a534995e321599e37910f92b98e114449a70a59e892dddc06262c8cca8d103b4cd7665ccb5ccf44b18296a876a9f4ec7cc6acb4fccfb8a94548fff864046fd40426682f5e1dfd4a1549ca93adc50ea856761e3081ddbeb5e5cb1d14e40e9e45ee95c5ffc45964ca4d14bea6ad452d9f733b180abad9839cbbc48150f4ff788ecf543473f83ca99b21322251e089fdbfe9c71d7aa0402fbec7ab6f2050389f4c6480538c812d68a2a3b0b260bdf99067b9613526a7f5d1c015516c05d52fa02cdc520d9122b74d16cb6a689d34af6cc21f5fdf4695473716e8c2629cd3eb835c92842806b95c2f2d65a9cf50ac4e4e3d9a95bccf06ada76e2cd7fe3ca007d9c0edb225c56ad02766474d49ea52fc9c870c14cc01ce0a2c25af4d797392642a0d1c81329adba6b240711caa7389e56b7850545a1b884a68ed89f020f98c1335ce5cf1f49f9200640847f887d4f1330a26a264947a9475bd7d34c724e21cc61928bc204d0eb3a21e763e504f60fba9b22bc4634facf7e482b018ebb580febe5a9b1d4a0026c3fd8f414d37683a1b15387947d5e2a18dd3daf3c248d9abf301a45e3e2a9aa95f4b79eecf64f9b038e13bb8e820c5a5625009d26e4b4c26d216b9497133719d875bdb059a78275815af1f4b8c9c3ee987065d8ff93ff9d15eb9da3649d53de103fe3a7cd271b8a0f536897b7486c5c42174a6bfddf0ddf87f4faea6813b5a327d25e538f2c376f59ed7c3ef7242188d8ee56dfd462b84a2f174f11aaf1e1d7b8e130fd0330414ae4ab730a58a185a30a8f12b71df2b83ac740238b2b63104b7cc2035f13044a88d1bea5337c070304a258e55d2f78933092992784d02aeea594f4076b0f3ab42702853f33ce375e1b7d7aef58a2278bd80bd67bef01134e80486797af4561745d819c6d6eb9db90d854620ec99ec1c8dfd62846d9098a9f63f5efaf0c6071f9ad842c5b540a506eeddac048f1516b6b20cfc7b5dd90d8c8052a3d9abfcf04b708e5883d479527b5ba9699e2502b7a3399e6192fe209f183e141e358f7900af2ecd428c3081e3af8a2c72b25aabd80c75fca25b12d39c03bba5f6ceb0bb8d9d05332cd5ff1de07647d50017c4cdcc56403fbd02f958c15b9d4c3b9cabd431df5ac5e8a3e12d0fc09b736b2e4dbe6e0c00e9abc9a6f7670b87161e910ce5ec020605d4f7cddf7ae47ab86d45523637e11308cd7ebd7c8b9e26296ea933f0c715ead5991014db739e1b83277af5c51bc672da40f28c1b6bab96a0e53ed30cc0b4cc47d0c8d837d45483029eb4002f617726a9129ad091aba63349d051c0d35fb2eb7ae904f995ba042b62a33c0dcd1148f914b34e849d72542c00ce23eb5c5415b72b76a2b64a380b1a854a7fb4c8b54eccbb62629227b4de531209f3a8330f1f2101e2880bd561031673f57aa1868ab3d707a9b0e31048f82eb20aff1092cd1be1b4686f483477010d965daaf7f7d00e98c53999f117e9f35e239e01c1fe1e30c214dd73368cf2b0bca40622faa903b6a7dec58cbecd4cbad10875f68a8777924847076d690a268d8ebb848d01a03585f80b8ff476c92c1ee2550bf5a7fa204cbaef1c8d4a3703d0f83f79ea07bafdf5cae7c94ca2cf68e2a766655ebcd463e834643b19a7ab04da54f0742df83ec884dcc4c8c77023f60c0e8e095bdc029b5341ed23393bccfe4815eb35a2fecc23a7e4045fb96827d95967f60000a36cc8cabfd6dfefe2e39410449a14aa8a2706e46f7b71f11aa2248bce7c824114bcfffc87081b4298ae1e4765f8155c7787238546291b1fb1fde28ca14d055065edcfe2cd22d9a9fc55ad34ecc9e1cfdb1004f13d974d335859303600b7a07c57b886f5e4567e43a379b74c60c067ade47bdcae56fa4e4a0a1b6f9b63318e24d21ee056b431cf5a935a84d85b56da3b53f568383f9ecf1593cd0ba585035907b35f55d6f9129d2229376e5c3689af746d47986944fd908780d3417e636117e71a7691f3364d2f4db85a4780b150e86143a29f0495b96df45d9e3e5100e03b65764bc2cacb515b2a5cde179c3c12764e995ba27f416911f0802e9e248fb8df3e735179aefa39be5e989473df06e1475ed320acb93aa9484757fa4385f84e68a581b887f56b483bb3cd8485cbb57d9c6ec5b8352417dae10da2ad267a4b9a2eefd3d013c94a673d9416e1905ffcc8e86245717fb922019ffe360c8edce8cef845ee605aa1f4bfb811cca752b84a88e1113f943be90c28d393845f63d910ae4753f0c7836b1b2505cce13cc876c453c3cd9caecfd4c3128789a4090d88590a774e18c089af74ce9528fee6a477bd02ec5219f1edfb1cb4d60f06e0ed981be78c0002b384d279cc4c2f4e1827f01ac7ccefe9a6ef69766dab7a6da465791e2e95ff0e327a498c9e2f944cdfd8946db1d008e9061c13aa8dc557b04621314c1fa94b5046d24899e7bea6f4b92b3688eee725ed0fd220e4a05f3b0bc6d1b5617889c9ff983cdfb213a3dc84fc846d3da968f1fcb18596675282e6e3b8fe21cc9eef0b0f417502cd606dd3173f8cd453568b8f5038e63dd9992dae9f6d93e32b9c00194f83f5bc7657adca9dfc445a7ea7ba9dcbdd03a5b5eedbb956eb8a0c93e2d57e4100ee690289ca91f885413bb37c75739b02e491830def6c02a57b5f8d5e63119b162d27e27fa769c2f69d66d4c2bdf4e8a797a449d0357410154526dee5f1b5d6b36d6b23361be3550888bb8bded53c1e9c46125b5b3abd8b56c10fc66083e5b6b359755ec26bbcf860e83ac654ef865b21c273748449c71f877a6c51172924e4832091f101ccc26d0c8f1e8cc330b609fbce2f9b78aa7b67c12abcbeb367c6ebbcb3331cd6ef1e73395562bbe4f8f1c6a52fb901b6e524e2e7a6b70174b946e65e2fc9b6463f7299e5eaf09454233a7e50956aacc05cb0d250981d9e9498814646342fb6b6d57654016fe62071ba210e70c4e578e2aafa88f46d9d86b742b7ebf6df55c3d55606b88637c5c287ef491ccae04cc21b1a15e1a591b1c063161febc773d73a2a6fb38fe504f1fe97e607dbaa758c078234155361bbb4d59931587dee4f41678a83bf48767a3ad46855325f3f296c3c64fa2bd7cfb24b8388fcfed3836b4b1dcdfa2f86368890887a0f1f13e912f332aaa16a6b459089282c27affa1092e6d09b25e42266a7d55356d0f4993b9c43676ee2ed1af391ef9f603fd83a0e576b434c2f59a42865ad56e2516c0d1fee91b21027f002d68ba58cc0436530a3d3b8a69ffd49205baf257fa629451e49312625a2996919d48faa5d60e3a7fc3c220867d36e38468b48572addf7192debfae6dc9e826b95fee81d5d4f9ba353f076b880c0879d19dacb8b55412297542174402e1ea43732bf2d436e01ae5ef61ccd9664859c6e0f5eff7b16656104f9c4a1bcbb0059ef8f4ef7434f9bba2c1dc381445e279bb673df4740fb46d09d45ef7ade0fd255a9878c351ccc947bcd0d5745003e253fa74cb32607b089dc207010b2edf2a863f52e5fac1a2d0ee305c3c5c2e6a8b633f3d9bfadce852ae6de878b8c89bf9a97a6e5bc20f88825a2269ddb1915f1127d6cc0f96029f22d39f06beec035c16bdfbf18c5659759eb5a410dd06436f484b4b9f7d10567d1adf5950fe4c6368b2b6f8fd7cba7cca7583f7ade27a5e58b1e4085b1af3bd7e8c23eb9bfd499fd4c61fd58182f07b5f461c3d272f79adb6a7a48b53049a33938ce744acb9274598a4ab0d4e26532517ef0e519e889b18b51f0e85e3641e890b76360ce1dfe1a7f72276a6edaddbc7e3bea5e48a71c5664ff17b8c08c87440a77d8deddd97d1baea130008689420c9498974af6dbb3d15a450f57d84af672391a4f296b6b3545d9ac8109141fb36dfe46963d281f81ef3bd35e87ab8a57fdcc941ea969bc671f377c979f6163bb104b643ab9e53485d4bfbd5c24a150f66fa618d88a1f0d8fb62b559fa846024aa6ad563ee38714d9dd444eb9d41cdc39ffa3647d84c66b39eebfa990483ce54a2e2679270d7de3291808e6aa0d578e31b59c9510c327cfd47a460cfd4dd214be89c63dbf25ea7f77010b8402f1b78ab744985e65ceaa6e3450657f60b8609a948036768c8c5a30e1af77bcecd00ab5b0c61a273aeb3ff7c2fbd6f2d6646a5a42b4cb958eb4273a160a898929f18db9e5e392dc09a048393b70064fdb793d3c36061fade8aeb25e117318e2781981a56421cf68605981c1402a06e246962b33c81825acb3cc242eb9d1cf012c251e10976c8290e75d3d91548a53a3c6f4bdd20f67d8b33472fdf75a7a453ed75323ea790c0c4e1997593879c4030bc17e34a1dacb354be516bd3283c29c68716eee1a2a4da797d2609f08a9f5ced60d50d667faf4245862ee36e3aa18841bbcc0719863c7df94a09449e9d8d26c0905b3d62f8f823780345390d86a014148a1619890a0d49f4a7c18ca37794457abd3f17dfbd7e0536d4f781ccbb72dcd07f22933c0b4fa84d82216a2344f57b0a66730b313c917b3a547b87610ea5af9e7f97861b5ea625b97757740ddf5bc4dd1dba77e90d5bcab7cb116454ac547fb22ad7ad75d624a1d8ba52e046f3fe5466cabb79074ff0ebba054d168975d706433e89dc5f0c5bc2360ced6c1c99812ae0ea358e8bdc3fb35b1cd07b153b2896cd28e4e47d5e61d968242f17133167d7178c03625b62dbf366b62c6ef1ff82eca564cb8099b016677d7289384c284d7ebf245aeb9e4fe708bd15b0da2f76dd1cca9dfa259b55a94443f51ff9b84cf6123e932f6a969d76a31009774c8412d43c5fcbb032f83c4ffc1e6010af88dbb76601d1c585df2040c906280fa5aa63fef723a11fc11a12147b738c608db5deb787326c99f98fe7ed23ed50757c7dc789d626c73fb223ac9136020953bb8742d7ce61f10c7732d0628ceeeda2cebb4748f9f0b12094d82b5c0b1ccc853ba897218e2b11fe0dbd5371c5f8a5c93b598ba6fa83d31a2d4c1d8d573729db7d145cc967721689752f039acf5d2e4fecce4f21046e9757e5c094b8fb0bc80fd40e8b69779b3f9d2591069492db8d943ae59c08e0260c757929699981264937a25b8352d879306430ad1b15a3109cc64ea1328319c97e310dfeacfd0055b012a6a8bbc13ad1a2bbce4b14cd66cf7edd6b556de2aba43022650c6ad5b5e43e7c927b24004540c6700410b73eb4294b08620bae93f1dc2be6be99232103d3639eb06e5127394fa033c18ec0944b33fec761f5e0a2e98213344862364e8c258bd0d3f6b85aeaf665c4e2f226f7f743b94c143c86be9dc0d7d8749c8b6668a441faf058e027a9a80d018a399ecc1c8853a2d043b2b690c99f9e2ed7bca2545ba5067138f15f9788601f078156386d85155045c5228ce45376f4337e50de25ae7baf0c1eda93dee97e9eccc6bbfcaf996457e65d435e19992b56edb517ad4328dd6b5ab03c12fc96c3748b42c95243e6281cf9b8cd8589c9a6c96f46ca2287a8934bfc68ccd30dbdbf68b78adbafb10982ae5224673580a6682e4156b78fa9211d79bf84e7b72944fdeadd41d2818b7f8ab026348ba89af0f2515f56c0ae3d28d7d250c78a7f70f8408f24ed6c33a93fdb3130d50417c27cac3bba19d93ff37a7d4ecf488a6c8704c7edfb345b427301c1c6f49fcb1ef7f162058336bd72a78bb5807f7ba4178ce54050dff76376dbd9787ea282834935edfb3b7ca5d9735553cb731da5d6fe0f0d7a682beabff45338e677980eb5865797035b667f2d08cdc35bccff69802887b97509b2da0726c827b9d1ad833bbdac47efc9416afbcf726b1f644ba731260f389d4de019b8ee75a171ee98776da0de512172d60c52a3f81c312038ad26371d93663a1c221d3f0dcc92c29f877a03c958f116972c0d27377bb846f3d715984ca59c9a4bec0c85298390e12ff33f360075b1167f0e43ba4e2b93f9984409bacb5166f599e4a9fd847381b8e68be864b5947ead3c03b9a11fac609199f07ef6debab7ac44a919598dcc2277a02fdab97c05af17fb342f88c540de7f4794087dd43495fa8e934ed5753b97c011899839a34f2f1cff72eb97c9cfc32366041700c754faf03f96452e42819535f5ebbdd0fc73e3c2d053dfb28da42608af070d6f6547503a32a58730ef2857b37adb456ea936f63ee90626adbcb2527493c225f59ece80ac92be63a80fbd9f1f6a81f35dd211649612067da6efd5cbbe94f5becb9d911e183b03d30b99854ff9c7c9a81064ec4959f899bb84abe7c2a706960da64ad8cc45f219cf461ba2b3809d556aad23f6c3576792bcfdf3fcaaa8ff2e18f3ecd54467ab583b9c1aecaeed9059d01ff281d81043697aef23d0097c3ede80b8098de4f96b81208ad57e501decd5c5868fc3490da2b0f76e2ae3a81d06336e8ecfdbadb7db0130b1677a3ac61e593f04eb1dce65b216af379e3fbddbba018e82bd268874eaa47af7854e1493d1988cce904a38293f694933206d15bfef26875a4fefff71a81535760b239813dd992fb7573048876f4ab323155f476272d75a1188481f0ee5060d9ce033ac31cdae1f244146f266ee4c4f004c542b0c06a7dbc67280176270ab311cda6eb72df85a2c8b47a6d58b26d59516b6abc6d7128364a51335baee563c69005f8b72ae70b3a327a275c9e2fe802ac61be32d043757a39533ad16db0cf217b60e5fa941add3adf061f66f7b5c8712a09ee5878014ed6862659ca909281961fa9e9083d3fa87e2267741cdbf5e9c2cee9c338861f1c89fcc6a52882b1f15cdc9d151f1efa56d5072a279e00b0dbb4b260855256bb6273e664275b58c4651ae47920bd446f6bd9f37ecd4ddf5d33057d2f03c8ac63a6334a82e73d02e1807ebad00eecf1ba11db709328cca8bdd2e5a14eeba11bb627f0cad8d365ee1661ad120589c63f5b265a239734aa2aaf231cf9e7c430c61879aa219a732572d411e3ff54501e3e026ec14a182b72830a301d2a8883d64881e9353541c931d011159eb3d25256221f8e34b587c87cc533e32033df11b0310dd110ee10679d40baac637a95f4142b6d29e191ced599477cdf9b1904c03e27dfaf7491d51938b8041e87d3d902984f6a61ee5a0765009addc9a758d15c13ec2d7ce8a5d71ff7941e4219e70868fda4bd655ee8a259c5f0724c41e6596cfc9ec375268840c511de5fed1dd97761f51decd2ffc8f811f191e7a551d8cbae8796dfaa008ceae3bf7b520aabb6ad22f856f95d88753cfff05856dd250438cbedb45e972cee64f25a8c6f775c947aaf104cc0cf07c1c4ccbec6e41ca1be374d77534d68e8498a9b23b364823232049d134238bd1fa644b4392484d9b0566dcc2c157a1b13c26b3591da58e55759cd9b9b505ca36fe036f2d39db630042cb4cbf661ddc20e289c2b5c6948e3e457921b2497f28e79150d273dcf316b02015294b9151e0ff4310f0b670dd85a41e38f38fb23b073045129ea8cbbb99231c4f58ac5c53561d6242e5eede33cb56fac10095e06e5f975364dffda9a30c343659ffafb059ee7423f186c46ac25c231cedfdcafec70da9abdef094009669d78e86e421bdea6c646a62ae033959e20cffbe27d5a6ac9e33061c81e78e4fbcaa71b1a43b1ac4010b0fb91c9c6c3d34be64d1e818baea9765bbb4bebda16b02cc70a01d3b2bc03119dab326b765aad79a8c22d8bd0e597bdd333772fcf8c2553edbabe9b2fae4d002a0ae77cb4775e6909c25f78337cd9365564558ff6bb29966373ef4851b0696c3ab4a635f384265b1c8fa1db4fc6b0e1aa91c0f6fa72d2f44720cdf2cfc4b019dac2d6266a4e3e4db2840fa1c2b6849c22b7079d99e521122e43501a314fcc8c853198901f943d1d082ac0b58a3c6e774dce1f5888b098a6eeac58186e5c1e1d8e4df065f238127616f410e06d3a6eaf39cd9c0bbcc79734267f29991302b534ee578bd38ea6f60c2d7dc026fcd922d56d617891b6a4d8dc51e8484d4713dd53a380d95bc16abea5ca4aff43428f2a4a80490767d71750470b5fdd248f715ed7de607bfb2503aebadedb608a0440c582c002f4d14d94f8832bf1680740236a9f0ef2b7fb146e8646ab3f5e832f45a2fba5b867cce4f9f05d6608284f48119b2fa92ef1605c46d93f6ced05653bfbd9ae266074bfb7959c07a2f99e03c997482c5bae7716f3545bde8aecb6771965753c2f49ce5c6648271029975516ad97634ac6acb9ba2de41a34b983150e062ea67921785122f1f598e1f2770b6d423da561c361e07a4b15f9f9ed88f8e5a477a3cd530f51f1944fe7f075f0fc8aae1a7788936fdd988648ba5b4e74f2dd30248af39c7d69068d7e8c3b760b5514deaf668675a548d62393e53157b3a163dd97212f8012b6d7d98ad2a8772d6dbcf075a46f545b824349d9eac8d4efa7d9fa7a5ddf4d8ae17f4b9849b2383b1dc716cb42d5081ca62dd2dae8696824ba914216b2c2f8d3b28b8cf416e123b53985385be9037d790246448810f25111f898721c90d79858a568787b048a84437299c685a84128004b1642b6b490ef0059ff441817a82084fb7971623c865e8f5a044a46cfddd437c2b29be25d965b725fd1e256bf7e9f24b773c1b593a460dd6734d7e37855fa8112172318d624a76ecf22bf41083e5e32da4da5cb3924938d7bc48b3dfc3c7259844a0174eeb46a3afa39ec6ab64e7a43f2ab0d2365c24e469caf2bff7493be676504c87772238cba4738862a17bfb44c45e7856bf0417f9571e63982c86463fefd2b4f70644a41818a6a59687305cbd4981e5d77c92d647a142386c6a833efd205f5b058870d490774eb1623415e3008168772fb124be2f38fc39a4e279513e604ce36560501aca08a6cc665791b0d1da5e35d8bac82bab0c72014a5fcba8328824558c4263acbd6c70dfdf51b826cb205d2a591db2d6bfc32fee5b67fbadf6efff21445496d65df13f8902b2d0e501e1b31be60ca43efbf8db7ba1b6faaf12a8c9b2e20ff92f39fc8f5c6e19b1edc8e84862bfd76cc7f6e1f132d1ffb7f491b824fd8b0dadc95bf4a654ad4bdce8ce9f386b27cf0034e7732df2c188452a3905e10fc6714f3a341169743938475ae84fdbbf71b5d70d5d586b83301d3d1f8445816e9d1a358b8bed667564f4d4d55e15d5bdb71d132bc8a3903dba08d8bbdd6ab052d0586c9d68e0c774a1e4334bf634ae6c59dbc040cf1482f333bc9c6bafe5e91abc0eab4bd851d1d4ab3f16515f9efc4a04b477adfd25d8ef7b816cd6944560920a10ce526389e8c413f71aa27b9bed1b02f24ac4b0b1a58b2b731df1650802672b0d2d8be308dc54e137de0b55491f30630e8229e9194924b73b7051126b3b261a9485fa304bda5b02b42558f838f4f546ddb582f5ca2b45fafb90c55d3e546b45586a878ac613825fa27dd396bc94363f887b5184684665ee5ee0ac8c580e6629270f993ab32f32b3641952af9d099d7722db1c325667de6d6483c74db5540c4dd27d533a8b5701e7c3089d44e2691a23f9bfff98d4ce1429ff0d88f020d740b8e851a985f9775cd2ffee49b8265b7b40932916a28a2583eeac7c1d3cf663a7fd68e0e424c694e30db4d078568c51c72aef98f2912eb8dcf1fda01f2a34dacce4b538224a12aec0fb51e762aebe34491353cba66c013a1aa246e9d7a8f8ca00a79a2c5d7bb212f7b6e22c12ae906cba2243b5be686c9f75bf07b7f2e359e1394fd7c48ab9ba1777acb9636a9070c9b716e8dad98b4f796a9e3e42e22519844ead3db75fdb953bbcb3766d9a69abb5b47c842796c6060a2bb3fb04163a686a71369c38d484ee607d83d137ecdfb469e6d31fe525c868d663e2c581fc9f94900b182db6f2604e430a1d5d1532c9348ffbefd650770daeaf29c349503dcae0bf39ab97c2bc0549518c6224323326d6d98fb5c8c8b2e449782f155ce1ea198ff9e7f642c6c8e83fb969471353d963ea02b5b2b78918b02f7e08a61a41ca2eb8891cbe381198a1f62dec9cefbf0801d54c3902dda6844522021791ee9029c352b26c04c3d36c7cd815929be6915e126244bc205023a731997fb4bb0c069f9c35289a86938530992a997a0e801794026142a345ba60f6c40245bf34bebf84617213321f920f707936b2050ffebd5f420a5a3dde1bbb2ce51c8519464285c2f75f20441f0bb3b1e3d6eb6b876ba07f909e2e18c5d5e78be47c279ec1d214643feef9cbacee2b033a685be4218d0727f0d82d0c14ffd80529ed85d84fd8606258e525341ff06d5b85d8ca7c8ada086072c461d16ba08f5218ec1e04c2d8b39579aeb6a4a627599ba19a5f885b6f441ce62cbf1a90db98b09d60c1ae88fc7c3632611244f28a0db02a314f5dbaea13ea1d4a610f4b80548175fef2bfcb53470ba443734e60a9256865980e7e21b246e4ce56dce75157ff0f67a9bb79d9857299f60c49bb5e51775cb9fbe617feb878216c83b2cf5948fc4875902ecd8d3d304caf472113df4c77b4fff809bb72ec1ba1235854fde3ebd9f5fa7ee4e9bb3f64d62cc7760bfd6b25e64202b0ac6473dd0d202c915573675fe9c5ddbe61dbd6606231079f0a28223423a42e49a2f9f99ac18bf556d429ae637ddf1c58387ac7030e918460956a2d8b963d9cd57e5325530f604880c174e3c78b9352d43c90c81ebdba6c12b027e619a4e76cad8bb08e697a4ca3347587285663d6c87eb262bab92e20001fa567484240e562279daf8db80ae733bdfcd8d88d817c90f6ec38a215a8ef809caa580660933e971e9284eeea5a9e61ee3125ba4947bbfaa45441954c14c9fd8ff418bb56a937784d5ed73232593023e29dcd24cffe03fba5a6abd85276f6d6ddfbf5883a55cb7b9b3714687ed5c55c3531b37c74857afc77303bf97ea5efdf4b64feb9b43dce39833d80e78846102aa58e841e6dd50590f7b3e5da5f1858f50a5bf43cbfdd76e45456b3872144b3f7c5339188bc73554e148537f9ee89ed88cd770d9ab171e341d8b2134015ba19666c1ef2054eb3462c73e5df83cbe96add0e8a5465a51d635788cf4921399f0a08387f6badd583caf6e3c365b818095c8e70b6d89413b5acc5b3c7d44f351d15d3fddd3a8057002b8684667e0afe8a2d406657dcde5e82c3b0992808fc5549e1c77c78ec6e33de2f8063eedcadecca29389a5b19cdaf434afd976ac3a5c73a251cce6ce738156904a4c45fc7123fbe5855048594b456dccefbcb65540b2c0af1a99d7f4f1cb1f3d05460bb75d0d20a4a1e4e2b37a446ce7c72627efd4970d2c6ed9891b0ca7326c34d21a509bc105de0f6aecb98464c5f79599c18a6215961f152ab5b41f0fa5258de37c4174c031dbca93132048f99357365d314d679a08a5a48f7ec9f2559ea73ea16888b5733054a3bfd0c568eaba8ffc462a34ecfcdf21782955b683cb7440a928099ce32fec662ea25e4d7f0028baa65654b614e7ca239d112a79a6b04a800edb2116c6dd495ea35ea7315d18dd96ebdbf6cd172d73ab489d5f42efe714000064d21614b8289e38cabbbb2186db304d47e5b5f7b2e1c1e0d41e3999a158891e9f4037b658218fae5c6471cacf88a52b395052550673d5fa4a2723741da559eed6a0936ee6aefe7360bb969da1a41a0d86ead3c3d70eb54d1f8b6a6e70803f4ccb9b701ab860c8b7f64112aa7a6b3ec061a810ad19d99aee07f12b70c1004373808d60c47b5ad040ab489233d99f98e23c7ccc02c2abe6010274548a715dee0af6dfce5d0ec3c846e78c2ab07d2e7c78ca71b20a7b2fec1e91469d44f2cfb6ba98227d21ec79390eb14c4529810aa151fa48b48bd41bc4a67b0f54fd760ce599e8fd9c4db536587cd4ab0d56dea3b644082e1e8f40034e7c8ab380437df9b28fe68addd7c402a806e010bf4fb00c733bf4578fcb26bbc8b7270113346578f7896dbb4185c06b0965419c852ac954f9d191769ebb85fba823622f5bfda727f93a3fc0a5009090b585e7255ce27d56b756a9bd1a1f06bb6d460167a5e0792e7fe2198b3cd34c396c4797c8b3b14833e07b2aaad9e80917dfbb903f299f4353e58e95a1a7b95aa3792f68ab5039cf746c37734fc35caac680bcd693891b98a116b1145073e099deb6220933c00deed49b3d71cf0d218a296478b26daf091423b7cf765b4f9b03e58cc6f9b3bcd46d740b49248548ea35ab7450379d2cabb79efbf242597d4b20cd22b9c27b1e07b798cbb11a3105581d8d45e56a7023dd0aa0c637e791c583c72b28e83e1f30c0a9ed45126cf96efc1b199534f7cd0aecc1a4ec4d6f289f80561da5125649d23731c5f5e3da256074489339a5ee2a615c65a6528e893ac50d3bbdc41039646d0b219f0d629bc660bf3258946c7c956f743e257ef9f38d730df3f8045238840a08cad664657971d7e093708b319e5c56a1b74202fdd5347cdad91b0fa8b95dae486c5f69b33214ecce2f2a9e010cb5adb48faf4a1aa51558c604e45314fdcd76a5e96d9aed8c05735f6b2132c5be2ffa9ce3afa6f9c7db4864f9b039215203a311001656391282b00a9efba7cbba6afaa0d780bbd80fd08058fecd63c85224193bebf288852da1dcf9c556a5b70a5746e2c02bb03e23f57168890a90fa33477403e60c17fa1f247a1a1d00d590697d9b2bc3f56ddc33debcb7cc4f0caa0350035489039f867a9defdbd4ce560524f4ee4faaed56f893bc60439f706b1ad384cd1357a7e3097b8b168d215409ba6e05571681ce7d0bead61857d52420279967aba0224eb6d9d3bbb46526eae4731b3cc634e2a60980fea1cd9e080d213acc8ca97cbd4db5f2030fa15bd334850b40592f7a1369b4ac970c2c827f8263e2bf9cc618b11009d5754e3c1090a1ea7dcc193402513b1204037c3e87a892a69ccf65b463f6930b4e1e4c59953137672a5d288d8b39d2bb31288f7c00350b8225d1c4378ae80911da6306321a425a1c5bc87680ff9e7e6020b1ea34551b0fecd2da96cd65447b97ab80e84e1c0519e11f383cf444bf3d87671e4eb4f0f7f25aba13555c23e44b4d816e778ef42c249b26f745d18b7d9ad16408cf1c850eae9c00d16dbc216df787ad2217af96785ad6a3bb9f81709bd119067eb09d728648d64960c9077f6857a55a9ba53293b9dc752917ad6f7b09814db0b8a76c4f5c2f16e760d3744bf748f7570dcb443c2d4cd848e4788a1066cde16d3e207a39c4d84b494db6460b536a51071b74ca41bca5029a01f74944960f2a983dcdf40fe7793f290450f6762cb663460a3ce06e1eeb69ab070da74856b8c09d0a6bd9888f3cc04d634b4ae93b700ad46f3203633036ef7e835de39b321946881b27f03d2f40dae61aacfb2a92e41fde87761ae43ac43b2f0a61c09dd8346b6d0fe4ffb3c17548481ab552c09274456d32e3c06975face538f7ffb50978d0753a52eb19fd09c2ab1a824ec1ffce290ff19fe6f570c799f3e505ed2cb764bf8178a067d5483d1afd00cb4b8b9b4a9592d37836d827d78251661bae87ac381d26427c0adbaa718cf1d6a46f337dc46991b17bee017a32465dc38a8e86e42985db7e9a47a0a1178f32571dcf4b484ca437eb0ac435d3376f8fc34d77beca34df036371945608be068b994306e8a565e9d5e85f735ce0615412759f00adc2bc477fc1794e04c9096f18eb404553c44af223fadc98fe8d7f66f21a56863197f448f64bb6047c78685ffb323dee0c7230715826a7fc1b20ad8f8a0e7cfb9acb31e9735dad9defd4d4acbf50fbc940fa8a507083e9356bd3384040c73dd8ff2bf8014f20dd09b74cdbd1d72cbe9dadb02d863ab7eda30ff1faab22b608e30b40776f8cefb612d7320531b8bbff9bca863c85aeed2fb67b54b98dc934f9016d6b18fa52bd689caf213a3099d01bcff1dd382d77058126ad6f184cab7a0f67e75bf7cd7968a98fb575ff3d8fccdb92265c657c9e9ed287f6ed060740de767581c3924385bb10a8cb4490c349d5fc9a2488260c613e786e39445fdd516ccb4189531a44b31435bee8e7f88ab76eb613fa5fc0650573eb620c0ae02f22a025145bc500c664e50c109bcaebfaf2cfa64e98ac17ceeb389aa0e3f4760830c948fe55e7bf0e0d2a51f764b7c59e3e9f9bb2a3ac055624ae1bacba0521d2187cd87d518f0731889602fb2d7396f6180cd0e467b22302c8e29d64359ee93ba6c442274f731dfbe8d5bbfe63ab7cb4c0d24b9f0eaea6ebb8a86c2ae10795ac611ec284d0c437b1ca7d3cb8439e68abb6e13b5a608ee4dec18da58b4bad4073ed86c261dd3e1caaee50cdb224762e42f5efc305fceb10b14e524d932f7fe32b2b8ba70a92f97a009571f1512d4db92b5055e2507151453da1a3ec57ab962de736b0f6ad1af738a9b404d5e8b3b1d6a852ad88fd42aebdf590eb8343a16216bf387839b5bc2766fb9072883e2a6e43435f8a2423b89bc2c4e6c7c541ea227ca32073894c88fc2a10667c5a4d4aa2b5e482252e3de8ef9734ee0aafe45fbdb9827a84e5bc867b71dbcb6a8d458b6df6424341012e1d9068410dd2c1c383138b2e707ac03c567d9e44b0f4ccc4384b9c0fb08d9d04a3f9d1220857bff2ea1ffc7fcdef7e8bcc0dcff77c23a35298883751e0e81a3e85e2189bc3052559670facfdaf2f7814452b78048b6749f94dd75cc85da6dfd4426b6f81bec6878c5d0c6ee65acc25a15c7d97a3d78b9fcedab35d28d6e1af554517e5da2d2ffbdbaf45bc1e2493cf7d3dad317e50e783decf3c4005a8744ed610ab3cd85b2376a04afe216c10a2d8a6776487e796fe7a4b3d81320b1f7182186e8ebd1feab6349f9b5c25a97dcbec7ca5e26be1c7fe80b696483d08c502c132767266a29383b1d4cfcf34d1e32f106eb2dcd9cd089bd16477aba7b7f022bfc767a52e7d736859a39d76ebc603bc71cbff97c8aa20e033e20b7255dfb3b70c6578d26ebfc3918a7e0359a9f19540a704739dd11463916ceacb3a384c3c0ebb42bc626019b79ba74405e152bf31199e3f70c4022220a53af36bb6eee0366277c2dcea518e4fa21b22e7eaaf7a78880ce2ab629ba72973c7856e023835592f9e8ab86aefa807cce00714d6388b0885cb705ac8620be085db16e0cb40baacbf7ebad2a176c57b6ae61cfd95b5c5bc02f92d552038d0e8ed6b7d091135e5987876203889fecad9fb70a59bd97f38a257c4c72b24152f22c5a5e09a54943f0d71e4a3cd1369a2d14811da8a4bd25cabc8b2bf9ce5deb64093e0928290d940c0f5432e42c63b089f6e0159e8616175775e915d52c765022a8ec2ffab090cbf33c5fa9eeba3faf06debd57ead368b2a3df15b33d9c327aaf3c095c5459ac652617584e7e07c66eda9f76d51de82e61bac08b5b25d426209c3bb183ff6d08305c758c35d57f6423c1691ea5e479e3e5f28a82b12c53c63e4378f0d6293f39904cb1decfd547f11f33a1160806ff30eda8ff688279b979296e70a3f804bdc077d2527ec7b30ae72eb404fe5be762d097d5ae8ab32b692fa33ad7cd89e45283680dbc976f8dba33f9ce640ffbe4ae3d0a24fce24989b29dcc5eeb86e9d94e474bb9ccd52a64bc24a63055c29402026af65453d8503765ef2e60240c0db3fb931396960bdf1c4947cc3a5e0d3b17724bb1b994e1dce790b49d850223cf84dca4f74cdd55324cfa323a80542dd4771f3a4d8920c0a279342ad1023658dde1ea80d3438eb957a776a8f67b11d836c2566ba95442e032a08483b3caf31222cbd5182e71e8ed22223e3bcf2ca50abc7ed7f067ced256233b53ce4da6a879e836026d821d55549e871299de9441834887f6035cec47d339d66b7a2fa70020a4cf23f9dd9ba6929f9539f16034f06c782926425c7c7e86fc530514ee85825c390b928d287c9fef6480f747d37064d19648a089b49e6b9f0f6b97b47e57a2828281a591499fcd0383768cb4fd156d00e7cf30b4db066190c850240396f0dbc54b709b1a1be7b75179dc9d1273c464488b6a7101c70e0e33dbea7ac7160fba1e88c07aab2c92a1ab9b8e94e8971adee4da1604c5c1ddcb8711faebf9627b4373bcaec4be55d1c081867c8728ac7500ef4209635927591b53304627ee785318c8c6c145d444a6068fd8e2564ebb279c7afe157445a4e1e89104bf18562d1331de3e741d07f9929801af5c574e5e33bd0e6f47ca9fdbbeb24558313ec99cfe139ec2c967fb6157ae2a7ff213e34a1d45e70010a065ccdf5737d0aeabac58de86268b0530de3f481520718e4a94074bd644cf2ca41850ee857fc93978b4416df8081148a2ad8ba395fda0cdfd07fa64b5a9ca628f41fafd74360bc29cd14796964002053308388df9741f0df83ab7089cedacfb6c0095c2c805db9c840f694b7aed6d7bbe4238e80f905edfcf597eea589c02ec4fd83d93c6faa3437a9d2fd9f97e8329b3d538cb5b5ba29f6ab0e3cb41f8fbc168fd0919119f5011ed333d615cdc9e52d7e0a376d30f70e84b75ddad3e60b145232ac30bbce171ea676474b875ea7a47477452ec8931eb06fe41bd4fc2d76cf1bfc40f9d2e02d05d32719bc8cda2792912efd5edf3b5299ba6e5039092d90a972403e25c783d4a4a7e50294cb4d371e11b91ec9a4ee1210863525a1781714dc8897433659c122aa7f2cead6b0f41f24936c79cddc7fa4f17f29b4d00eb3fd89c7bb9933a1653baec70d3425cd0898c0597e9316d772a7ad2664de0d937e1628e5ba1487dc39479d37aac01303efd496df386f3384387f3a168216d6c2679ea91e7a09eb0746c613d886c9fd0c9ba9b402a5ed9f889129a827876b29510a3f61852b0c414c30525a1365358f51b4039a04dc6ee73fa3ef84bb1e0d29e57309b42e8916799656fbb8facd7d4b533bb934c7c08e8a8d51e4ed6d2824e480648a902a2491281b8115427c61645246d864a1a2237d7a2ebf2f64bfba4dfe4c21e8d4e5e6e8ba765af8455baeaf0188837374a455ee4947917e0123fdb7f0e01d9e8ffa9c38a8cfb8176d4df029c832137b7d88c3a9c07128d5884100e538c9085f16446fa028c4e1cc0815031ff85b0c1bbd94727623d81e595ae3a1752cc3cf9e75cda5662f2b605b528fa92f69e5a429277a00144a83fd797cb67f259405e69e639549e08c6d0eda4dcdad8666dfbcdaa3e71d415fac854b3e95fa52b419f8f891fdc415f42b848dea17cf3b1fb17c730973a8302fbb5cad653a4c5e0ee72e6c2eca10db59a200e8731bf154fb498a843ef2cf455194ea99cca2edd83b91c045cbc1c196c83a86e4be212b379373ccf9e81e30e527e8bcf40814b3bbc2914f8fc6ce1a60fb3035234b5ab1c55d2c42ddf706a26d2d74a61e050c55187debcddac6ee1b61c24f419f025e380b510b84fbda283e780b82a3fac220284aaf036d10e4daf891a8d230625de0bbd4f8b7c278d07f1403b236ef854f98c716c9359681bff319fb3b269ae8d650a59541ed03926b275ed5b57eb338e07a638d9ecc100a085fc28c82e1ed94ec37f4a55f60db1a5b62eb9ebcdbacaeeb94e8858b6f59032aebe48b719c63bd207a36e276d6e245a9c0d15556f062a0604c9d8ac0624257daf4a00f09503fd5e5a31adf6e55778fd5fca0aea52a6ed0dc4d119431d98e8678b4993efb8eaab0c78448baed5168489890cb194b3acb920b5b66777160b01a503fb4e0951e0740e6dd1bca4a106ba4704d6fb0bcb7a9be2a14b3ea53e66a79bbbc9af38a84929665e6e3ba0827f01048acbbef746f450c5ed6166b17790d74b0873ea6beb76bf3af6629d0e6d37aeda4cd3a6edebad04ef4fda7065f74011ec023b3de6c7ec4540fa035c2369613573db1fd65be628ba6211fb84989431b20901c4a5319d4378426b4b0032f7b767d2668b3eb05016e6abc2a7a1977e2aed46d65abfc513177c6a8044e75731b36781b3386eda163ebb1fbbb07305555acef35bbdc5df5ac2640aac31c6bc95adc6e4112a0534f224aa2ef8ed7bed194707d8cf62595ffb045da02953b427b799873b25ad05423dc51aee345b664c499f60e6c9e502bdf1ecc34ff1d56e7720c9cab31ec26ce7a149e97a5e2a9158bf6818e58ea1af35e0a1871f85b1720c52eae3059b14910cf01992cd6cfda62a64c28071213ca8e48da0822f85748559deb2f8f955895f9c4c8f5e1a8a4054237b502671f2f49fee4d5b1ccd80fc53576189d245ffeab181dc788db192ed6afbfb364ca4e4f0e373bb0e60c5c2828b55a04da17870ba7dadef22063bbda9d771e31553279d96da262e1327ec3fd2b590b53000e33ec64418af1813680ef88008e530d3de838ec3baf586e54c671237effaf7376b743b4e7c06b45acc506f1d1dea6a9c6772cf46555f8e1613fa183b97c5ed671d3375978fda2003bb4a5d22a9e347f98544cb6a016f377de1b1db7c9bbb45437148ef63baa22ad5264609fc71f7177419b89c2b6162dc54a79e6b372acee4b58ae0dcf3d0f3b08f896f1dec654207a6aaf3f9cde5d79ab867d13a03ef4510a14d9fd6be8463b486e6655315a53ebba2c314f1df3364c1976357981a0890de656ce75d7f0d2fd4da55de5687da5c6b69501dbe9a6d66c9c9a82f341decf0d472e66481d22fd7dc20d403be8774494f646c96b5eecea69e632ab61675109adc66d5f8ffa143b2b2ef9e8046ced46c3baf35ebbcc28725133d065d50574fa6e0030f547e0443192ccbaca4b3159ce87153efddc4107e4592acbfb5cdf6cda0a845c4d219d4504e5ef20925ae9b1a356b01fd30002548aa24e9bb36607ce4dbc4f17279fcc44b8b151d61bfa8f8f7694dd1139709a6852294f420e6c24f6a1d5b184a2087552daedc90228eb481aedee4d881b8ff80e069093c955963d20bfba2afa65c5e5782b95b8a47993bb682aa2d3bf98d036265ea60da66640578cb5348dce11de177cb37c2d5306c2bc303b6216b375eed7533e71d6331cb13af25c847c87842a110e2fee15ba3c2dc2a28b1acdac7b2686cc83f43412bb955ff035f918824e768a559587c9f2c841b534ec2c9bdbd9005a37dc3d474a6b3a3f90fb0ff3e794c55fc69d9d4fcce2bdab29063ea1e87c6816a9bc692f910fd28e660224c7b1173d096a120a36adce3405ae863bc614268cf3c2161703ff93cbf699ef551ed407f0d2d0b53b5b8b8f466fc1e601ef6c943ed792200b0da41e2db87ac710cd0ede4b794ffb1d4fbbd98e226f49dea35ccba695dfd21b15d6970df04c385ebac9df6beedf9f0fbb650998cebc5afba19afc631f1d552423f0b567c3d1dab4af8906a4b3532ee3445f82f3d06f0ac8542eb6dd7f8f0afa5620ce265c7e513f39a733c5c30a910d1732a61eb8ff9a73caacc1e478706c0644e577a93b0f84464526bd8ab34e976cf6cfbdf49f9a4224d215cb6f8ee5a46f0bee8e430a3721ba690a7d0c55ea69a05b1cc88fd33999a66e1915ffe5b0bdeb4bf2125943bee502258ab47d787350422d833cd9ba95d61ff7da8296f8d6635c6ab859cd6e252e28d725d7f9cad43c3903855ecc8b6f626045a75328d4917a8ad789390f3ffd86f4e774d9f174b0f5105918216cffed1a952344ac5a17d0daef420e0aa7c26ae4abc8812c78c6c10088ecd53b87321d19889dd9419ff807c98e6a608ff9d685196ab5f3e8574f259ccfcb5d16b68c3d830e98f54dfa05292657d95f004672d60bd9f71a90dfdae413f99cd821a7357197b0a2eebe013e9d9c95f25496e67b25caf61049a4f843284b43258598fcb1a341765ecb17e1289a7c9dd7e5bed8037f33e2839b40219b5e0db4835a53db790ee374d13d04dd7db8168bbd1001333d67b4c986fde166407bc5ffed447ee7d39dcfefe93aef9370e3d1261b91aabf0477ea830f4c0857ab418fbc5d6ff3a6a74e52583784e767692f278b173dd8f19214733d83164da3e762c2844d3852f15b4040228c793972ed3ac4b4e4fb1265d00831ea15d9e6af2daf8604c3720ace6c13cf0c270b089aec483442f4e2fdc278d29bce673f96ca908cab4537c8627a1b260097323ef64149d50401afb3abc9cdc05585d0d3b57a8c0a7db83dbe524b9ba36ab592e2f1f517f84707ffe76b642473b1cca831214f1c15b76657a0557265ca7c06c378901c88330f52052e16ab260760b12feae352df63bb083db8f9d00e3801c9054a8e623f38fa087d9a714ff3792a6aef3cd288fa38c5a484df3695b805077c72cb41b64614b3fa4571ae028fcf931b399b9bca05602753a7e2f59cc3e0a4123128af7735827dc2329b2c1b94b753db0a3a1bfa14522f07778b25bef3937f19a660025c713cc73f061e188a044e51d096a44080c21b1bdd8e17b085aa188cb8f70639b2cd9b665ae7168cf600b95a3322d33b0f6c1d892b7435b060eef7b46ed1c9712d7359d63e0d3ea6aacda600d2be022749c2e288425042c4663b21289fef44b74bf331dcbaa079832f8dfa96ce430cc83cdf1355d70c312754ba5aa95e3c65026a724f02d108ce8f61d4567d2d0b9f94dc1149b3343b1822147d50fea81b314bb1c3c50076ed4527a7560c4c665c3244a935902c3cc718a618526cc806c02cd89b4d378c771da4c92cd88cb2f515b1cc3557d6520d675273864479621abd1a3aab4230696de92da2712c50489f68d14b3646c40deb51c6ef8333da043e78007b6639d7d3b2f88e8bf3af1e6fc77b9050187c742cb9b8ff4c4d0032c5cb57f757d9f454a60bf6f99f50c4d9e3b4eb53193c2bd6a7f6ed67690718a94c92b135c7902791340920129eda1e55a1b56e058c03e94035c9051129e544ecd20ed0f0412300652bb26c64e443669cdc098cd5cd013d9f014c44e7355bbdff2649d2da988d52df34078841b885a2663238b8c9a2ad2e3392129faf02ce73514d195474011ce8c68b2ccf0e895d1ea76e1e3d3803cd07bb4bb2b0418a68caf73f4fb902ac317b7468883f7f1f8b8e7b2cdf50fcdf789c36136b751abb4ca9155a0494351cddfc7320df7e09e58ff894618c73d1c8e8fb0153f435c9fe3b8bd0718a8928d19dabd335c3c135965e798b1bf9df3337b54d935c1e83fd67ec0cd73bc39469fea6cf86ad6b2cde2395ba82bd80c78bf844f7c2d2d7ec00f472382b9db8686481e3bd85c5f4db635433e3ec1067324f365947c73236969586230d29505d10e6423adb1c996ec26dc13cd39e0b4db3a7e7ef631a049e3c1455b3c323d7e3feb3425cb277e1730599414cef82cfd76dd0f23351a56625c380be1ff95a4fb524644d724520f0f7eb9790cac694a9738e057e27ec71b9dcfd3dc09859af847b7ec0c130c32bd55a12bae60b5d284c913b880efd43279bbf9a684042a878ae0f5e3387c5cc13de6db7bec994d0ce761bb21e589af1e454eeab5bb1901a83f12d4347a7711c7f73499cca99b58ad5a0f728f2e9edb15e99c0d52554d1a807307af0330b178512b606a21624aaa45e1cd91d5da4b975af0b03c96d5946112534343853b197c7ba8892ca278f451eb95b0cab11d6898244cec28f174338dfce367f1c27e1893200c6518bb3da47e4f1d9268e04b6ac45fb88b3f5a4186928b98b09cb13219fa5ffbf73cebccc06b7eb3acd71955eab280d638d16ac41385a17b29f7752333c597d56eccda8fb37379b291fc32ff3055c2da2258250a6641fdc0bce822d40a505fe6c1e63749a5aea872ccfb826e06a06b1dd1fac03dfdd85ba010a911747bb2bd597a08b5d8bce6c8af6d8abd31e8a07d47dc8ab8593a09003925ab1b47e6f41bee6ea26dd5c552f691d53691f038e43f2adc7a0144f8bb16321fe130e5035083b4b1f6dbc11d278b08843fed6473e8235524ab63fba131860c8993e195daebb627944f6a0578136eded9ed9fc901fa7e08f4d64df545c474d1b3a04994aa0bd0af61c22d668d97e3d01ac22d85b564968dbd9170caf6ecd1162d2cf010041c2a17875d1853d97cd61264baa6c56049c1fd8869c8b477687aec54a0d525081c7a3bdaea192ad20efec26ab6f3b12c8728a50c30ffc9c80728fd781b2cefdaf66333a64f8300823332c6981f44d3a5d9126cc82b51fbf4bce306e9b8b39a57ad99a77f29c16f7a1828b7327b13245ef7f71d0c4ce8e7605e2a97cd8989a9ae5ee32d38e831eeb6ac8171b302c873a3b2380bf2147f148693b9437d41ecaa3a33a82cb9a60736e88153e0614f5a2c6660aacab5e1b847b62835f9c768c3bf18b3d579e5af5c07fdc66342dca52fa0147c9b67282f0df5b9a430d42fc1bf60caeaa10171c20d628fb548ef35677573bab6ef050781632826b45a63287bae984a0f16aa2dd270ba95f2848cb3f478f198e33a1ae03da724e1f7dcb8bf25ffdf113f9113ed69b790fbddc28b73cffaa354b784ff1f80f518c59b33e964ab5221428648cd153b74ec044706f7190596c939b227962dbfc3a682ced5c13afa648f435ad3997267426edc263655962af291fe47a443b80e10521263c85fe8b28ebd243e30604e07f253a027c7f537ecf245a326f569336e378b21b64f17ef0abe250f1c982e8f5e6b752dba64b6394dd1d1f60d2344c8e8c9f73e3b80017311f670fbde14d57c1690a96655338dfe3e58496ff2d17264cf461da24227309dc2289</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">This blog post requires a password to view.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>数学建模</category>
        <category>聚类分析</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>聚类</tag>
        <tag>Kmeans</tag>
        <tag>Kmeans++</tag>
        <tag>Python</tag>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>数模M02-Kmeans聚类</title>
    <url>/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/M02-Kmeans/</url>
    <content><![CDATA[<h1 id="KMeans聚类法"><a href="#KMeans聚类法" class="headerlink" title="KMeans聚类法"></a>KMeans聚类法</h1><h2 id="一、Kmeans内容"><a href="#一、Kmeans内容" class="headerlink" title="一、Kmeans内容"></a>一、Kmeans内容</h2><blockquote>
<p>Video:~<a href="https://www.bilibili.com/video/BV1qy4y1a7JJ?p=25&amp;vd_source=1437b1798845fbcba4cf09d5a889e546">Bilibili-ln异教徒 <strong>Kmeans</strong></a></p>
</blockquote>
<ul>
<li><p>随机生成k个聚类中心点</p>
<ul>
<li><p>其中k值的确定可以采用“手肘法”，通过分析不同k值下误差平方和(SSE)的值的变化，选取其”肘部“作为合适的聚类数目</p>
<script type="math/tex; mode=display">
SSE = \sum_{i=1}^k\sum_{p\in C_i}|p-m_i|^2</script><p>其中$C_i$是第i个类，p是$C_i$中的样本点，$m_i$是$C_i$的质心($C_i$中所有样本点的均值)，SSE是所有样本的聚类误差，代表了聚类效果的好坏。通过找寻SSE的值的下降幅度剧烈减小的位置来判断合适的k取值</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SSE</span> = <span class="title">funcSSE</span><span class="params">(data,total)</span> % <span class="title">data</span>为数据,<span class="title">total</span>为要划分的类别总数</span></span><br><span class="line">n = <span class="built_in">size</span>(data,<span class="number">2</span>); <span class="comment">% data的ColCount</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:total</span><br><span class="line">    k = <span class="built_in">i</span>;</span><br><span class="line">    [label,c] = kmeans(data,k);</span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">i</span> <span class="comment">% 按照分类数量遍历</span></span><br><span class="line">        loc = <span class="built_in">find</span>(label == <span class="built_in">j</span>) <span class="comment">% 找到每个类别所对应的行标(Row)，形成一个Arr</span></span><br><span class="line">        <span class="keyword">for</span> j2 = <span class="number">1</span>:n <span class="comment">% 按照Col遍历</span></span><br><span class="line">            temp = temp + sum((data(loc,j2)-c(<span class="built_in">j</span>,j2)).^<span class="number">2</span>)</span><br><span class="line">            <span class="comment">% 通过loc得到一个row区域内的所有label与c索引相同的数据</span></span><br><span class="line">            <span class="comment">% 依次loc所对应数据块中的每一列与c同列的数据相减并求点成的平方</span></span><br><span class="line">            <span class="comment">% 随后sum求和处理后每一列loc数据的和并且与先前的其他列数据结果相加</span></span><br><span class="line">            <span class="comment">% 将每一个label相同的data和c的结果再相加，全部用temp承接数值</span></span><br><span class="line">            <span class="comment">% 实际上是将原本每一数据点同其c的减法求平方(距离)过程纵向化了</span></span><br><span class="line">            <span class="comment">% 用于矩阵运算的遍历，以及其最终得到的结果就是每个数据每个坐标的距离</span></span><br><span class="line">            <span class="comment">% 所以可以用这种简单的方法Coding</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    SSE(<span class="built_in">i</span><span class="number">-1</span>) = temp <span class="comment">% 令SSE这个Arr的数值仍然从Index=1开始</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>根据聚类中心点，将数据分为k类。分类的原则是数据离哪个中心点最近就将他分为哪一类别</p>
<ul>
<li><p>距离的判断采用欧式距离(欧几里得距离):</p>
<p>令各类中心为 $\mu_j$ ,计算各个数据到各类中心点的距离为$(x-\mu_j)^2$</p>
</li>
</ul>
</li>
<li><p>根据分好的类别的数据，重新计算聚类的类别中心点</p>
</li>
<li><p>不断重复上述的两步，直到中心点不再变化，得到聚类结果</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% 数据导入</span></span><br><span class="line">data = xlsread(<span class="string">&#x27;./k-means.xlsx&#x27;</span>);</span><br><span class="line"><span class="comment">%% SSE手肘法判断</span></span><br><span class="line">km = <span class="number">10</span>; <span class="comment">% 所需的k最大测试值</span></span><br><span class="line">SSE = funcSSE(data,km);</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">2</span>:km,SSE)</span><br><span class="line">k = <span class="number">5</span>; <span class="comment">% 选择 k=5</span></span><br><span class="line"><span class="comment">%% Kmeans聚类</span></span><br><span class="line">[label,center] = kmeans(data,k)</span><br><span class="line"><span class="comment">%% DispPlot</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">scatter</span>(<span class="number">0</span>,data(label==<span class="number">1</span>),<span class="string">&#x27;cyan&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">scatter</span>(<span class="number">0</span>,data(label==<span class="number">2</span>),<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">scatter</span>(<span class="number">0</span>,data(label==<span class="number">3</span>),<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"><span class="built_in">scatter</span>(<span class="number">0</span>,data(label==<span class="number">4</span>),<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="built_in">scatter</span>(<span class="number">0</span>,data(label==<span class="number">5</span>),<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:k</span><br><span class="line">    <span class="built_in">plot</span>([<span class="number">-0.1</span>,<span class="number">0.1</span>],[center(<span class="built_in">i</span>),center(<span class="built_in">i</span>)],<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">xlim([<span class="number">-1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、Python可使用代码"><a href="#二、Python可使用代码" class="headerlink" title="二、Python可使用代码"></a>二、Python可使用代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> sklearn</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;Consolas&#x27;</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Consolas&#x27;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机数据</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.seed(<span class="number">66</span>)</span><br><span class="line">x = [random.randint(<span class="number">1</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line">y = [random.randint(<span class="number">1</span>,<span class="number">100</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line">data=<span class="built_in">list</span>(<span class="built_in">zip</span>(x,y))</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df.columns = [<span class="string">&#x27;v1&#x27;</span>, <span class="string">&#x27;v2&#x27;</span>]</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手肘法判断图</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> silhouette_score</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line">score01 = [ ]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">7</span>):</span><br><span class="line">    km1 = KMeans(n_clusters=i, random_state=<span class="number">42</span>)</span><br><span class="line">    kcat1 = km1.fit_predict(df)</span><br><span class="line">    score = silhouette_score(df, kcat1)</span><br><span class="line">    score01.append(score)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">7</span>),score01)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">n = <span class="number">4</span></span><br><span class="line">km = KMeans(n_clusters=n, random_state=<span class="number">42</span>)</span><br><span class="line">km.fit(df)</span><br><span class="line">centers = km.cluster_centers_</span><br><span class="line"><span class="built_in">print</span>(centers)</span><br><span class="line">kcat = km.predict(df)</span><br><span class="line">df_cat = pd.concat([df,pd.DataFrame(kcat)],axis=<span class="number">1</span>)</span><br><span class="line">df_cat.columns = <span class="built_in">list</span>(df.columns) + [<span class="string">&#x27;Cate&#x27;</span>]</span><br><span class="line">df_cat.head()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colorg1 = [<span class="string">&#x27;#1f77b4&#x27;</span>, <span class="string">&#x27;#2ca02c&#x27;</span>, <span class="string">&#x27;#ff7f0e&#x27;</span>, <span class="string">&#x27;#7f7f7f&#x27;</span>, <span class="string">&#x27;#9467bd&#x27;</span>]</span><br><span class="line">colorg2 = [<span class="string">&#x27;#2ecc71&#x27;</span>, <span class="string">&#x27;#3498db&#x27;</span>, <span class="string">&#x27;#e74c3c&#x27;</span>, <span class="string">&#x27;#9b59b6&#x27;</span>, <span class="string">&#x27;#f39c12&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    plt.scatter(df_cat[df_cat[<span class="string">&#x27;Cate&#x27;</span>] == i].iloc[:,<span class="number">0</span>],</span><br><span class="line">                df_cat[df_cat[<span class="string">&#x27;Cate&#x27;</span>] == i].iloc[:,<span class="number">1</span>],</span><br><span class="line">                label = <span class="string">f&#x27;Cate<span class="subst">&#123;i&#125;</span>&#x27;</span>,color = colorg1[i],)</span><br><span class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> df_cat[df_cat[<span class="string">&#x27;Cate&#x27;</span>] == i].iterrows():</span><br><span class="line">        plt.plot([row[<span class="string">&#x27;v1&#x27;</span>], centers[i, <span class="number">0</span>]], [row[<span class="string">&#x27;v2&#x27;</span>], centers[i, <span class="number">1</span>]], color=colorg1[i])</span><br><span class="line"></span><br><span class="line">plt.scatter(centers[:,<span class="number">0</span>],centers[:,<span class="number">1</span>],color = <span class="string">&#x27;r&#x27;</span>, s = <span class="number">100</span>, zorder = <span class="number">5</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;KMeans Result&#x27;</span>,size = <span class="number">20</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;V1&#x27;</span>, size = <span class="number">15</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;V2&#x27;</span>, size = <span class="number">15</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.savefig(<span class="string">r&#x27;./PIC.svg&#x27;</span>,dpi=<span class="number">500</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_cat.to_csv(<span class="string">r&#x27;./kmoutput.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="三、Python展开Kmeans聚类"><a href="#三、Python展开Kmeans聚类" class="headerlink" title="三、Python展开Kmeans聚类"></a>三、Python展开Kmeans聚类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成测试数据</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">1</span>)</span><br><span class="line">kdatax = [random.randint(<span class="number">1</span>,<span class="number">30</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)]</span><br><span class="line">kdatay = [random.randint(<span class="number">1</span>,<span class="number">30</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)]</span><br><span class="line">kdata = pd.DataFrame([kdatax,kdatay]).transpose()</span><br><span class="line">plt.plot(kdata.iloc[:,<span class="number">0</span>], kdata.iloc[:,<span class="number">1</span>], <span class="string">&#x27;ro&#x27;</span>)</span><br><span class="line">kdata.head()</span><br><span class="line"></span><br><span class="line">colorg1 = [<span class="string">&#x27;#1f77b4&#x27;</span>, <span class="string">&#x27;#2ca02c&#x27;</span>, <span class="string">&#x27;#ff7f0e&#x27;</span>, <span class="string">&#x27;#7f7f7f&#x27;</span>, <span class="string">&#x27;#9467bd&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">kdata, cen, ax, k</span>):</span><br><span class="line">    plt.plot()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Dep</span>(<span class="params">ax, t, cen,</span>):</span><br><span class="line">    pls = [ ]</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> t:</span><br><span class="line">        dval = [ ]</span><br><span class="line">        dsum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cen)):</span><br><span class="line">            dval.append(np.sqrt(<span class="built_in">sum</span>((cen[i] - d)**<span class="number">2</span>)))</span><br><span class="line">        place =  dval.index(<span class="built_in">min</span>(dval))</span><br><span class="line">        pls.append(place)</span><br><span class="line">    <span class="keyword">return</span> pls</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Init_cen</span>(<span class="params">kdata, k, ax</span>):</span><br><span class="line">    centers = [ ]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        subcenters = [ ]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ax):</span><br><span class="line">            maxval = (kdata.iloc[:,i].<span class="built_in">max</span>())</span><br><span class="line">            minval = (kdata.iloc[:,i].<span class="built_in">min</span>())</span><br><span class="line">            subcenters.append(random.randint(minval,maxval))</span><br><span class="line">        centers.append(subcenters)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Init:&#x27;</span>,centers)</span><br><span class="line">    <span class="keyword">return</span> centers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">KmeansH</span>(<span class="params">kdata, k, seed = <span class="number">0</span>,centers= [<span class="number">0</span>],co = <span class="number">0</span>, ax = <span class="number">0</span>, karray = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span> ax ==<span class="number">0</span>:</span><br><span class="line">        ax = <span class="built_in">len</span>(kdata.columns)</span><br><span class="line">        karray = np.array(kdata)</span><br><span class="line">        <span class="keyword">if</span> seed !=<span class="number">0</span>:</span><br><span class="line">            random.seed(seed)</span><br><span class="line">    <span class="keyword">if</span> co == <span class="number">0</span>:</span><br><span class="line">        centers = Init_cen(kdata, k, ax)</span><br><span class="line">        co = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        co += <span class="number">1</span></span><br><span class="line">    label = Dep(ax, karray, centers)</span><br><span class="line">    kdatanew = pd.concat((kdata,pd.DataFrame(label)),axis=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    cn1 = [ ]     </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        cn2 = [ ]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(ax):</span><br><span class="line">            cn2.append(np.mean(kdatanew[kdatanew.iloc[:,ax]==i].iloc[:,j]))</span><br><span class="line">        cn1.append(cn2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(co,centers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>((np.array(cn1) - np.array(centers)).<span class="built_in">sum</span>()) &lt;= <span class="number">1e-9</span>:</span><br><span class="line">        random.seed()</span><br><span class="line">        <span class="keyword">return</span> kdatanew</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> KmeansH(kdata, k, seed,cn1 , co, ax, karray)</span><br><span class="line">    </span><br><span class="line">k=<span class="number">4</span></span><br><span class="line">kdatak = KmeansH(kdata,k,<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">centers = pd.DataFrame([[<span class="number">25.0</span>, <span class="number">10.416666666666666</span>], [<span class="number">9.555555555555555</span>, <span class="number">24.666666666666668</span>], [<span class="number">14.166666666666666</span>, <span class="number">10.0</span>], [<span class="number">3.0</span>, <span class="number">5.333333333333333</span>]])</span><br><span class="line">centers</span><br><span class="line"></span><br><span class="line">colorg1 = [<span class="string">&#x27;#1f77b4&#x27;</span>, <span class="string">&#x27;#2ca02c&#x27;</span>, <span class="string">&#x27;#ff7f0e&#x27;</span>, <span class="string">&#x27;#7f7f7f&#x27;</span>, <span class="string">&#x27;#9467bd&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line"></span><br><span class="line">    plt.plot(kdatak[kdatak.iloc[:,<span class="number">2</span>]==i].iloc[:,<span class="number">0</span>],</span><br><span class="line">             kdatak[kdatak.iloc[:,<span class="number">2</span>]==i].iloc[:,<span class="number">1</span>],</span><br><span class="line">             <span class="string">&#x27;o&#x27;</span>,color = colorg1[i])</span><br><span class="line"></span><br><span class="line">plt.plot(centers.iloc[:,<span class="number">0</span>],centers.iloc[:,<span class="number">1</span>],<span class="string">&#x27;r*&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数学建模</category>
        <category>聚类分析</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>聚类</tag>
        <tag>Kmeans</tag>
        <tag>Kmeans++</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>TestDoc</title>
    <url>/test/b01-test/</url>
    <content><![CDATA[<h3 id="TestDoc"><a href="#TestDoc" class="headerlink" title="TestDoc"></a>TestDoc</h3><p>这是一篇测试文章，选用的内容为数学建模插值的内容：</p>
<iframe src="//player.bilibili.com/player.html?aid=824706868&bvid=BV1ig4y1M7z6&cid=1088440765&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><p>[toc]</p>
<h2 id="一、插值定义"><a href="#一、插值定义" class="headerlink" title="一、插值定义"></a>一、插值定义</h2><p>数据处理问题：在平面上给定一组离散点列，要求一条曲线把这些点依次连接起来，称之为插值</p>
<p><strong>注意！</strong>此部分出现了大量不同的有关矩阵的函数运算方法，不同的运算方法之间对行标和列标的对应不同，最好在使用之前用<code>size()</code>方法看清相应的大小和对应关系，再进行操作！</p>
<h2 id="二、常见插值方法"><a href="#二、常见插值方法" class="headerlink" title="二、常见插值方法"></a>二、常见插值方法</h2><p>已知$n+1$个点$(x_i,y_i)\ (i=0,1,…,n)$，下面求各种插值函数</p>
<h3 id="（一）分段线性插值"><a href="#（一）分段线性插值" class="headerlink" title="（一）分段线性插值"></a>（一）分段线性插值</h3><p>将两个相邻的节点用直线连接起来，如此形成的一条折线就是分段线性插值函数，记作$I<em>n(x)$，它满足$I_n(x_i)=y_i$，且$I_n(x)$在每一个小区间$[x_i,x</em>{i+1}]$上是线性函数   $(i=0,1,…,n)$</p>
<p>$I<em>n(x)$可以表示为$I_n(x)\sum\limits^n</em>{i=0}y_il_i(x)$，其中</p>
<script type="math/tex; mode=display">
l_i(x)=\begin{cases}
\dfrac{x-x_{i-1}}{x_i-x_{i-1}},\quad x\in[x_{i-1},x_i]\ (i\ne 0)\\\\
\dfrac{x-x_{i+1}}{x_i-x_{i+1}},\quad x\in[x_i,x_{i+1}]\ (i\ne n)\\\\
\quad\ \ \ 0\quad\quad\,,\quad \rm Others
\end{cases}</script><p>$I_n(x)$有较好的收敛性，即对于$x\in[a,b]$，有</p>
<script type="math/tex; mode=display">
\lim_{n\to\infty}I_n(x) = f(x)</script><p>用$I_n(x)$计算x点的插值时，只用到x左右的两个节点，计算量与节点个数n无关。但n越大，分段越多，插值误差越小。实际上用函数表做插值计算时，分段线性插值就足够了，如：数学、物理重用的特殊函数表，数理统计中用的概率分布表等等</p>
<h3 id="（二）拉格朗日插值多项式"><a href="#（二）拉格朗日插值多项式" class="headerlink" title="（二）拉格朗日插值多项式"></a>（二）拉格朗日插值多项式</h3><p>拉格朗日插值的基函数为</p>
<script type="math/tex; mode=display">
\begin{align}
l_i(x) &= \dfrac{(x-x_0)\cdots(x-x_{i-1})(x-x_{i+1})\cdots(x-x_n)}{(x_i-x_0)\cdots(x_i-x_{i-1})(x_i-x_{i+1})\cdots(x_i-x_n)}\\\\
&={\prod^n_{j=0}}\limits_{j\ne i}\frac{x-x_j}{x_i-x_j}\quad(i=0,1,\cdots,n)
\end{align}</script><p>其中$l_i(x)$是n次多项式，满足</p>
<script type="math/tex; mode=display">
l_i(x_j)=
\begin{cases}
0\ ,\quad j \ne i\\
1\ ,\quad j = i
\end{cases}</script><blockquote>
<p>i,j相同时，$l_i(x)$式上下一致，结果为1</p>
<p>i,j不同时，$l<em>i(x)$中一定存在$(x_j-x</em>?)=0$，结果为0</p>
</blockquote>
<p>拉格朗日插值函数：</p>
<script type="math/tex; mode=display">
L_n(x) = \sum_{i=0}^n y_il_i(x)=\sum_{i=0}^ny_i\left({\prod^n_{j=0}}\limits_{j\ne i}\dfrac{x-x_j}{x_i-x_j}\right)\quad(i=0,1,\cdots,n)</script><h3 id="（三）样条插值"><a href="#（三）样条插值" class="headerlink" title="（三）样条插值"></a>（三）样条插值</h3><p>部分问题对所得插值函数的光滑性有较高的要求，不仅要连续，而且要有连续的曲率</p>
<p>样条（Spline）原指富有弹性的细木条或金属条。利用将已知点连接成一条光滑曲线（称为样条曲线），并使连接点处具有连续的曲率，三次样条插值就是如此抽象出来的</p>
<p>数学上将具有一定光滑性的分段多项式称为样条函数。具体来说，给定区间[a,b]的一个分划</p>
<script type="math/tex; mode=display">
\Delta:a=x_0<x_1<\cdots<x_{n-1}<x_n=b</script><p>如果函数S(x)满足</p>
<ul>
<li>在每一个小区间$[x<em>i,x</em>{i+1}]\ (i = 0,1,\cdots,n-1)$上S(x)是m次多项式</li>
<li>S(x)在$[a,b]$上具有m-1阶连续导数</li>
</ul>
<p>则称S(x)为关于分划$\Delta$的m次样条函数，其图形为m次样条曲线。显然，折现是依次样条曲线</p>
<h2 id="三、MATLAB插值工具箱-notebook-with-decorative-cover"><a href="#三、MATLAB插值工具箱-notebook-with-decorative-cover" class="headerlink" title="三、MATLAB插值工具箱:notebook_with_decorative_cover:"></a>三、MATLAB插值工具箱:notebook_with_decorative_cover:</h2><h3 id="（一）一维插值函数-interp1"><a href="#（一）一维插值函数-interp1" class="headerlink" title="（一）一维插值函数 interp1()"></a>（一）一维插值函数 interp1()</h3><p>Code : <code>&lt;ValName&gt; = interp1(x0, y0, x, &lt;method&gt;)</code></p>
<p>其中<code>&lt;method&gt;</code>指插值的方法，默认为线性插值(‘linear’)，其可选值有：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>&lt; method &gt;</th>
<th>Description</th>
<th>Sp</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘linear’</td>
<td>线性插值</td>
<td>None</td>
</tr>
<tr>
<td>‘nearest’</td>
<td>最近项目插值</td>
<td>None</td>
</tr>
<tr>
<td>‘spline’</td>
<td>立方(三次)样条插值</td>
<td>保证函数平滑</td>
</tr>
<tr>
<td>‘cubic’</td>
<td>立方(三次)插值</td>
<td>保持函数凸凹性</td>
</tr>
</tbody>
</table>
</div>
<p>其中所有的插值方法都要求x0是单调的</p>
<p>当x0为等距的时候可以使用快速插值法</p>
<blockquote>
<p>method格式：<code>&#39;*linear&#39;</code> , <code>&#39;*nearest&#39;</code> , <code>&#39;*spline&#39;</code> , <code>&#39;*cubic&#39;</code></p>
</blockquote>
<h3 id="（二）一维三次样条插值"><a href="#（二）一维三次样条插值" class="headerlink" title="（二）一维三次样条插值"></a>（二）一维三次样条插值</h3><p>CodeStyle01 : <code>&lt;ValName&gt; = interp1(x0, y0, x, &#39;spline&#39;)</code></p>
<p>CodeStyle02 : <code>&lt;ValName&gt; = spline(x0, y0, x)</code></p>
<p><em>Recommand </em>: <strong>csape()</strong></p>
<p>CodeStyle03 : <code>pp = csape(x0, y0, &lt;conds&gt;)</code></p>
<p>​                         <code>&lt;ValName&gt; = fnval(pp, x)</code></p>
<p>CodeStyle04 : <code>pp = csape(x0, y0, &lt;conds&gt;, &lt;valconds&gt;)</code></p>
<p>​                         <code>&lt;ValName&gt; = fnval(pp, x)</code></p>
<p>提倡使用函数csape，其返回值是pp形式，为了求出插值点的函数值，需要调用函数fnval</p>
<p><code>pp = csape(x0, y0)</code>使用默认的边界条件（Lagrange边界条件）</p>
<p><code>&lt;conds&gt;</code>为指定插值的边界条件，可选值如下</p>
<blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>&lt; conds &gt;</th>
<th>Description</th>
<th>&lt; valconds &gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘complete’</td>
<td>边界为一阶导数</td>
<td>需提供</td>
</tr>
<tr>
<td>‘not-a-knot’</td>
<td>非扭结条件</td>
<td></td>
</tr>
<tr>
<td>‘periodic’</td>
<td>周期条件</td>
<td></td>
</tr>
<tr>
<td>‘second’</td>
<td>边界为二阶导数(缺省值为[0,0])</td>
<td>需提供</td>
</tr>
<tr>
<td>‘variational’</td>
<td>设置边界的二阶导数值为[0,0]</td>
<td>对于一些特殊的边界条件，可以通过conds的一个1$\times$2矩阵来表示，conds元素的取值为0,1,2</td>
</tr>
</tbody>
</table>
</div>
<p><strong><em>Eg:</em></strong> <code>conds = [2,1]</code> 左边界是二阶导数，右边界是一阶导数，相应的值由valconds给出</p>
<p><code>&lt;valconds&gt;</code>为<code>&lt;conds&gt;</code>方法所需的值，若不填写则按照缺省情况处理</p>
</blockquote>
<p><a href="# Eg5.1  机床加工">Eg5.1  机床加工</a></p>
<h3 id="（三）二维插值"><a href="#（三）二维插值" class="headerlink" title="（三）二维插值"></a>（三）二维插值</h3><h4 id="1-插值节点为网格节点"><a href="#1-插值节点为网格节点" class="headerlink" title="1. 插值节点为网格节点"></a>1. 插值节点为网格节点</h4><p>已知m$\times$n个节点：$(x<em>i,y_j,z</em>{ij})\ (i = 1,2,\cdots,m;\ j=1,2,\cdots,n)$，</p>
<p>且$x_1&lt;\cdots&lt;x_m;\ y_1&lt;\cdots&lt;y_n$</p>
<p>求点$(x, y)$处的插值</p>
<h5 id="（1）二维插值函数"><a href="#（1）二维插值函数" class="headerlink" title="（1）二维插值函数"></a>（1）二维插值函数</h5><p>Code : <code>&lt;ValName&gt; = interp2(x0, y0, z0, x, y, &lt;method&gt;)</code></p>
<p>其中<code>&lt;method&gt;</code>指插值的方法，同一维的参数相同</p>
<p><strong>x0,y0</strong>分别为<strong>m</strong>维和<strong>n</strong>维向量，表示节点，<strong>z0为n$\times$m维度矩阵</strong>，表示节点的值，x,y为一维数组，指插值点，</p>
<p>x与y应当是方向不同的向量，即一个是行向量，一个是列向量（y需要转置）</p>
<p>输出内容为矩阵，Row=y的维数，Col=x的维数，表示得到的插值</p>
<h5 id="（2）二维三次样条插值"><a href="#（2）二维三次样条插值" class="headerlink" title="（2）二维三次样条插值"></a>（2）二维三次样条插值</h5><p>Code : <code>pp = csape(&#123;x0, y0&#125;, z0, conds, valconds)</code></p>
<p>​            <code>&lt;ValName&gt; = fnval(pp, &#123;x, y&#125;)</code></p>
<p>对其内容的解释同上</p>
<h5 id="（3）显示相应的三维网格图"><a href="#（3）显示相应的三维网格图" class="headerlink" title="（3）显示相应的三维网格图"></a>（3）显示相应的三维网格图</h5><p>Code : <code>mesh(y,x,z)</code></p>
<p>mesh函数的x为列，y为行，需要将xy反写</p>
<p><a href="# Eg5.3 丘陵曲面最高点">Eg5.3 丘陵曲面最高点</a></p>
<h4 id="2-插值节点为散乱节点"><a href="#2-插值节点为散乱节点" class="headerlink" title="2. 插值节点为散乱节点"></a>2. 插值节点为散乱节点</h4><p>已知n个节点$(x_i,y_i,z_i)\ (i=1,2,\cdots,n)$，求点$(x,y)$处的插值z</p>
<p>Code：<code>&lt;ValName&gt; = griddata(x, y, z, XI, YI)</code></p>
<p>其中x、y、z均为n维向量，指明所给出数据的横坐标、纵坐标和竖坐标 </p>
<p>向量XI、YI是给定的网格点的横坐标和纵坐标</p>
<p>返回值<code>&lt;ValName&gt;</code>为网格(XI, YI)处的函数值，但是<strong>行为YI，列为XI</strong>，进行mesh的时候不需要反转XY</p>
<p>XI与YI应当是方向不同的向量，一行一列（YI需要转置）</p>
<blockquote>
<p>MATLAB中插值时，外插值是不确定的，可以使用混合插值的方法，把不确定的插值换成最近点的插值结果</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">ZI1=griddata(x,y,z,XI,YI&#x27;,<span class="string">&#x27;cubic&#x27;</span>); <span class="comment">%立方插值</span></span><br><span class="line">ZI2=griddata(x,y,z,XI,YI&#x27;,<span class="string">&#x27;nearest&#x27;</span>); <span class="comment">%最近点插值</span></span><br><span class="line">ZI = ZI1; <span class="comment">%</span></span><br><span class="line">ZI(<span class="built_in">isnan</span>(ZI1)) = ZI2(<span class="built_in">isnan</span>(ZI1));</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h2 id="四、实战例题"><a href="#四、实战例题" class="headerlink" title="四、实战例题"></a>四、实战例题</h2><h4 id="Eg5-1-机床加工"><a href="#Eg5-1-机床加工" class="headerlink" title="Eg5.1  机床加工"></a>Eg5.1  机床加工</h4><blockquote>
<p>待加工零件的外形根据工艺要求由一组数据$(x,y)$给出（在平面情况下），用程控铣床加工时每一刀只能沿$x$方向和$y$方向走非常小的一步，这就需要从已知数据得到加工所要求的步长很小的$(x,y)$坐标。<br>Data中给出的$x,y$数据位于机翼断面的下轮廓线上，假设需要得到$x$坐标==每改变0.1时==的$y$坐标。试完成加工所需数据，==画出曲线==，并==求出$x=0$处的曲线斜率和$13\le x\le15$范围内y的最小值==。要求用==分段线性==和==三次样条==两种插值方法计算。</p>
</blockquote>
<p>Data：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center">0</th>
<th style="text-align:center">3</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
<th style="text-align:center">13</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>y</strong></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1.2</td>
<td style="text-align:center">1.7</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">2.1</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">1.8</td>
<td style="text-align:center">1.2</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">1.6</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% Data:</span></span><br><span class="line">x0 = [<span class="number">0</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>];</span><br><span class="line">y0 = [<span class="number">0</span> <span class="number">1.2</span> <span class="number">1.7</span> <span class="number">2.0</span> <span class="number">2.1</span> <span class="number">2.0</span> <span class="number">1.8</span> <span class="number">1.2</span> <span class="number">1.0</span> <span class="number">1.6</span>];</span><br><span class="line">x = [<span class="built_in">min</span>(x0):<span class="number">0.1</span>:<span class="built_in">max</span>(x0)];</span><br><span class="line"><span class="comment">%% Linear</span></span><br><span class="line">y_linear = interp1(x0, y0, x);</span><br><span class="line"><span class="comment">%% Spline</span></span><br><span class="line">y_spline = interp1(x0, y0, x, <span class="string">&#x27;spline&#x27;</span>);</span><br><span class="line">pp_lagrange = csape(x0, y0);</span><br><span class="line">y_spline_lagrange = fnval(pp_lagrange, x);</span><br><span class="line">pp_second = csape(x0, y0, <span class="string">&#x27;second&#x27;</span>);</span><br><span class="line">y_spline_second = fnval(pp_second, x);</span><br><span class="line"><span class="comment">%% DispFigure</span></span><br><span class="line"><span class="comment">% linear</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Position&#x27;</span>, [<span class="number">800</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">800</span>]);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y_linear, <span class="string">&#x27;r&#x27;</span>,x0, y0,<span class="string">&#x27;bp&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Interp1-Linear&#x27;</span>)</span><br><span class="line"><span class="comment">% spline</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y_spline, <span class="string">&#x27;r&#x27;</span>,x0, y0,<span class="string">&#x27;bp&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Interp1-Spline&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y_spline_lagrange, <span class="string">&#x27;r&#x27;</span>,x0, y0,<span class="string">&#x27;bp&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Csape-Lagrange&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y_spline_second, <span class="string">&#x27;r&#x27;</span>,x0, y0,<span class="string">&#x27;bp&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;Csape-Second&#x27;</span>)</span><br><span class="line"><span class="comment">%% Other Tasks</span></span><br><span class="line"><span class="comment">% 求x=0处的斜率</span></span><br><span class="line">dx = diff(x); <span class="comment">% diff逐差函数</span></span><br><span class="line">dy = diff(y_spline_lagrange);</span><br><span class="line">dy_dx = dy./dx;</span><br><span class="line">dy_dx_0 = dy_dx(<span class="number">1</span>);</span><br><span class="line"><span class="comment">% 求13~15范围内y的最小值</span></span><br><span class="line">ymin = <span class="built_in">min</span>(y_spline_lagrange(<span class="number">131</span>:<span class="number">151</span>)); <span class="comment">% 找出ymin</span></span><br><span class="line">yloc = <span class="built_in">find</span>(y_spline_lagrange == ymin); <span class="comment">% find ymin的index</span></span><br><span class="line">xloc = x(yloc); <span class="comment">% 用ymin的index定位xloc</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;k(0) = &#x27;</span> num2str(dy_dx_0)])</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;xloc: &#x27;</span> num2str(xloc)])</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;ymin: &#x27;</span> num2str(ymin)])</span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k(0) = 0.49716</span><br><span class="line">xloc: 13.8</span><br><span class="line">ymin: 0.98511</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="F:/LeaG/Mathematical Modeling/Program/预测模型/01插值/output/eg51output.jpg" style="zoom: 50%;" /></p>
<h4 id="Eg5-2-求速度曲线的位移"><a href="#Eg5-2-求速度曲线的位移" class="headerlink" title="Eg5.2 求速度曲线的位移"></a>Eg5.2 求速度曲线的位移</h4><blockquote>
<p>已知速度曲线$v(t)$上的四个数据点如下表，用三次样条插值求位移</p>
<script type="math/tex; mode=display">
S = \int_{0.15}^{0.18}v(t)\,{\rm d}t</script></blockquote>
<p>Data:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$t$</th>
<th>0.15</th>
<th>0.16</th>
<th>0.17</th>
<th>0.18</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>$v(t)$</strong></td>
<td>3.5</td>
<td>1.5</td>
<td>2.5</td>
<td>2.8</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% DataLoad</span></span><br><span class="line">t0 = <span class="number">0.15</span>:<span class="number">0.01</span>:<span class="number">0.18</span>;</span><br><span class="line">v0 = [<span class="number">3.5</span>,<span class="number">1.5</span>,<span class="number">2.5</span>,<span class="number">2.8</span>];</span><br><span class="line"><span class="comment">%% Spline</span></span><br><span class="line">pp = csape(t0, v0); <span class="comment">% 使用默认边界条件Lagrange</span></span><br><span class="line">format long g <span class="comment">% 设置长小数格式</span></span><br><span class="line">xs = pp.coefs <span class="comment">% 显示每个区间上三次多项式的系数</span></span><br><span class="line">s = integral(@(t)ppval(pp,t),<span class="number">0.15</span>,<span class="number">0.18</span>) <span class="comment">% 求数值积分</span></span><br><span class="line">    <span class="comment">% @(t) 为匿名函数的书写格式 </span></span><br><span class="line">    <span class="comment">% integral(fx,xmin,ymin) 求数值积分</span></span><br><span class="line">        <span class="comment">% 使用全局自适应积分和默认误差容限在 xmin 至 xmax 间以数值形式为函数</span></span><br><span class="line">    <span class="comment">% ppval(pp,xq)计算分段多项式:查询点 xq 处计算分段多项式 pp</span></span><br><span class="line">format <span class="comment">% 恢复短小数小时格式</span></span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xs =     -616666.666666667                     33500         -473.333333333334                       3.5</span><br><span class="line">         -616666.666666667                     15000          11.6666666666671                       1.5</span><br><span class="line">         -616666.666666668         -3499.99999999999          126.666666666667                       2.5</span><br><span class="line">s =0.068625</span><br></pre></td></tr></table></figure>
<h4 id="Eg5-3-丘陵曲面最高点"><a href="#Eg5-3-丘陵曲面最高点" class="headerlink" title="Eg5.3 丘陵曲面最高点"></a>Eg5.3 丘陵曲面最高点</h4><blockquote>
<p>在一丘陵地带测量高程，==x和y方向每隔100米==测一个点，得高程如表，试插值一==曲面==，确定合适的模型，并由此找出==最高点和该点的高程==</p>
</blockquote>
<p>Data:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">y\x</th>
<th style="text-align:center">100</th>
<th style="text-align:center">200</th>
<th style="text-align:center">300</th>
<th style="text-align:center">400</th>
<th style="text-align:center">500</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>100</strong></td>
<td style="text-align:center">636</td>
<td style="text-align:center">697</td>
<td style="text-align:center">624</td>
<td style="text-align:center">478</td>
<td style="text-align:center">450</td>
</tr>
<tr>
<td style="text-align:center"><strong>200</strong></td>
<td style="text-align:center">698</td>
<td style="text-align:center">712</td>
<td style="text-align:center">630</td>
<td style="text-align:center">478</td>
<td style="text-align:center">420</td>
</tr>
<tr>
<td style="text-align:center"><strong>300</strong></td>
<td style="text-align:center">680</td>
<td style="text-align:center">674</td>
<td style="text-align:center">598</td>
<td style="text-align:center">412</td>
<td style="text-align:center">400</td>
</tr>
<tr>
<td style="text-align:center"><strong>400</strong></td>
<td style="text-align:center">662</td>
<td style="text-align:center">626</td>
<td style="text-align:center">552</td>
<td style="text-align:center">334</td>
<td style="text-align:center">310</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意此处直接列写矩阵，则xy与正常的对应相反</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% DataLoad</span></span><br><span class="line">x0 = <span class="number">100</span>:<span class="number">100</span>:<span class="number">500</span>;</span><br><span class="line">y0 = <span class="number">100</span>:<span class="number">100</span>:<span class="number">400</span>;</span><br><span class="line">z0 = [<span class="number">636</span> <span class="number">697</span> <span class="number">624</span> <span class="number">478</span> <span class="number">450</span></span><br><span class="line">      <span class="number">698</span> <span class="number">712</span> <span class="number">630</span> <span class="number">478</span> <span class="number">420</span></span><br><span class="line">      <span class="number">680</span> <span class="number">674</span> <span class="number">598</span> <span class="number">412</span> <span class="number">400</span></span><br><span class="line">      <span class="number">662</span> <span class="number">626</span> <span class="number">552</span> <span class="number">334</span> <span class="number">310</span>]&#x27;;</span><br><span class="line"><span class="comment">% 此处的z0两坐标方向交叉，需要转置</span></span><br><span class="line">step = <span class="number">5</span>;</span><br><span class="line">x = <span class="number">100</span>:step:<span class="number">500</span>;</span><br><span class="line">y = <span class="number">100</span>:step:<span class="number">400</span>;</span><br><span class="line"><span class="comment">%% interp</span></span><br><span class="line"><span class="comment">% interp2要求矩阵和向量交叉对应，且y为列向量</span></span><br><span class="line">z1 = interp2(x0,y0,z0&#x27;,x,y&#x27;);</span><br><span class="line">z1 = z1&#x27;; <span class="comment">% 转置z1回正常的对应</span></span><br><span class="line"><span class="comment">% csape正常进行</span></span><br><span class="line">pp = csape(&#123;x0,y0&#125;,z0);</span><br><span class="line">z2 = fnval(pp,&#123;x,y&#125;);</span><br><span class="line"><span class="comment">%% DispMesh</span></span><br><span class="line"><span class="comment">% mesh函数的x为列，y为行，需要将xy反写</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;Position&#x27;</span>,[<span class="number">500</span>,<span class="number">300</span>,<span class="number">1000</span>,<span class="number">600</span>])</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">mesh(y,x,z1) </span><br><span class="line">title(<span class="string">&#x27;Interp1-Linear&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">mesh(y,x,z2)</span><br><span class="line">title(<span class="string">&#x27;Spline&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">20</span>)</span><br><span class="line"><span class="comment">%% MAXValue</span></span><br><span class="line"><span class="comment">% interp-Linear</span></span><br><span class="line">[maxls1,xlocls1] = <span class="built_in">max</span>(z1); <span class="comment">% 按列取max</span></span><br><span class="line">[vmax1,yloc1] = <span class="built_in">max</span>(maxls1); <span class="comment">% 按行取max</span></span><br><span class="line">info1 = [<span class="string">&quot;interp-Linear&quot;</span>,x(xlocls1(yloc1)),y(yloc1),vmax1]; </span><br><span class="line">    <span class="comment">% 行loc索引列ls的loc,并用loc索引相应的x,y的值</span></span><br><span class="line"><span class="comment">% Spline</span></span><br><span class="line">[maxls2,xlocls2] = <span class="built_in">max</span>(z2);</span><br><span class="line">[vmax2,yloc2] = <span class="built_in">max</span>(maxls2);</span><br><span class="line">info2 = [<span class="string">&quot;Spline&quot;</span>,x(xlocls2(yloc2)),y(yloc2),vmax2]; </span><br><span class="line">info = [info1;info2];</span><br><span class="line"><span class="comment">% 更好的位置索引方法</span></span><br><span class="line">[<span class="built_in">i</span>,<span class="built_in">j</span>]=<span class="built_in">find</span>(z2==<span class="built_in">max</span>(<span class="built_in">max</span>(z2)));  <span class="comment">%找最高点的地址</span></span><br><span class="line">xm=x(<span class="built_in">i</span>),ym=y(<span class="built_in">j</span>),zm=z2(<span class="built_in">i</span>,<span class="built_in">j</span>);  <span class="comment">%求最高点的坐标 </span></span><br><span class="line">[zm,xm,ym]</span><br><span class="line"><span class="comment">%% DispMAX</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;Step:&#x27;</span> num2str(step)])</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;Type:&#x27;</span> num2str(info(<span class="built_in">i</span>,<span class="number">1</span>))]) </span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;max = &#x27;</span> num2str(info(<span class="built_in">i</span>,<span class="number">4</span>)) ...</span><br><span class="line">        <span class="string">&#x27;    x = &#x27;</span> num2str(info(<span class="built_in">i</span>,<span class="number">2</span>)) ...</span><br><span class="line">        <span class="string">&#x27;    y = &#x27;</span> num2str(info(<span class="built_in">i</span>,<span class="number">3</span>))])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong><em>output</em></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  720.7217  165.0000  175.0000</span><br><span class="line">Step:5</span><br><span class="line">Type:interp-Linear</span><br><span class="line">max = 712    x = 200    y = 200</span><br><span class="line">Type:Spline</span><br><span class="line">max = 720.7217    x = 165    y = 175</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/XLY23333/picture01/img01/eg53output.jpg" style="zoom: 50%;" /></p>
<h4 id="Eg5-4-海底图像"><a href="#Eg5-4-海底图像" class="headerlink" title="Eg5.4 海底图像"></a>Eg5.4 海底图像</h4><blockquote>
<p>在某海域测得一些点（x,y）处的水深z由表5.4给出，在适当的矩形区域内画出海底曲面的图形。</p>
</blockquote>
<p>Data：</p>
<blockquote>
<p>x=[129,140,103.5,88,185.5,195,105,157.5,107.5,77,81,162,162,117.5];</p>
<p>y=[7.5,141.5,23,147,22.5,137.5,85.5,-6.5,-81,3,56.5,-66.5,84,-33.5];</p>
<p>z=-[4,8,6,8,6,8,8,9,9,8,8,9,4,9];</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line"><span class="comment">%% DataLoad</span></span><br><span class="line">x=[<span class="number">129</span>,<span class="number">140</span>,<span class="number">103.5</span>,<span class="number">88</span>,<span class="number">185.5</span>,<span class="number">195</span>,<span class="number">105</span>,<span class="number">157.5</span>,<span class="number">107.5</span>,<span class="number">77</span>,<span class="number">81</span>,<span class="number">162</span>,<span class="number">162</span>,<span class="number">117.5</span>];</span><br><span class="line">y=[<span class="number">7.5</span>,<span class="number">141.5</span>,<span class="number">23</span>,<span class="number">147</span>,<span class="number">22.5</span>,<span class="number">137.5</span>,<span class="number">85.5</span>,<span class="number">-6.5</span>,<span class="number">-81</span>,<span class="number">3</span>,<span class="number">56.5</span>,<span class="number">-66.5</span>,<span class="number">84</span>,<span class="number">-33.5</span>];</span><br><span class="line">z=-[<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>];</span><br><span class="line">step = <span class="number">1</span>;</span><br><span class="line">XI = <span class="built_in">min</span>(x):step:<span class="built_in">max</span>(x)</span><br><span class="line">YI = <span class="built_in">min</span>(y):step:<span class="built_in">max</span>(y)</span><br><span class="line"><span class="comment">%% grid</span></span><br><span class="line">ZI1=griddata(x,y,z,XI,YI&#x27;,<span class="string">&#x27;cubic&#x27;</span>); <span class="comment">%立方插值</span></span><br><span class="line">ZI2=griddata(x,y,z,XI,YI&#x27;,<span class="string">&#x27;nearest&#x27;</span>); <span class="comment">%最近点插值</span></span><br><span class="line">ZI = ZI1; <span class="comment">% 设置ZI初始值为ZI1</span></span><br><span class="line">ZI(<span class="built_in">isnan</span>(ZI1)) = ZI2(<span class="built_in">isnan</span>(ZI1)); <span class="comment">% 用ZI2填充ZI1外插值(为NaN)的部分</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">mesh(XI,YI,ZI)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,<span class="string">&#x27;or&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong><em>Pic</em></strong></p>
<p><img src="F:\Blog\BOX\output\eg54output.jpg" style="zoom: 80%;" /></p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
